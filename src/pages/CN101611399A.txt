<!DOCTYPE html><html><head><title>专利 CN101611399A - 网页、网站建模和生成 -  Google 专利</title><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){var d=void 0!=b?b:(new Date).getTime();this.t[a]=[d,c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(e){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_",
"_wtsrt",d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})();
</script><link rel="stylesheet" href="/patents/css/_50a6672b5f82ffbd39b7a9e87fd4594c/kl_intl_patents_bundle.css" type="text/css" /><script src="/books/javascript/atb_50a6672b5f82ffbd39b7a9e87fd4594c__zh_cn.js"></script><script>function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: "zh",gaTrack: true,gaId: "UA-27188110-1",multilanguagePage: true});}</script><script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><meta name="DC.type" content="Patent"><meta name="DC.title" content="网页、网站建模和生成"><meta name="DC.contributor" content="凡 罗" scheme="inventor"><meta name="DC.contributor" content="凡 罗" scheme="assignee"><meta name="DC.date" content="2008-2-12" scheme="dateSubmitted"><meta name="DC.description" content="发明了组件模型用于建模网页。网页和位置可通过组件汇编来构造。组件封装在构造过程中来自用户的HTML元素的细节。通过展出组件作为服务，组件可在其他网站中被重用并使得网站能聚合。抽象页面代表网页；抽象镶嵌代表网页的组件或部分。镶嵌可本地或远程地被本地到任何有意义信息。镶嵌可悬挂于页面上的不同行和列位置处，以形成用于呈现网页的图案。其他镶嵌可以与镶嵌悬挂于页面上相同的方式悬挂于镶嵌上，嵌套级别是任意高的。"><meta name="DC.date" content="2009-12-23"><meta name="citation_patent_publication_number" content="CN:101611399:A"><meta name="citation_patent_application_number" content="CN:200880005210"><link rel="canonical" href="https://www.google.com/patents/CN101611399A?cl=zh"/><meta property="og:url" content="https://www.google.com/patents/CN101611399A?cl=zh"/><meta name="title" content="专利 CN101611399A - 网页、网站建模和生成"/><meta name="description" content="发明了组件模型用于建模网页。网页和位置可通过组件汇编来构造。组件封装在构造过程中来自用户的HTML元素的细节。通过展出组件作为服务，组件可在其他网站中被重用并使得网站能聚合。抽象页面代表网页；抽象镶嵌代表网页的组件或部分。镶嵌可本地或远程地被本地到任何有意义信息。镶嵌可悬挂于页面上的不同行和列位置处，以形成用于呈现网页的图案。其他镶嵌可以与镶嵌悬挂于页面上相同的方式悬挂于镶嵌上，嵌套级别是任意高的。"/><meta property="og:title" content="专利 CN101611399A - 网页、网站建模和生成"/><meta property="og:type" content="book"/><meta property="og:site_name" content="Google Books"/><meta property="og:image" content="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><link rel="image_src" href="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><script>if (window['_OC_timingAction']) {window['_OC_timingAction']('patents_refpage');}</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}@media all{.gb1{height:22px;margin-right:.5em;vertical-align:top}#gbar{float:left}}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb4{color:#00c !important}.gbi .gb4{color:#dd8e27 !important}.gbf .gb4{color:#900 !important}

#gbar { padding:.3em .6em !important;}</style></head><body ><div id=gbar><nobr><a class=gb1 href="https://www.google.com/search?cl=zh&hl=zh-CN&sa=N&tab=tw">搜索</a> <a class=gb1 href="https://www.google.com/search?cl=zh&hl=zh-CN&tbm=isch&source=og&sa=N&tab=ti">图片</a> <a class=gb1 href="https://maps.google.com/maps?cl=zh&hl=zh-CN&sa=N&tab=tl">地图</a> <a class=gb1 href="https://play.google.com/?cl=zh&hl=zh-CN&sa=N&tab=t8">Play</a> <a class=gb1 href="https://www.youtube.com/results?cl=zh&hl=zh-CN&sa=N&tab=t1">YouTube</a> <a class=gb1 href="https://news.google.com/nwshp?hl=zh-CN&tab=tn">新闻</a> <a class=gb1 href="https://mail.google.com/mail/?tab=tm">Gmail</a> <a class=gb1 href="https://drive.google.com/?tab=to">云端硬盘</a> <a class=gb1 style="text-decoration:none" href="https://www.google.com/intl/zh-CN/options/"><u>更多</u> &raquo;</a></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a target=_top id=gb_70 href="https://www.google.com/accounts/Login?service=&continue=https://www.google.com/patents%3Fcl%3Dzh%26hl%3Dzh-CN&hl=zh-CN" class=gb4>登录</a></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div><div role="alert" style="position: absolute; left: 0; right: 0;"><a href="https://www.google.com/patents/CN101611399A?cl=zh&amp;hl=zh-CN&amp;output=html_text" title="屏幕阅读器用户请注意：点击此链接可进入无障碍模式。阅读器在无障碍模式下具有同样的基本功能，但可让用户获得更好的体验。"><img border="0" src="//www.google.com/images/cleardot.gif"alt="屏幕阅读器用户请注意：点击此链接可进入无障碍模式。阅读器在无障碍模式下具有同样的基本功能，但可让用户获得更好的体验。"></a></div><div class="kd-appbar"><h2 class="kd-appname"><a href="/patents?hl=zh-CN"> 专利</a></h2><div class="kd-buttonbar left" id="left-toolbar-buttons"><a id="appbar-write-review-link" href=""></a><a id="appbar-view-print-sample-link" href=""></a><a id="appbar-view-ebook-sample-link" href=""></a><a id="appbar-patents-prior-art-finder-link" href="https://www.google.com/patents/related/CN101611399A"></a><a id="appbar-patents-discuss-this-link" href="https://www.google.com/url?id=XtJ1BwABERAJ&amp;q=http://patents.stackexchange.com/redirect/google-patents%3Fpublication%3DCN101611399A&amp;usg=AFQjCNHf-B7HaNtOPCGlh7cEluA3dbfmzw" data-is-grant="false"></a><a id="appbar-read-patent-link" href="//docs.google.com/viewer?url=patentimages.storage.googleapis.com/pdfs/a0e0900312244c8de42d/CN101611399A.pdf"></a><a id="appbar-download-pdf-link" href="//patentimages.storage.googleapis.com/pdfs/a0e0900312244c8de42d/CN101611399A.pdf"></a><a class="appbar-content-language-link" data-selected="true" data-label="中文" href="/patents/CN101611399A?cl=zh&amp;hl=zh-CN"></a><a class="appbar-content-language-link" data-label="英语" href="/patents/CN101611399A?cl=en&amp;hl=zh-CN"></a></div><div class="kd-buttonbar right" id="right-toolbar-buttons"></div></div><div id="books-microdata" itemscope=""itemtype="http://schema.org/Book"itemid="https://www.google.com/patents/CN101611399A?cl=zh" style="display:none"><span itemprop="description">发明了组件模型用于建模网页。网页和位置可通过组件汇编来构造。组件封装在构造过程中来自用户的HTML元素的细节。通过展出组件作为服务，组件可在其他网站中被重用并使得网站能聚合。抽象页面代表网页；抽象镶嵌代表 ...</span><span itemprop="url">https://www.google.com/patents/CN101611399A?cl=zh&amp;utm_source=gb-gplus-share</span><span class="main-title" itemprop="name">专利 CN101611399A - 网页、网站建模和生成</span><img itemprop="image" src="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"alt="专利 CN101611399A - 网页、网站建模和生成" title="专利 CN101611399A - 网页、网站建模和生成"></div><div style="display: none"><ol id="ofe-gear-menu-contents" class="gbmcc"><li class="gbe gbmtc"><a class="gbmt goog-menuitem-content" id="" href="https://www.google.com/advanced_patent_search?hl=zh-CN"> 高级专利搜索</a></li></ol></div><div id="volume-main"><div id="volume-center"><div class=vertical_module_list_row><div id=intl_patents class=about_content><div id=intl_patents_v><table class="patent-bibdata patent-drawings-missing"><tr><td class="patent-bibdata-heading"> 公开号</td><td class="single-patent-bibdata">CN101611399 A</td></tr><tr><td class="patent-bibdata-heading">发布类型</td><td class="single-patent-bibdata">申请</td></tr><tr><td class="patent-bibdata-heading"> 专利申请号</td><td class="single-patent-bibdata">CN 200880005210</td></tr><tr><td class="patent-bibdata-heading"> 专利合作条约 (PCT) 编号</td><td class="single-patent-bibdata">PCT/IB2008/050493</td></tr><tr><td class="patent-bibdata-heading">公开日</td><td class="single-patent-bibdata">2009年12月23日</td></tr><tr><td class="patent-bibdata-heading"> 申请日期</td><td class="single-patent-bibdata">2008年2月12日</td></tr><tr><td class="patent-bibdata-heading"> 优先权日<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="优先日期属于假设性质，不具任何法律效力。Google 对于所列日期的正确性并没有进行法律分析，也不作任何陈述。"></span></td><td class="single-patent-bibdata">2007年2月16日</td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">公告号</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/US20080201118?hl=zh-CN&amp;cl=zh">US20080201118</a>, </span><span class="patent-bibdata-value"><a href="/patents/WO2008099333A1?hl=zh-CN&amp;cl=zh">WO2008099333A1</a></span></span></td></tr><tr class="patent-bibdata-list-row alternate-patent-number"><td class="patent-bibdata-heading"> 公开号</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value">200880005210.2, </span><span class="patent-bibdata-value">CN 101611399 A, </span><span class="patent-bibdata-value">CN 101611399A, </span><span class="patent-bibdata-value">CN 200880005210, </span><span class="patent-bibdata-value">CN-A-101611399, </span><span class="patent-bibdata-value">CN101611399 A, </span><span class="patent-bibdata-value">CN101611399A, </span><span class="patent-bibdata-value">CN200880005210, </span><span class="patent-bibdata-value">CN200880005210.2, </span><span class="patent-bibdata-value">PCT/2008/50493, </span><span class="patent-bibdata-value">PCT/IB/2008/050493, </span><span class="patent-bibdata-value">PCT/IB/2008/50493, </span><span class="patent-bibdata-value">PCT/IB/8/050493, </span><span class="patent-bibdata-value">PCT/IB/8/50493, </span><span class="patent-bibdata-value">PCT/IB2008/050493, </span><span class="patent-bibdata-value">PCT/IB2008/50493, </span><span class="patent-bibdata-value">PCT/IB2008050493, </span><span class="patent-bibdata-value">PCT/IB200850493, </span><span class="patent-bibdata-value">PCT/IB8/050493, </span><span class="patent-bibdata-value">PCT/IB8/50493, </span><span class="patent-bibdata-value">PCT/IB8050493, </span><span class="patent-bibdata-value">PCT/IB850493</span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading"> 发明者</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22%E5%87%A1+%E7%BD%97%22">凡 罗</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading"> 申请人</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=inassignee:%22%E5%87%A1+%E7%BD%97%22">凡 罗</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">导出引文</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/CN101611399A.bibtex?cl=zh">BiBTeX</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN101611399A.enw?cl=zh">EndNote</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN101611399A.ris?cl=zh">RefMan</a></span></span></td></tr><tr class="patent-internal-links"><td colspan=2><span class="patent-bibdata-value"><a href="#forward-citations"> 被以下专利引用</a> (7),</span> <span class="patent-bibdata-value"><a href="#classifications">分类</a> (5),</span> <span class="patent-bibdata-value"><a href="#legal-events">法律事件</a> (3)</span> </td></tr><tr><td colspan=2 class="patent-bibdata-external-link-spacer-top"></td></tr><tr class="patent-bibdata-external-link-spacer-bottom"></tr><tr><td colspan=2><span class="patent-bibdata-heading">外部链接:&nbsp;</span><span><span class="patent-bibdata-value"><a href="https://www.google.com/url?id=XtJ1BwABERAJ&amp;q=http://211.157.104.87:8080/sipo/zljs/hyjs-yx-new.jsp%3Frecid%3D200880005210&amp;usg=AFQjCNEU7vVaAzb1jCohbGwSEH2vpxSzog"> 中国国家知识产权局</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/url?id=XtJ1BwABERAJ&amp;q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DCN%26NR%3D101611399A%26KC%3DA%26FT%3DD&amp;usg=AFQjCNEJ7c1_SjyVEchEwfW8WYDkFlFTLw"> 欧洲专利数据库 (Espacenet)</a></span></span></td></tr><tr class="patent-bibdata-group-spacer"></tr></table><div class="number-and-title"><span class="patent-title"><invention-title mxw-id="PT91322816" lang="ZH" load-source="patent-office">网页、网站建模和生成</invention-title>
      </span><br><span class="patent-number">CN 101611399 A</span></div><div class="patent-section patent-abstract-section"><div class="patent-section-header"><span class="patent-section-title"> 摘要</span></div><div class="patent-text"><abstract mxw-id="PA71990928" lang="ZH" load-source="patent-office">
    <div class="abstract">发明了组件模型用于建模网页。网页和位置可通过组件汇编来构造。组件封装在构造过程中来自用户的HTML元素的细节。通过展出组件作为服务，组件可在其他网站中被重用并使得网站能聚合。抽象页面代表网页；抽象镶嵌代表网页的组件或部分。镶嵌可本地或远程地被本地到任何有意义信息。镶嵌可悬挂于页面上的不同行和列位置处，以形成用于呈现网页的图案。其他镶嵌可以与镶嵌悬挂于页面上相同的方式悬挂于镶嵌上，嵌套级别是任意高的。</div>
  </abstract>
  </div></div><div class="patent-section patent-claims-section"><div class="patent-section-header"><span class="patent-section-title">权利要求<span class="patent-section-count">(59)</span></span></div><div class="patent-text"><div mxw-id="PCLM28441865" lang="ZH" load-source="patent-office" class="claims">
    <div class="claim"> <div num="1" class="claim">
      <div class="claim-text">1.一种用于建模由web容器生成的网页的系统，包括：    实体，其定义所有实体的顶层超集并实现适用于所有实体的公共方法；    镶嵌，其继承所述实体并代表所述网页的组件；    页面，其继承所述实体并代表所述网页；    镶嵌悬挂，其继承所述实体并处理将镶嵌悬挂于页面或另一个镶嵌上由X变量代表的水平或行位置以及由Y变量代表的垂直或列位置处的关系；    镶嵌绑定，其继承所述实体并且将镶嵌绑定到除页面和镶嵌实体外的实体的实例，并且使所述镶嵌代表所述实体。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="2" class="claim">
      <div class="claim-text">2. 如权利要求1所述的系统，其特征在于，还包括：页面映射，其继承所述实体并且将页面映射到除页面实体外的实体的实例； 页面孩子，其继承所述实体并处理父页面与其子页面的关系；树形镶嵌悬挂，其继承所述实体并通过将镶嵌悬挂于经过滤页面上由X变量代表的水 平或行位置以及由Y变量代表的垂直或列位置处来将所述镶嵌应用于页面树；镶嵌引用，其继承所述实体并处理镶嵌本地或远程地弓l用另一个镶嵌的关系； 页面引用，其继承所述实体并处理页面本地或远程地引用另一个页面的关系。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="3" class="claim">
      <div class="claim-text">3. 如权利要求1所述的系统，其特征在于，还包括：公共访问，其以指定访问级别无、读取、编辑、删除、或创建来标注页面对于公共的可 访问性，其各自比前一个具有更多权限并且分别由数字O、 1、 2、 3、 4来表示；访问组，其继承所述实体并代表通过用户信息、所述用户来自的位置、指定访问级别的 因子来定义页面的可访问性的访问组，其中所述指定访问级别为无、读取、编辑、删除或创建 中的任一个，其各自比前一个具有更多权限并且分别由数字O、 1、 2、 3、 4来表示；页面访问，其维持页面的可访问性信息的信息用于在用户访问所述页面时进行授权；搜索框，其继承所述实体并定义对页面的目录树的搜索准则以及返回遵循所述搜索准则 的实体列表；媒体，其代表未保存在数据库中的文件并处理对所述文件的检索和移除。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="4" class="claim">
      <div class="claim-text">4. 如权利要求1所述的系统，其特征在于，还包括： 实体呈现，其定义用于呈现实体的公共方法的签名；媒体接口 ，其定义用于检索未保存在数据库中的文件的公共方法的签名； 搜索接口 ，其定义用于提供对搜索的排序支持的公共方法的签名； 服务器动作接口 ，其定义用于在所述web容器上执行异步任务的公共方法的签名； 搜索呈现，其定义用于呈现通过搜索产生并由所述搜索接口的实例排序的实体列表的公 共方法的签名；页面呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现页面、检索相关联外部文件、排序通过搜索产生的页面列表、以及执行与页面相关的异步任务; 镶嵌呈现，其实现所述实体呈现以呈现镶嵌； 访问组呈现，其实现所述实体呈现以呈现访问组； 搜索框呈现，其实现所述实体呈现以呈现搜索框。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="5" class="claim">
      <div class="claim-text">5. 如权利要求1所述的系统，其特征在于，还包括： Servlet处理，用于处理请求并生成响应；Servlet基，其继承HttpServlet以接收由所述web容器提供的服务并定义用于在其子类中 进行继承和使用的公共方法；Servlet呈现，其定义用于在收到所述web容器的请求之后生成响应的呈现的公共方法的签名；多部分请求，用于在请求是"多部分/格式-数据"类型的情况下解析参数值对和二进制 流上传，并且在被实例化时，代表所述请求的HttpServlet请求的实例被传入作为唯一自变量;Servlet会话，其继承所述多部分请求并充当访问和操纵存储在Http会话中的信息的适配 器或外观，并且在被实例化时，代表请求的HttpServlet请求的实例被传入作为唯一自变量。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="6" class="claim">
      <div class="claim-text">6. 如权利要求1所述的系统，其特征在于，还包括以下任一项： 文档，其继承所述实体并代表文档；音乐，其继承所述实体并代表音乐； 图片，其继承所述实体并代表图片； 视频，其继承所述实体并代表视频；收藏，其继承所述实体并代表因特网浏览器的"收藏夹"中的收藏链接； 网页，其继承所述实体并代表保存在本地文件夹中的html文件及其相关联内容； Html文本，其继承所述实体并代表html代码片段； 简单文本，其继承所述实体并代表简单文本块。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="7" class="claim">
      <div class="claim-text">7. 如权利要求4所述的系统，其特征在于，还包括以下任一项：文档呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现文 档、检索相关联外部文件、排序通过搜索产生的页面列表、以及执行与文档相关的异步任务；音乐呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现音 乐、检索相关联外部文件、排序通过搜索产生的音乐列表、以及执行与音乐相关的异步任务;图片呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现图 片、检索相关联外部文件、排序通过搜索产生的图片列表、以及执行与图片相关的异步任务；视频呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现视 频、检索相关联外部文件、排序通过搜索产生的视频列表、以及执行与视频相关的异步任务；收藏呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现收 藏、检索相关联外部文件、排序通过搜索产生的收藏列表、以及执行与收藏相关的异步任务；网页呈现，其实现所述实体呈现、媒体接口、搜索接口、以及服务器动作接口以呈现网页、检索相关联外部文件、排序通过搜索产生的网页列表、以及执行与网页相关的异步任务; Html文本呈现，其实现所述实体呈现以呈现Html文本； 简单文本呈现，其实现所述实体呈现以呈现简单文本。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="8" class="claim">
      <div class="claim-text">8. 如权利要求5所述的系统，其特征在于，还包括：页面Servlet，其继承Servlet基并实现Servlet呈现以在收到对页面的请求后生成所述网页；管理页面，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新和移除页面；管理镶嵌，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新和移除镶嵌；管理访问组，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、 读取、更新和移除访问组；管理搜索框，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、 读取、更新和移除搜索框。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="9" class="claim">
      <div class="claim-text">9. 如权利要求5所述的系统，其特征在于，还包括：服务器动作控制器，其继承Servlet基并处理对请求的接收和派遣以开始异步任务。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="10" class="claim">
      <div class="claim-text">10. 如权利要求8所述的系统，其特征在于，还包括以下任一项：管理文档，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新、上传和移除文档；管理音乐，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新、上传和移除音乐；管理图片，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新、上传和移除图片；管理视频，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新、上传和移除视频；管理收藏，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新、上传和移除收藏；管理网页，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、读 取、更新、上传和移除网页；管理Html文本，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、 读取、更新和移除Html文本；管理简单文本，其继承Servlet基并实现Servlet呈现以提供基于浏览器的接口用于创建、 读取、更新和移除简单文本。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="11" class="claim">
      <div class="claim-text">11. 如权利要求l所述的系统，其特征在于，镶嵌被绑定到Servlet呈现的实现类以代表 所述Servlet呈现的实现类的实例的输出，并且其关系由镶嵌绑定通过标识所述Servlet呈现实现类的完全匹配类名的"标识符"字段和"类名"字段以及标识所述镶嵌的"镶嵌"字段来处理。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="12" class="claim">
      <div class="claim-text">12. 如权利要求l所述的系统，其特征在于，镶嵌被悬挂于Servlet呈现实现类上，并且 其关系由镶嵌悬挂通过标识所述Servlet呈现实现类的完全匹配类名的"标识符"字段和"类 名"字段和标识所述镶嵌的"镶嵌"字段以及由X变量和Y变量标识的悬挂位置来处理。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="13" class="claim">
      <div class="claim-text">13. 如权利要求l所述的系统，其特征在于，通过将悬挂位置的X和Y值皆指定为负来 将镶嵌悬挂于所述web页面的标题区上。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="14" class="claim">
      <div class="claim-text">14. 如权利要求l所述的系统，其特征在于，页面有4中类型：专用、目录型、弓l用、 和目录。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="15" class="claim">
      <div class="claim-text">15. 如权利要求14所述的系统，其特征在于，专用类型页面是页面自身且未映射到任何 实体的页面，或者是映射到除页面外的任何实体，所述任何实体是镶嵌、文档、音乐、图片、 视频、收藏、网页、简单文本、Html文本、搜索框或访问组中任意一个。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="16" class="claim">
      <div class="claim-text">16. 如权利要求15所述的系统，其特征在于，映射到镶嵌的页面具有将所述镶嵌悬挂于 所述页面上预定义位置的镶嵌悬挂以及将所述页面映射到所述镶嵌的页面映射。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="17" class="claim">
      <div class="claim-text">17. 如权利要求15所述的系统，其特征在于，映射到除页面和镶嵌外的实体的页面具有 将镶嵌绑定到所述实体的镶嵌绑定、将所述镶嵌悬挂于所述页面上预定义位置的镶嵌悬挂以及 将所述页面映射到所述实体的页面映射。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="18" class="claim">
      <div class="claim-text">18. 如权利要求14所述的系统，其特征在于，目录型类型页面用作维持映射到由所述实 体的实体呈现实现类的完全匹配类名标识的相同类型实体的一组子页面的父页面。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="19" class="claim">
      <div class="claim-text">19. 如权利要求14所述的系统，其特征在于，引用类型页面本地或远程地引用另一个页 面，并且所述弓l用页面和所述被弓l用页面的关系维持在页面引用中。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="20" class="claim">
      <div class="claim-text">20. 如权利要求14所述的系统，其特征在于，目录类型页面维持包括另一个目录类型页 面的所有类型的页面作为其子页面。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="21" class="claim">
      <div class="claim-text">21. 如权利要求l所述的系统，其特征在于，镶嵌有4中类型：专用、目类型、用于、 和目录。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="22" class="claim">
      <div class="claim-text">22. 如权利要求21所述的系统，其特征在于，专用类型镶嵌是镶嵌自身且未绑定到任何 实体的镶嵌，或者是绑定到除页面和镶嵌外的任何实体作为文档、音乐、图片、视频、收藏、 网页、简单文本、Html文本、搜索框或访问组之一的镶嵌，并且镶嵌与实体的绑定关系由镶 嵌绑定来处理。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="23" class="claim">
      <div class="claim-text">23. 如权利要求21所述的系统，其特征在于，目录型类型镶嵌充当父镶嵌并且绑定到由 所述实体的实体呈现实现类的完全匹配类名标识的相同类型实体的一组专用镶嵌悬挂于其上， 父镶嵌和悬挂于父镶嵌上的子镶嵌的关系由镶嵌悬挂来处理。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="24" class="claim">
      <div class="claim-text">24. 如权利要求21所述的系统，其特征在于，引用类型镶嵌本地或远程地引用另一个镶 嵌，并且所述引用镶嵌和所述被引用镶嵌的关系由镶嵌引用来处理。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="25" class="claim">
      <div class="claim-text">25. 如权利要求21所述的系统，其特征在于，目录类型镶嵌充当父镶嵌并且包括另一个目录类型镶嵌的所有类型的镶嵌悬挂于其上。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="26" class="claim">
      <div class="claim-text">26. 如权利要求1所述的系统，其特征在于，镶嵌通过镶嵌绑定被绑定到函数以呈现执 行所述函数的结果。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="27" class="claim">
      <div class="claim-text">27. 如权利要求1所述的系统，其特征在于，镶嵌通过镶嵌绑定被绑定到搜索框以呈现 所述搜索框的搜索结果。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="28" class="claim">
      <div class="claim-text">28. 如权利要求l所述的系统，其特征在于，镶嵌通过私有API展出作为服务并被其他 网站消费。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="29" class="claim">
      <div class="claim-text">29. 如权利要求1所述的系统，其特征在于，通过将镶嵌与函数绑定的镶嵌绑定将所述 镶嵌绑定到消费通过网站的私有API展出的服务的函数。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="30" class="claim">
      <div class="claim-text">30. 如权利要求1所述的系统，其特征在于，镶嵌通过WSDL (web服务描述语言）展 出作为web服务以定义服务端点和端口，并被其他网站消费以对所述镶嵌进行重用。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="31" class="claim">
      <div class="claim-text">31. 如权利要求l所述的系统，其特征在于，通过将镶嵌与消费web服务的函数绑定的 镶嵌绑定，将所述镶嵌绑定到消费通过网站的标准化WSDL展出的web服务的函数。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="32" class="claim">
      <div class="claim-text">32. 如权利要求l所述的系统，其特征在于，所述镶嵌被封入html表的行的单元格中， 所述单元格、行、表分别由单元格ID、行ID和表ID的唯一 ID标识，从而镶嵌的外观通过定 义单元格ID、行ID和表ID的样式表信息并将其保存在外部CSS文件中来调整。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="33" class="claim">
      <div class="claim-text">33. 如权利要求32所述的系统，其特征在于，由镶嵌的标识符加上文件扩展".css"标识的 外部CSS文件包含所述镶嵌的所有派生镶嵌的所有单元格ID、行ID和表ID样式表信息。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="34" class="claim">
      <div class="claim-text">34. 如权利要求33所述的系统，其特征在于，当所述镶嵌被其他网站通过服务请求时， 所述外部CSS文件被嵌入所述输出中。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="35" class="claim">
      <div class="claim-text">35. 如权利要求3所述的系统，其特征在于，搜索框维持将被搜索的目录树的顶页面、 指示从所述顶页面向下深入所述目录树的搜索程度的深度级别、所述搜索框正搜索的页面的类 型、指示所述搜索框正搜索的特定类型实体的实体的实体呈现实现类的完全匹酉己类名、搜索基 于的与搜索结果的次序有关的参数、指示所述次序的升序或降序的方向的信息。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="36" class="claim">
      <div class="claim-text">36. 如权利要求4所述的系统，其特征在于，实体呈现的公共方法的签名即获取呈现， 返回结果作为对象并要求7个自变量：代表请求的HttpServlet请求的实例、代表响应的 HttpServlet响应的实例、代表当前会话的Servlet会话的实例、用于处理所述请求并生成所述 响应的Servlet处理的实例、用于接收所述请求并从web容器送出所述响应的Servlet基的实例、 作为代表一系列缓冲器的关键字链的对象数组、作为实体的实例的标识符的对象。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="37" class="claim">
      <div class="claim-text">37. 如权利要求4所述的系统，其特征在于，媒体接口的公共方法的签名即获取媒体返 回媒体的实例并要求两个变量：作为实体的实例的标识符的对象以及所述媒体的子类型。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="38" class="claim">
      <div class="claim-text">38. 如权利要求4所述的系统，其特征在于，搜索接口的公共方法的签名即排序返回实 体的排序列表并要求4个变量：实体的未排序列表、指定"排序依据"参数的字符串、指定"升 序"或"降序"的次序方向的字符串、语言偏好。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="39" class="claim">
      <div class="claim-text">39. 如权利要求4所述的系统，其特征在于，服务器动作接口的唯一公共方法的签名即执行动作，返回空或不返回并要求5个自变量：代表请求的HttpServlet请求的实例、代表响 应的HttpServlet响应的实例、代表当前会话的Servlet会话的实例、用于处理所述请求并生成 所述响应的Servlet处理的实例、用于接收所述请求并从web容器送出所述响应的Servlet基的 实例。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="40" class="claim">
      <div class="claim-text">40. 如权利要求4所述的系统，其特征在于，搜索呈现的公共方法的签名即获取呈现， 返回结果作为对象并要求8个自变量：代表请求的HttpServlet请求的实例、代表响应的 HttpServlet响应的实例、代表当前会话的Servlet会话的实例、用于处理所述请求并生成所述 响应的Servlet处理的实例、用于接收所述请求并从web容器送出所述响应的Servlet基的实例、 作为代表一系列缓冲器的关键字链的对象数组、作为搜索框实例的标识符的对象、实体的排序 列表。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="41" class="claim">
      <div class="claim-text">41. 如权利要求5所述的系统，其特征在于，Servlet处理被4个自变量实例化：代表请 求的HttpServlet请求的实例、代表响应的HttpServlet响应的实例、代表当前会话的Servlet会 话的实例、用于接收所述请求并从web容器送出所述响应的Servlet基的实例。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="42" class="claim">
      <div class="claim-text">42. 如权利要求41所述的系统，其特征在于，所述Servlet处理的实例实现用于开始处理 请求并生成响应的"开始(）"方法、用于同步所产生的所有线程的共享对象、以对象数组的两 个自变量为关键字链以及对象作为所生成内容的用于将所述内容保存在缓冲器中并将所述缓 冲器中的所述内容在缓冲器层次中向上推一级的"打印(）"方法、以对象数组的一个自变量为 关键字链的用于将缓冲器中保存的所述内容在缓冲器层次中向上推一级的"已打印(）"方法、 以及用于结束该过程的"结束(）"方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="43" class="claim">
      <div class="claim-text">43. 如权利要求5所述的系统，其特征在于，所述Servlet基实现用于授权用户的检查访 问方法、用于将页面映射到实体的映射页面方法、用于移除所述映射关系的解映射页面方法、 产生新线程并封入Servlet处理的实例的"开始(）"方法的开始方法、封入Servlet处理的实例 的"结束(）"方法的结束方法、封入所述开始和结束方法的完成方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="44" class="claim">
      <div class="claim-text">44. 如权利要求5所述的系统，其特征在于，Servlet呈现的唯一公共方法的签名即获取 呈现，返回结果作为对象并要求6个自变量：代表请求的HttpServlet请求的实例、代表响应 的HttpServlet响应的实例、代表当前会话的Servlet会话的实例、用于处理所述请求并生成所 述响应的Servlet处理的实例、用于接收所述请求并从web容器送出所述响应的Servlet基的实 例、作为代表一系列缓冲器的关键字链的对象数组。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="45" class="claim">
      <div class="claim-text">45. 如权利要求5所述的系统，其特征在于，Servlet会话的实例存储用于会话范围宽度 信息共享并由Http会话中的会话ID标识的会话范围散列表、用于会话的每次相同请求URI 拜访的累积信息并由Http会话中的请求URI标识的请求范围散列表。</div>
    </div>
    </div> <div class="claim"> <div num="46" class="claim">
      <div class="claim-text">46. &#8212;种用于通过web容器生成网页的方法，包括：接收代表对所述网页的请求的HttpServlet请求的实例，以及接收用于通过Servlet基的实 例送回响应的HttpServlet响应的实例；通过HttpServlet请求的实例来实例化Servlet会话的实例；通过HttpServlet请求的实例、H邻Servlet响应的实例、Servlet会话的实例以及Servlet基 的实例来实例化Servlet处理的实例；在将所述HttpServlet请求的实例、所述HttpServlet响应的实例、所述Servlet会话的实例 以及所述Servlet处理的实例传递给Servlet基的开始方法后执行所述开始方法；在将所述HttpServlet请求的实例、所述HttpServlet响应的实例、所述Servlet会话的实例 以及所述Servlet处理的实例传递给Servlet基的结束方法后执行所述结束方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="47" class="claim">
      <div class="claim-text">47. 如权利要求46所述的方法，其特征在于，所述执行开始方法的步骤还包括： 产生线程并将所述HttpServlet请求的实例、所述HttpServlet响应的实例、所述Servlet会话的实例、所述Servlet处理的实例、以及所述Servlet基的实例传递至所述线程； 执行所述线程。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="48" class="claim">
      <div class="claim-text">48. 如权利要求47所述的方法，其特征在于，所述执行所述线程的步骤还包括： 执行所述Servlet处理的实例的"开始(）"方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="49" class="claim">
      <div class="claim-text">49. 如权利要求48所述的方法，其特征在于，所述执行所述"开始(）"方法的步骤进一 步包括：实例化标注线程层次组织的开始点的名为矩阵标记的有限元标记的实例，并将其传递至 所述线程层次组织的顶线程中；实例化名为矩阵标记结束的有限元标记的实例，并将其传递至所述线程层次组织的所述 顶线程中并标记所述线程层次组织的结束点；实例化代表用于保存所生成内容的缓冲器的具有仅一个元素的对象矩阵的实例，并将所 述对象矩阵传递至所述线程层次组织的所述顶线程中；从所述HttpServlet请求的实例解析"模式"参数，并设置所述Servlet处理的实例中的所 述模式参数；开始构造所述响应的标题区；嵌入对外部javascript文件的链接引用；嵌入对包括于临时外部样式表文件相关的会话的外部javascript文件的链接引用； 如果所述请求是请求页面则找出悬挂于页面的标题区上的镶嵌悬挂的列表，若所述请求 并非请求页面的请求则找出悬挂于Servlet呈现实现类的标题区上的镶嵌悬挂的列表； 获取与所述列表中的每一个镶嵌悬挂相关联的每一个镶嵌的内容； 将所述内容嵌入所述响应的标题区中；如果所述请求是请求页面则找出悬挂于页面上的镶嵌悬挂的第二列表，若所述请求并非 请求页面的请求则找出悬挂于Servlet呈现实现类的上的镶嵌悬挂的第二列表，排除悬挂于所 述标题区上的镶嵌悬挂；产生有限元矩阵线程用于排序所述镶嵌悬挂的第二列表和用于处理，其中所述有限元矩 阵线程是所述线程层次组织的顶线程；根据所述镶嵌悬挂的第二列表嵌入对所有镶嵌的外部样式表文件的链接弓l用；结束所述响应的所述标题区；如果所述响应并非针对框架集html文件则开始主体区； 输送出所述生成的内容；将所述对象数组的第一元素作为关键字以及值为真的有限元标记的实例放入Servlet处理 实例的存储器块开始散列表中，用于指示所述缓冲器准备好将其保存的内容送出； 等待所述有限元矩阵线程的通知，如果排序完成或到达超时则前进至下一步； 将所述矩阵标记的值设为真； 将所述矩阵标记的片标记的第一元素的值设为真； 将所述片标记的第一元素的格标记的第一元素的值设为真； 通知所有线程等待共享同步对象；等待所述共享同步对象以发现来自其他线程的通知，并且一旦矩阵标记结束的值为真则将关键字和值为真的有限元标记的实例放入所述开始散列表中； 通知所有其他线程等待所述共享同步对象。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="50" class="claim">
      <div class="claim-text">50.如权利要求49所述的方法，其特征在于，所述产生有限元矩阵线程的步骤还包括： 存储所述镶嵌悬挂的第二列表以及根据其X值将其编组成片并根据其Y值将其编组成格；通知其他线程等待此线程完成排序； 如果根据分序有多片则逐一产生有限元片线程；实例化有限元助手实例并将信息存储在所述实例中供以后检索以建立CSS元素； 将所述有限元助手实例放入以页面呈现的完全匹配类名为关键字的请求范围散列表中； 如果有多片则结束所述线程；否则等待所述共享同步对象直至所述矩阵标记的值翻转为真或到达超时； 通过复制从所述对象数组传递至所述有限元矩阵线程中的所有元素并且通过添加新对象元素作为代表缓冲器层次中的新缓冲器来构造新对象数组作为新关键字链；将所述新关键字和具有真值的新有限元标记实例放入开始散列表中，指示所述新缓冲器准备好将其保存的内容在所述缓冲器层次中向上移一级；通过使用所述Servlet基的实例的完全匹配类名来实例化Servlet呈现实现类的实例； 获取通过用所述新关键字链执行所述Servlet呈现实例的获取呈现方法返回的对象，其中如果所述方法已将其生成的内容保存至U与所述新关键字链相关联的缓冲器中，则所述返回的对象可为空；用所述新关键字链和所述返回的对象执行所述Servlet处理实例的打印方法，以将所述对 象保存到所述新缓冲器中；用所述新关键字链执行所述Servlet处理实例的已打印方法，以便将当前保存在所述新缓 冲器中的内容在所述缓冲器层次中向上推一级；将所述矩阵标记结束的值设为真以标注所述有限元矩阵线程的结束；通知所有其他线程等待所述共享同步对象。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="51" class="claim">
      <div class="claim-text">51. 如权利要求50所述的方法，其特征在于，所述逐一产生所述有限元片线程的步骤还包括：在片中逐一产生有限元格线程。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="52" class="claim">
      <div class="claim-text">52. 如权利要求51所述的方法，其特征在于，所述逐一产生所述有限元格线程的步骤进 一步包括-如果所述格为片中的第一元素，则如果所述响应并非针对框架集html文件则构造html表的起始部分以包括所述第一 单元格元素，并且如果所述模式是"管理"模式则使得所述表的边界以粗体出现以易于 识别；等待所述共享同步对象，直至当前线程的矩阵标记的值翻转为真并且其片标记的 值翻转为真以及其格标记的值翻转为真，或到达超时；用所述新关键字链和所述生成的内容执行所述Servlet处理实例的打印方法以将所述生成的内容保存到所述新缓冲器中；将下一个格标记的值设为真； 通知所有其他线程等待所述共享同步对象；否则如果所述格代表镶嵌悬挂则产生有限元镶嵌悬挂线程；否则如果所述片涉及矩形区则针对所述格产生有限元框线程并且包括3个单元格：左侧单元 格、矩形区单元格、以及右侧单元格。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="53" class="claim">
      <div class="claim-text">53. 如权利要求52所述的方法，其特征在于，所述产生有限元镶嵌悬挂线程的步骤还包括：获得与镶嵌悬挂相关联的信息：镶嵌以及悬挂位置的X值和Y值；如果所述响应并非针对框架集html文件，贝IJ:如果所述格是最后片的最后元素则构造 html单元格元素的结尾部分和html表的结尾部分，且如果所述模式是"管理"模式则嵌入移 除按钮和编辑按钮以示出X和Y值的悬挂信息；如果所述镶嵌是嵌套镶嵌则找出悬挂于所述镶嵌上的镶嵌悬挂的列表；如果所述镶嵌并非嵌套镶嵌，则通过复制从所述对象数组作为关键字链传递至所述有限元镶嵌悬挂线程中的所有元素并且通过添加新对象元素作为代表缓冲器层次中的新缓冲器来构造新对象数组作为新关键字链；产生有限元镶嵌线程并将所述镶嵌的信息和新关键字链连同HttpServlet请求的实 例、HttpServlet响应的实例、Servlet会话的实例、Servlet处理的实例、以及Servlet基的实例一起传递至所述有限元镶嵌线程；等待所述共享同步对象直至当前线程的矩阵标记的值翻转为真并且其片标记的值翻转为真以及其格标记的值翻转为真，或到达超时；将所述新关键字和具有真值的新有限元标记实例放入开始散列表中，指示所述新 缓冲器准备好将其保存的内容在所述缓冲器层次中向上移一级； 通知所有其他线程等待所述共享同步对象；等待所述共享同步对象直至由所述新关键字标识并存储在Servlet处理实例的存储 器块结束散列表中的有限元标记的实例的值翻转为真，或到达超时；用所述结尾部分和所述对象数组作为当前有限元镶嵌悬挂线程的关键字链来执行 所述Servlet处理实例的打印方法；将下一个格标记的值设为真，并且如果所述格为片的最后元素则将下一片的片标 记及其第一格的格标记的值设为真，以及如果所述格是最后片的最后元素则将所述矩阵 标记结束的值设为真；通知所有其他线程等待所述共享同步对象；否则实例化标注线程层次组织的分支的开始点的名为子矩阵标记的有限元标记的新实例，并 将其传递至所述线程层次组织的所述分支的顶线程中；将所述当前有限元镶嵌悬挂线程的格标记指派给所述子矩阵标记并将其链接在一起；实例化名为子矩阵标记结束的有限元标记的新实例，并将其传递至所述线程层次组织的 所述分支的所述顶线程中并标记所述线程层次组织的所述分支的结束点；将所述对象数组作为所述当前有限元镶嵌悬挂线程的关键字链传递至所述线程层次组织 的所述分支的所述顶线程中；产生新有限元矩阵线程用于排序悬挂于所述镶嵌上的镶嵌悬挂的列表和处理，其中所述 新有限元矩阵线程是所述线程层次组织的所述分支的所述顶线程；等待所述新有限元矩阵线程的通知，如果排序完成或到达超时则前进至下一步；等待所述共享同步对象直至当前线程的矩阵标记的值翻转为真并且其片标记的值翻转为 真以及其格标记的值翻转为真，或到达超时；自所述子矩阵标记与所述格标记相链接起将所述子矩阵标记的值自动翻转为真；将所述子矩阵标记的子片标记的第一元素的值设为真；将所述子片标记的第一元素的子格标记的第一元素的值设为真；通知所有线程等待共享同步对象；等待所述共享同步对象直至其他线程通知所述子矩阵标记结束的值翻转为真； 用所述结尾部分和所述对象数组作为当前有限元镶嵌悬挂线程的关键字链来执行所述 Servlet处理实例的打印方法；将下一个子格标记的值设为真，并且如果所述格为片的最后元素则将下一片的子片标记及其第一格的子格标记的值设为真，并且如果所述格是最后片的最后元素则将所述矩阵标记结束的值设为真；通知所有其他线程等待所述共享同步对象。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="54" class="claim">
      <div class="claim-text">54.如权利要求53所述的方法，其特征在于，所述产生有限元镶嵌线程的步骤还包括：通过镶嵌悬挂获得镶嵌的绑定信息； 如果所述镶嵌被绑定到Servlet呈现实现类，则 实例化所述Servlet呈现实现类的实例；获取通过用所述关键字链执行所述Servlet呈现实例的获取呈现方法返回的对象， 其中如果所述方法已将其生成的内容保存到与所述关键字链相关联的缓冲器中，则所述 返回的对象可为空；用所述关键字链和所述返回的对象执行所述Servlet处理实例的打印方法，以将所 述对象保存到与所述关键字链中的最后关键字相关联的缓冲器中；用所述关键字链执行所述Servlet处理实例的已打印方法，以便将当前保存在与所 述最后关键字相关联的所述缓冲器中的内容在与所述关键字链相关联的所述缓冲器层 次中向上推一级；否则 实例化所述实体呈现实现类的实例；获取通过用所述关键字链和标识符执行所述实体呈现实例的获取呈现方法返回的对象， 其中如果所述方法已将其生成的内容保存到与所述关键字链相关联的缓冲器中，则所述返回的 对象可为空；用所述关键字链和所述返回的对象执行所述Servlet处理实例的打印方法，以将所述对象 保存到与所述关键字链中的最后关键字相关联的缓冲器中；用所述关键字链执行所述Servlet处理实例的已打印方法，以便将当前保存在与所述最后 关键字相关联的所述缓冲器中的内容在与所述关键字链相关联的所述缓冲器层次中向上推一 级。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="55" class="claim">
      <div class="claim-text">55. 如权利要求54所述的方法，其特征在于，所述实体呈现实现类代表访问组、文档、 音乐、图片、视频、收藏、网页、用于纯文本的简单文本、用于html文本的Html文本、用于 搜索功能的搜索框、用于消费web服务的函数之一。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="56" class="claim">
      <div class="claim-text">56. 如权利要求52所述的方法，其特征在于，所述产生有限元框线程的步骤还包括： 如果所述响应并非针对框架集html文件，则若所述格是最后片中的最后元素，则构造html单元格元素的结尾部分以及html表的结尾部分；实例化标注线程层次组织的分支的开始点的名为子矩阵标记的有限元标记的新实例并将 其传递至所述线程层次组织的所述分支的顶线程中；将当前有限元框线程的格标记指派给所述子矩阵标记并将其链接在一起； 实例化名为子矩阵标记结束的有限元标记的新实例并将其传递至所述线程层次组织的所 述分支的所述顶线程中并标记所述线程层次组织的所述分支的结束点； 如果所述格单元格为所述矩形区单元格，则找出悬挂于所述Servlet呈现实现类上的镶嵌悬挂列表； 如果所述镶嵌悬挂列表不为空，则将所述对象数组作为当前有限元框线程的关键字链传递至所述线程组织层次的所述分支的所述顶线程中；产生新有限元矩阵线程用于排序所述镶嵌悬挂列表和用于处理，其中所述新 有限元矩阵线程是所述线程层次组织的所述分支的所述顶线程；等待所述新有限元矩阵线程的通知，如果排序完成或到达超时则前进至下一步；等待所述共享同步对象直至当前有限元框线程的矩阵标记的值翻转为真并 且其片标记的值翻转为真以及其格标记的值翻转为真，或到达超时；自所述子矩阵标记与所述格标记相链接起将所述子矩阵标记的值自动翻转为真；将所述子矩阵标记的子片标记的第一元素的值设为真；将所述子片标记的第一元素的子格标记的第一元素的值设为真；通知所有线程等待所述共享同步对象；等待所述共享同步对象直至其他线程通知所述子矩阵标记结束的值翻转为真；用所述结尾部分和所述对象数组作为当前有限元框线程的关键字链来执行 所述Servlet处理实例的打印方法；将下一个格标记的值设为真，并且如果所述格为片的最后元素则将下一片的 片标记及其第一格的格标记的值设为真，并且如果所述格是最后片的最后元素则 将当前有限元框线程的矩阵标记结束的值设为真；通知所有其他线程等待所述共享同步对象；否则等待所述共享同步对象直至当前有限元框线程的矩阵标记的值翻转为真并 且其片标记的值翻转为真以及其格标记的值翻转为真，或到达超时；通过复制从所述对象数组传递至所述有限元框线程中的所有元素并且通过 添加新对象元素作为代表缓冲器层次中的新缓冲器来构造新对象数组作为新关键 字；将所述新关键字和具有真值的新有限元标记实例放入开始散列表中，指示所 述新缓冲器准备好将其保存的内容在所述缓冲器层次中向上移一级；通过使用所述Servlet基的实例的完全匹配类名来实例化Servlet呈现实现类 的实例；获取通过用所述新关键字链执行所述Servlet呈现实例的获取呈现方法返回 的对象，其中如果所述方法已将其生成的内容保存到与所述新关键字链相关联的 缓冲器中，则所述返回的对象可为空；用所述新关键字链和所述返回的对象执行所述Servlet处理实例的打印方法， 以将所述对象保存到所述新缓冲器中；用所述新关键字链执行所述Servlet处理实例的已打印方法，以便将当前保存在所述新缓冲器中的内容在所述缓冲器层次中向上推一级；用所述结尾部分和所述对象数组作为当前有限元框线程的关键字链来执行 所述Servlet处理实例的打印方法；将下一个格标记的值设为真，并且如果所述格为片的最后元素则将下一片的片标记及其第一格的格标记的值设为真，并且如果所述格是最后片的最后元素则将当前有限元框线程的矩阵标记结束的值设为真；通知所有其他线程等待所述共享同步对象；否则找出所述左侧单元格或所述右侧单元格上的镶嵌悬挂列表； 如果所述镶嵌悬挂列表不为空，则将所述对象数组作为当前有限元框线程的关键字链传递值所述线程层次组 织的所述分支的所述顶线程中；产生新有限元矩阵线程用于排序所述镶嵌悬挂列表和用于处理，其中所述新 有限元矩阵线程是所述线程层次组织的所述分支的所述顶线程；等待所述新有限元矩阵线程的通知，如果排序完成或到达超时则前进至下一步；等待所述共享同步对象直至当前有限元框线程的矩阵标记的值翻转为真并 且其片标记的值翻转为真以及其格标记的值翻转为真，或到达超时；自所述子矩阵标记与所述格标记相链接起将所述子矩阵标记的值自动翻转为真；将所述子矩阵标记的子片标记的第一元素的值设为真；将所述子片标记的第一元素的子格标记的第一元素的值设为真；通知所有线程等待所述共享同步对象；等待所述共享同步对象直至其他线程通知所述子矩阵标记结束的值翻转为真；用所述结尾部分和所述对象数组作为当前有限元框线程的关键字链来执行 所述Servlet处理实例的打印方法；将下一个格标记的值设为真，并且如果所述格为片的最后元素则将下一片的 片标记及其第一格的格标记的值设为真，并且如果所述格是最后片的最后元素则将当前有限元框线程的矩阵标记结束的值设为真；通知所有其他线程等待所述共享同步对象；否则等待所述共享同步对象直至当前有限元框线程的矩阵标记的值翻转为真并 且其片标记的值翻转为真以及其格标记的值翻转为真，或到达超时；用所述结尾部分和所述对象数组作为当前有限元框线程的关键字链来执行 所述Servlet处理实例的打印方法；将下一个格标记的值设为真，并且如果所述格为片的最后元素则将下一片的片标记及其第一格的格标记的值设为真，并且如果所述格是最后片的最后元素则 将当前有限元框线程的矩阵标记结束的值设为真； 通知所有其他线程等待所述共享同步对象。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="57" class="claim">
      <div class="claim-text">57. 如权利要求46所述的方法，其特征在于，所述执行Servlet基的结束方法的步骤还包括：执行所述Servlet处理的实例的"结束(）"方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="58" class="claim">
      <div class="claim-text">58. 如权利要求57所述的方法，其特征在于，所述执行所述"结束0"方法的步骤还包括：等待所述共享同步对象直至存储器块开始散列表中的关键字的值翻转为真或到达超时；送出仍驻留在缓冲器层次中的内容并清空；通知所有其他线程等待所述共享同步对象；产生html文件的结尾部分；使所生成的结尾部分输送至用户；若保存在所述开始散列表中的关键字指示，则产生新线程以送出URL并请求所述web容器生成半静态文件；将关键字和值为真的有限元标记的实例放入存储器块结束散列表中； 通知所有其他线程等待所述共享同步对象。</div>
    </div>
    </div> <div class="claim"> <div num="59" class="claim">
      <div class="claim-text">59. &#8212;种通过web容器和Ajax技术来跟踪和维护框架集网页中框架大小和框架的URL 的改变的方法，其中用户通过与相同计算机机器中或远程计算机机器中的所述web容器通信 的浏览器来浏览所述网页并与之交互，所述方法包括：接收用户对所述网页的请求；创建在会话的寿命期间存储累积性请求范围宽度信息的存储器块请求散列表； 在所述会话中保存所述请求散列表，其中所述请求散列表由请求URI来标识和检索； 生成所述网页并加载框架的初始布局和每一个框架的URL;创建对象数组以存储框架集的ID信息、第二对象数组以存储框架的ID信息、第三对象 数组以存储框架的URL信息、第四对象数组以存储框架的布局信息，其中所述第四对象数组 是二维对象数组，其第一维标识框架并且第二维存储所述框架的宽度和高度信息；以4个不同关键字将全部4个对象数组存储在所述请求散列表中；将所述网页发送给所述用户以供浏览和交互；在通过初始加载或通过点击到新位置加载所述框架并被所述浏览器的加载事件触发时， 通过Ajax将框架的URL送回至相同的请求URI;将通过Ajax送回的新信息保存到URL信息对象数组中；在用户调整框架的布局并被所述浏览器的调整大小事件触发时，通过Ajax将所有框架的 宽度和高度信息送回至相同的请求URI;将通过Ajax送回的所述宽度和高度信息保存到所述第四对象数组中；在用户重新拜访时检索每一框架的所述URL和大小信息； 重构所述框架的布局；生成反映框架的当前布局和每一个框架的URL的所述网页。</div>
    </div>
  </div> </div>
  </div></div><div class="patent-section patent-description-section"><div class="patent-section-header"><span class="patent-section-title"> 说明</span></div><div class="patent-text"><div mxw-id="PDES34698416" lang="ZH" load-source="patent-office" class="description">
    <p>网页、网站建模和生成</p>
    <p>技术领域</p>
    <p>本发明领域：本发明一般涉及计算系统，尤其涉及在组件级建模网页，其提供了用于汇</p>
    <p>编和构建网页、网站和网站聚合(website syndication)的系统和方法。 发明背景</p>
    <p>自因特网和万维网的诞生起，开发了许多工具和方法来离线地创作网页（Macromedia Studio、 Microsoft FrontPage、 Dreamweaver, Adobe Creative Suite,这仅歹俾了少数)，或者在 线动态地创作网页，其大部分时间是数据库驱动的（Google Page Creator, Yahoo GEOCIT正S 等）。通常它们直接遵守HTML规范并提供实现html元素的函数和特征。</p>
    <p>缺乏对网页自身的抽象建模是这些工具和方法的共同特性。该特性通常反映在需要对工 具的深度学习曲线以及对HTML元素和规范的透彻理解才能更好地创作网页这一事实。几乎 所有工具都提供模板供作者使用和构建，从而在创建网页方面具有高超能力，但这对于外行而 言仍不容易。网页是从基本级的html元素或从最顶级构建而成的，在后一种情形中网页由引 用其他网页的框架集和框架组成。从中间立场而言，在组件级(component level)建模网页具有 缺点。</p>
    <p>对于为了重用网页的一部分的网页聚合，RSS (真正简单聚合）的不同版本和Atom规 范将XML用作其数据格式并将其信息作为被称为"RSS订阅源"、"web订阅源"、"RSS 流"、或"RSS频道"的XML文件来递送。被称为订阅源阅读器或聚集器的程序可代表用户 检查订阅源列表并显示其找到的任何已更新的文章。需要网页上的组件模型来提供用于网页聚 合的新领地。</p>
    <p>发明公开</p>
    <p>发明了在HTML元素级上层的更高级别地建模网页，用于通过封装组件中的HTML元 素的细节并随后将组件汇编成网页来构建网页和网站。通过展示组件作为服务，组件可在其他 网站中被重用并使得网站能聚合。</p>
    <p>定义抽象页面并用于代表网页；定义抽象镶嵌并用于代表网页的组件或部分，镶嵌可本 地或远程地被绑定到任何有意义信息，镶嵌可被展示作为服务。 一个或多个镶嵌可悬挂于页面 上的不同行和列位置处，以形成呈现网页用的图案。通过操纵镶嵌的行和列位置，达成了用于 呈现网页的不同图案。此外， 一个或多个其他镶嵌可以与镶嵌悬挂于页面上相同的方式悬挂于 镶嵌上。嵌入级别可为任意高。此外，与网页的标题区的恰当信息绑定的镶嵌可被悬挂于网页的标题区上或所谓的注入其中。</p>
    <p>这种有序多层结构提供了供一组同步线程同时一起工作以便以高效和高速方式生成网页 的机制。多个缓冲器层次容纳该过程以临时并有序地存储所生成的内容以构成网页。此机构的 嵌套或级联本质在本质上与层叠样式表（CSS)机制是相同的，并且每一个组件的样式可个别 地指定并从最低部到顶部级联。</p>
    <p>页面在指定为目录类型时可将其他页面维持为其孩子并提供用于管理和访问的目录树结 构。页面可以仅仅是页面自身或者其可被映射到镶嵌;页面拷贝映射到诸如图片或视频等实体， 页面还可被映射到诸如搜索框等函数，页面还可被映射到远程信息源，在所有情形中，实体、 函数、或远程信息服务与悬挂于被映射页面上预先指定位置处的镶嵌绑定。此树结构使得能管 理和访问大量页面和各种内容，以及相关树操作和函数。这种结构可用于映射本地文件目录以</p>
    <p>供从web浏览器访问，并也可用于生成电子书以供离线查看。定义许可和访问控制机制用于</p>
    <p>页面的创建、管理和可访问性。 附图简述</p>
    <p>图1是页面的示例性实施例并示出悬挂于该页面上的镶嵌，并且这些镶嵌根据其悬挂位</p>
    <p>置的行值（X值）被编组成片（slice);</p>
    <p>图2是嵌套镶嵌的示例性实施例并示出悬挂于嵌套镶嵌上的镶嵌，并且所悬挂的镶嵌根 据其悬挂位置的行值（X值）被编组成片；</p>
    <p>图3是与网页的生成过程相关联的多个线程的层次的示例性实施例；</p>
    <p>图4是多个缓冲器层次的示例性实施例及其在网页的生成过程中相关联的对象关键字； 图5是在浏览器中查看页面的网页的示例性实施例；</p>
    <p>图6是用于&#26619;看和导航页面的目录结构以及用于创建和管理页面的基于浏览器的用户接</p>
    <p>口的示例性实施例；</p>
    <p>图7是用于管理页面的可访问性的基于浏览器的用户接口的示例性实施例；</p>
    <p>图8是用于在视图模式下显示和汇编页面的基于浏览器的用户接口的示例性实施例；</p>
    <p>图9是用于在编辑模式下显示和汇编页面的基于浏览器的用户接口的示例性实施例；</p>
    <p>图10是用于显示和管理页面的CSS元素的样式表信息的基于浏览器的用户接口的示例</p>
    <p>性实施例；</p>
    <p>图11是用于显示和管理所选本地文件夹的列表及其指定的实体类型的基于浏览器的用 户接口的示例性实施例。</p>
    <p>发明最佳实施方式</p>
    <p>无论是静态地存储在web应用服务器中还是由其动态地生成的网页的底层html文件，在 被用户请求时都被传送给用户的web浏览器并在其中呈现。网页可呈现许多种类的信息以供 展现和交互。网页的html文件以开始标签〈html〉开始并以结束标签^html〉结束。html文件包括以开 始标签〈head〉开始并以结束标签^head〉结束的标题区。非框架类型html文件除标题区外还包 括主体区，并且主体区以开始标签〈body〉开始并以结束标签^body〉结束。框架类型html文件 除标题区外还包括以开始标签〈framese^开始并以结束标签々frameseP结束的框架集元素，其 可涵盖一个或多个框架元素以及一个或多个其他框架集元素。</p>
    <p>网站可以很简单并且仅由一个html文件或数个html文件组成，或者可以较复杂从而包 括存储与该网站有关的数据和信息的数据库。 一种网站是目录站点： 一种包含被分为各类别和 子类别的不同内容的站点。在此，数据、信息、和内容是不可分且可互换的，并且它们具有相 同的普通意义。</p>
    <p>实体（Entity)是具有独特的单独存在性的事物，但其无需是物质上的存在性。 一般而言， 也不假定实体是有生命的。实体可被视为包含子集的集合。可以认为集合是作为整体考虑的截 然不同事物的任何集成。在计算机编程中，实体是持久性的，这意味着其可被存储在诸如存储 器或硬盘的文件系统或数据库等计算机可读介质中并从其检索。</p>
    <p>在本公开中，术语"实体"及相应的实体类被用来定义所有实体的最抽象和最顶层的超</p>
    <p>集。其还实现适用于所有实体的公共方法。</p>
    <p>在本公开中，术语"实体呈现（EntityPresentation)"及其相应的实体呈现界面被用来定 义对呈现实体的公共方法集的签名。有许多不同方法来通过构造和修改实体的html格式或其 他格式来呈现实体。在一些情形中，实体自身的内容为html格式并且可直接使用。</p>
    <p>作为实体的子集，术语"页"（Page)或"页面"及其相应的页面类被用于表示网页。 网页的表示并不意味着其是网页的实际html文件。在html文件的生成期间，页面被用作参考 以便将组成该页面所代表的html文件的所有内容汇总到一起。该过程在实现实体呈现界面的 页面呈现（PagePresentation)类中发生。</p>
    <p>非框架类型html文件的内容被封入其在开始标签〈body〉和结束标签^ody〉之间的主体 区中。并且内容经常存在于html表元素或多个后续html表中。html表(table)可包括一个或 多个其他html表并变成嵌套。html表模型允许将数据&#8212;&#8212;文本、预格式化文本、图像、链接、 表格(form)、表格字段、其他表^^安排到单元格的行和列中。</p>
    <p>html表以开始标签々able〉开始并以结束标签々table〉结束，其之间可为一个行元素或多个 行元素。行元素以开始标签〈tr〉开始并以结束标签々tr〉结束，其之间可为一个单元格元素或多 个单元格元素。单元格元素以开始标签〈td〉开始并以结束标签々td〉结束，并且一段内容可被 封入一个单元格元素中。</p>
    <p>作为实体的另一个子集，术语"镶嵌（Mosaic)"及其相应的镶嵌类被用于代表组成页 面的组件或部分的一段内容或任何有意义信息。在这段内容的生成期间，镶嵌被作为引用以便 将组成该镶嵌所代表的这段内容的所有子内容汇总到一起。该过程在实现实体呈现接口的镶嵌 呈现（MosaicPresentation)类的实例中发生。镶嵌可用于代表本地或远程的且与之绑定的任何 有意义信息。镶嵌可作为服务被展出，从而另一个网站可使用该服务并获取该镶嵌代表的内容。为建立页面与一个或多个镶嵌之间的关系，比如玩拼图游戏，将页面想象为平板并将镶 嵌想象为一片拼板，需要按有序方式将一个或多个镶嵌悬挂于该平板上以完成该页面的图案或 呈现的辨识。这就是"镶嵌悬挂（MosaicHanger)"的来源。</p>
    <p>镶嵌悬挂类被定义为实体类的子类，并且镶嵌悬挂被用来将镶嵌与页面连接，其使用两 个变量X和Y来标识镶嵌悬挂于页面上的位置。X代表水平或行位置。Y代表垂直或列位置。</p>
    <p>网页被分成两个主要区段：标题区，以及主体区（在非框架html文件的情形中）或框架 集元素（在框架类型html文件的情形中）。在一个实施例中，代表网页的标题区的适当信息 的镶嵌在其悬挂位置的X和Y值被指定为负值时被悬挂于网页的标题区上或所谓的注入其中。</p>
    <p>在生成由页面代表的非框架类型html文件的主体区的过程中，与页面相关联的所有镶嵌 悬挂（除悬挂于页面的标题区上的镶嵌悬挂以外）被排序和编组成片(slice)。每一片代表具有 相同X值的一个或多个镶嵌悬挂的组。随后创建只有一行的html表元素，并且后续在该行中 按镶嵌悬挂的Y值的次序创建与该片中的每一个镶嵌悬挂相对应的每一个单元格。每一个镶 嵌悬挂引用一个镶嵌，并且该镶嵌所代表的内容被汇集以填充相应的单元格。在完成一片之后， 前往下一片。该过程保持继续直至完成所有片。</p>
    <p>图1代表示例性实施例并示出页面100和悬挂于页面100上除标题区以外的少数镶嵌 (111,113,115, 121,131);悬挂于位置X1和Yll的镶嵌lll、悬挂于位置X1和Y12的镶 嵌113、悬挂于位置XI和Yln的镶嵌115、悬挂于位置X2和Y21的镶嵌121、悬挂于位置 Xm和Yml的镶嵌131。在页面100的生成期间，具有相同X值的镶嵌被编组成片，并且根 据其悬挂位置的X值，镶嵌（111， 113, 115)被编组为片110，镶嵌121被编组为片120，以 及镶嵌131被编组为片130，随后创建只有一行的html表以代表每一片，并且每一个单元格 封入由该片中每一个镶嵌所代表的内容，逐一进行直至完成所有片。</p>
    <p>镶嵌可以嵌套，这意味着可按照前述在页面上悬挂一个或多个镶嵌的方式将一个或多个 其他镶嵌悬挂于镶嵌（父镶嵌）上。并且嵌套的级别可以是任意的。镶嵌悬挂还被用来连接镶 嵌和其父镶嵌。镶嵌悬挂使用相同的两个变量X和Y来标识镶嵌被悬挂于其父镶嵌上的位置。 X代表水平或行位置。Y代表垂直或列位置。</p>
    <p>在生成由嵌套镶嵌（nested mosaic)代表的一段内容的过程中，与嵌套镶嵌（父镶嵌） 相关联的所有镶嵌悬挂被排序并编组成片。每一片代表具有相同X值的一组镶嵌悬挂。随后 创建只有一行的html表元素，并且后续在该行中按镶嵌悬挂的Y值的次序创建与该片中的每 一个镶嵌悬挂相对应的每一个单元格。每一个镶嵌悬挂引用一个镶嵌，并且该镶嵌所代表的内 容被集中以填充相应的单元格。在完成一片之后，前往下一片。该过程保持继续直至完成所有 片。</p>
    <p>图2代表示例性实施例并示出嵌套镶嵌200和悬挂于镶嵌200上的少数镶嵌（211, 213, 215,221,231);悬挂于位置Xl和Yll的镶嵌211、悬挂于位置XI和Y12的镶嵌213、悬挂 于位置XI和Yln的镶嵌215、悬挂于位置X2和Y21的镶嵌221 、悬挂于位置Xm和Yml 的镶嵌231。在镶嵌200的内容的生成期间，悬挂于镶嵌200上的具有相同X值的镶嵌被编组成片，并且根据其悬挂位置的X值，镶嵌（211,213,215)被编组为片210，镶嵌221被编组 为片220，以及镶嵌231被编组为片230，随后创建只有一行的html表以代表每一片，并且每 一个单元格封入由该片中每一个镶嵌所代表的内容，逐一进行直至完成所有片。</p>
    <p>对于简单的非嵌套镶嵌，可将非嵌套镶嵌绑定到由其实体呈现实现类的完全匹配类名 (folly qualified class name)标识的实体实例和标识该实体实例的标识符。镶嵌绑定 (MosaicBinder)类被定义为实体类的子类，并且镶嵌绑定被用来处理这种关系。在需要时， 镶嵌绑定通过对实体实例的实体呈现实现和标识该实体实例的标识符拉取出内容。镶嵌在一时 间仅可被绑定到一个实例。为避免死循环，镶嵌将不能被绑定到页面实例或镶嵌实例。</p>
    <p>文档、音乐、图片和视频是一些常见内容。在本公开中，作为实体的不同子集，术语"文 档"、"音乐"、"图片"和"视频"以及相应的文档类、音乐类、图片类和视频类分别用来 表示相应内容的集合。相应的实体呈现类为文档呈现、音乐呈现、图片呈现、视频呈现，其全 部实现实体呈现接口。</p>
    <p>为了使页面向用户呈现代表诸如图片等特定内容的网页以供在web浏览器中查看，这种 页面是"专用"类型页面。为使页面与实体的特定内容或实例相关，页面映射（PageMap)类 被定义为实体类的子类，并且页面映射被用于将页面映射到由其实体呈现实现类的完全匹配类 名标识的实体实例和标识该实体实例的标识符，同时创建镶嵌、镶嵌绑定和镶嵌悬挂；镶嵌绑 定将镶嵌与由其实体呈现实现类的完全匹配类名标识的实体实例和标识该实体实例的标识符；</p>
    <p>镶嵌悬挂随后将该镶嵌悬挂到页面上的预定义位置。 一种例外是：为了将页面映射到镶嵌，页</p>
    <p>面映射被用来将该页面映射到由镶嵌呈现类的完全匹配类名标识的镶嵌和标识该镶嵌的标识</p>
    <p>符，同时创建镶嵌悬挂而不创建镶嵌绑定；镶嵌悬挂随后将该镶嵌悬挂到该页面上的预定义位 置。第二例外是：页面将不被映射到另一个页面，在创建页面时，不创建页面映射、镶嵌、镶 嵌绑定、镶嵌悬挂。</p>
    <p>在一个实施例中，在创建将通过由页面表示的其底层html文件来在网页中呈现的图片实 例期间，创建页面，其中以字符串为该页面的标识符；还创建镶嵌、页面映射、镶嵌绑定和镶 嵌悬挂；出于简单起见，全部都使用与页面的标识符相同的字符串作为其标识符；页面映射将 该页面映射到由图片呈现类的完全匹配类名标识的图片实例和该实例的标识符;镶嵌绑定将镶 嵌绑定到由图片呈现类的完全匹配类名标识的图片实例和该实例的标识符;镶嵌悬挂将该镶嵌 悬挂至1顶面上的预定义或默认位置"=64,丫=64)。在此，创建、映射、绑定、悬挂全部意味着 创建相关联信息的记录并将其存储在数据库的相应表中的动作，如以下规定的。</p>
    <p>在一个实施例中，名为"页面"的数据库表用于存储关于页面的记录；名为"镶嵌"的 数据库表用于存储关于镶嵌的记录；名为"页面映射"的数据库表用于存储关于页面与实体的 实体呈现实现类的完全匹配类名以及标识实体实例的标识符之间的关系的记录；名为"镶嵌绑 定"的数据库表用于存储关于镶嵌与由实体的实体呈现类的完全匹配类名标识的实体实例以及 标识该实体实例的标识符的关系的记录；名为"镶嵌悬挂"的数据库表用于存储关于镶嵌与由 页面呈现类的完全匹配类名标识的页面以及标识该页面的标识符，或者由镶嵌呈现类的完全匹配类名标识的另一个镶嵌以及标识该镶嵌的标识符，以及X和Y值的悬挂位置信息的关系的 记录。如果从数据库表"页面"移除或删除页面，则还需要移除相关数据库表中存在的所有相</p>
    <p>关记录。</p>
    <p>为了以与目录树管理样式类似的结构化方式来更好地管理页面，页面可分别被定义为"专 用"、"目录型"、"引用"或"目录"；这是页面的目录类型属性。在一个实施例中，名为 "页面"的数据库表中名为"目录类型"的字段或列用来记录这4种不同定义。</p>
    <p>如前述的"专用"页面是其自身且未被映射到任何其他实体的页面，或者被映射到镶嵌、 文档、图片、音乐或视频等的实例的页面。在一个实施例中，名为"页面"的数据库表中名为 "类名"的另一个字段或列用来记录特定类型的内容的实体呈现实现类的完全匹配类名。</p>
    <p>"目录型"页面用于维持具有相同特定类型的内容的一个或多个"专用"页面的组并充 当用以维持这一个或多个页面的组的父页面。其不允许其他类型的一个或多个"专用"页面加 入。在一个实施例中，该组的特定类型的内容的实体呈现实现类的完全匹配类名记录在名为"页 面"的数据库表中父页面的"类名"字段中以反映此特性。</p>
    <p>"引用"页面如该名称所暗示的，是指向或连接到另一个页面的页面，该另一个页面可 能驻留在相同的网站上或在不同或远程网站上。页面引用（PageReference)类被定义为实体的 子类，并且页面引用被用来处理"引用"页面和被引用页面之间的关系。被引用页面若其自身 是"引用"页面则还可引用另一个页面。</p>
    <p>"目录"页面是通用页面，其可维持包括另一个或多个"目录"页面的所有页面。 页面孩子（PageChild)类被定义为实体的子类，并且页面孩子被用来存储父页面与子页 面关系的信息。</p>
    <p>与页面类似，镶嵌可分别被定义为"专用"、"目录型"、"引用"、或"目录"。在 一个实施例中，名为"镶嵌"的数据库表中名为"目录类型"的字段或列用来记录这4种不同 定义。</p>
    <p>"专用"镶嵌是代表除页面和镶嵌外的诸如文档、音乐、图片、或视频等特定类型的一 段内容的镶嵌。相应的镶嵌绑定将该镶嵌与实体的实体呈现实现类和标识实体实例的标识符绑 定。在一个实施例中，名为"镶嵌"的数据库表中名为"类名"的字段或列被用来记录特定类 型的内容的实体呈现实现类的完全匹配类名，同时，名为"镶嵌绑定"的数据库表中的记录通 过特定类型的内容的实体呈现实现类的完全匹配类名和标识该特定类型的内容的实例的标识 符来维持该镶嵌的信息。</p>
    <p>"目录型"镶嵌被用作父镶嵌，并且与相同类型的内容绑定的一个或多个"专用"镶嵌 的组可被悬挂于其上。其不允许其他类型的一个或多个"专用"镶嵌悬挂于其上。在一个实施 例中，该组的特定类型的内容的实体呈现实现类的完全匹配类名记录在名为"镶嵌"的数据库 表中父镶嵌的"类名"字段中以反映此特性。</p>
    <p>"引用"镶嵌如该名称所暗示的，是指向或连接到另一个镶嵌的镶嵌，该另一个镶嵌可 能驻留在相同的网站上或在不同或远程网站上。镶嵌引用（MosaicRefereiice)类被定义为实体的子类，并且镶嵌引用被用来处理"引用"镶嵌和被引用镶嵌之间的关系。被引用镶嵌若其自 身是"引用"镶嵌则还可引用另一个镶嵌。</p>
    <p>"目录"镶嵌是通用镶嵌，其可被包括另一个或多个"目录"镶嵌的所有镶嵌悬挂于其上。</p>
    <p>镶嵌悬挂维持父镶嵌与其子镶嵌关系的信息。在一个实施例中，名为"镶嵌悬挂"的数 据库表维持作为父镶嵌的镶嵌以及悬挂于父镶嵌上由X和Y值指定的位置处的子镶嵌的记录。</p>
    <p>在定义页面的目录结构之后，以下规定一些目录或目录树相关操作或特征。</p>
    <p>当在页面上悬挂镶嵌时，该镶嵌可被悬挂于该页面及其所有派生页面上；若设置了过滤 条件，则该镶嵌可能仅被悬挂于目录树中的一些页面上。树形镶嵌悬挂（MosaicHangerOnTree) 类被定义为实体的子类，并且树形镶嵌悬挂被用来处理此问题。</p>
    <p>在一个实施例中，名为"树形镶嵌悬挂"的数据库表中的记录维持镶嵌、目录树的顶页 面、由X和Y值指定的悬挂位置、以及对页面的"目录类型"和该页面被映射和指派的实体 呈现实现类的完全匹配类名的"类名"的过滤条件的信息。在一个实施例中，在创建新页面时， 应根据该新页面的一个或多个祖先上是否有任何树形镶嵌悬挂来检&#26619;是否需要创建任何新镶 嵌悬挂以悬挂于新创建的页面上，并且该新页面遵循过滤条件且不被滤除。另一方面， 一旦删 除了树形镶嵌悬挂，关于或弓l用此树形镶嵌悬挂的所有一个或多个镶嵌悬挂也需要被移除和删 除。</p>
    <p>作为实体的子集，术语"搜索框（SearchBox)"及其相应的搜索框类被用于定义对页面 或实体的目录树的搜索准则并输出遵循该搜索准则的实体的列表或集合。通过这样做，其代表 或提供搜索功能。此搜索输出的呈现通过搜索框呈现类，即实体呈现接口的实现来处理。</p>
    <p>在一个实施例中，名为"搜索框"的数据库表中的记录维持作为将被搜索的目录树的顶 页面的"起始页面"、指示从顶页面向下深入目录树的搜索程度的"深度"、搜索框正搜索的 页面的目录类型、指示搜索框正搜索的特定类型的内容之实体的实体呈现实现类的完全匹配类 名、指示搜索基于的字段关于搜索结果的次序的"排序依据"、指示该次序的升序或降序的"升 降序"的信息。</p>
    <p>搜索呈现（SearchPresentation)接口用于定义在不实际实现的情况下呈现搜索结果的排 序实体列表的一种或多种公共方法的签名。在实现搜索呈现时，实体可能具有许多不同方式通 过构造和修改其html格式来呈现搜索框的搜索输出。呈现实体的搜索输出的一种方式可通过 其实现搜索呈现的相关类的完全匹配类名来标识。在一个实施例中，名为"搜索框"的数据库 表中的记录还维持实体的搜索呈现实现的所选完全匹配类名的信息。</p>
    <p>搜索接口 （Searchlnterface)接口用于定义提供排序支持、排序依据字段列表、实体的搜 索呈现实现类的阵列列表及其标题的一种或多种公共方法的签名。</p>
    <p>在一个实施例中，在搜索框呈现内生成搜索框的搜索的输出的过程中，首先，其根据搜 索框所定义的搜索准则搜索出实体的成员列表，其次，其将该列表传给实体的搜索接口实现， 该搜索接口实现提供排序支持并根据搜索框所定义的排序准则取回排序列表，第三其将排序列表传给实体的搜索呈现实现并从其取回呈现结果。结果作为搜索框的输出被返回。</p>
    <p>一些有用用处包括：当与搜索框绑定的镶嵌被悬挂于目录树中的一个或多个页面上时， 其可被用于提供网站导航功能；其还可被用于呈现诸如一组图片或文档列表等有意义信息，并 且如果在每一个图片或文档上提供了链接，则点击该链接可将用户引领到具体图片或文档。</p>
    <p>在一个实施例中，镶嵌通过定制API (应用编程接口）作为服务展出并被其他网站消费 以便将该镶嵌重用为网站的网页的组件。通过将镶嵌与函数绑定的镶嵌绑定将镶嵌绑定到消费 由定制API展出的服务的函数。</p>
    <p>在一个实施例中，镶嵌还通过标准化WSDL (Web服务描述语言）作为web服务展出以 定义服务端点和端口，且该镶嵌所代表的内容被封入SOAP (简单对象访问协议）消息的主体 中，并且web服务被其他网站或软件程序消费以重用该镶嵌，这提供了在组件级聚合不同网 站和软件程序的方式。通过将镶嵌与消费web服务的函数绑定的镶嵌绑定，将镶嵌绑定到消 费通过网站的标准化WSDL展出的web服务的函数。如果镶嵌以XML格式表示该内容，并 且其嵌入了对其可扩展样式表转换信息（XSLT)的引用链接，则用于消费web服务的函数可 实现转换并根据XSLT中定义的模式和规则将内容转成html格式。</p>
    <p>当用户发送请求以请求页面时，web应用服务器通过标识请求的URI (在本公开中 URI&#8212;&#8212;统一资源标识符&#8212;&#8212;被定义为在HTTP请求的第一行中从协议名到查询字符串的这 部分请求URL)标识出该请求正请求一页面，并且随后在参数列表中标识出被请求的页面； web应用服务器随后可由页面表示的预生成的静态html文件或动态生成的html文件来响应。 在一个实施例中，用于请求页面的URI被定义和标识为"/servlet/Page"，存在底层动作类来 进行该实际工作以完成请求并返回响应，在此"/servlet/Page"的动作类是页面servlet (PageServlet)类，即在Java虚拟机的web应用服务器中运行的Java类。</p>
    <p>除了处理页面请求外，网站可向用户提供许多其他功能和交互，诸如登录、登出等；每 一种可表示不同的请求URI。 一般而言，它们全部涉及在收到请求之际送出响应。响应的呈现 是所涉及的常见行为。</p>
    <p>由此，servlet呈现（ServletPresentation)接口被用于定义生成对请求的响应的呈现的公 共方法的签名。在每一个不同的请求URI下，若其未被诉诸静态资源，则存在底层动作类来 进行实际工作以便完成该请求并返回响应，该动作类将实现servlet呈现接口。在一个实施例 中，页面Servlet实现Servlet呈现。</p>
    <p>可将镶嵌绑定到Servlet呈现的实现类以表示Servlet呈现的实现类的实例的输出。这种 关系由镶嵌绑定通过标识Servlet呈现实现类的完全匹配名的"标识符"字段和"类名"字段 以及标识镶嵌的"镶嵌"字段来处理。</p>
    <p>还可将镶嵌悬挂于实现Servlet呈现的请求URI的动作类上。这对响应的呈现提供一些有 意义用处，诸如对动作类的呈现周围添加一些嵌入提示、帮助注释、或导航链接等；这些悬挂 的镶嵌可被动态地配置、改变或重新安排而不影响动作类的呈现的主体。镶嵌悬挂被用于处理 如何将镶嵌悬挂于实现Servlet呈现的请求URI的动作类上的关系。其使用两个变量X和Y来标识镶嵌悬挂于请求URI的动作类上的位置。X代表水平或行位置。Y代表垂直或列位置。 在一个实施例中，名为"镶嵌悬挂"的数据库表中的记录维持镶嵌、标识请求URI的动作类 的完全匹配类名的"标识符"、标识请求URI的动作类的完全匹配类名的"类名"、标识悬 挂水平或行位置的"X"、标识悬挂垂直或列位置的"Y"的信息；由于请求URI的动作类并 不像实例可由标识符来标识的实体那样行为，因此"标识符"和"类名"两者皆维持请求URI 的动作类的完全匹配类名以便使其于镶嵌悬挂的其余部分区别开。在一个实施例中，悬挂位置 的X和Y值为负，这意味着与镶嵌悬挂相关联的镶嵌被悬挂于请求的URI的动作类的标题区 上。</p>
    <p>除标题区以外，处理对实现Servlet呈现的请求URI的动作类上的镶嵌悬挂的寻找和分类 与页面的稍有不同。定义类布局（classLayout)类，并且类布局被用于定义由响应的呈现上的 4个变量标识的矩形区：最小X、最小Y、最大X和最大Y。实现Servlet呈现接口的请求URI 的动作类的输出被封入该矩形区，连同其他周围镶嵌悬挂（若有） 一起组成整个响应的呈现。 最小X指定最小水平或行位置，最小Y指定最小垂直或列位置，最大X指定最大水平或行位 置，最大Y指定最大垂直或列位置，这4个全部一起组成矩形区以维持实现Servlet呈现接口 的请求URI的动作类的输出。</p>
    <p>在针对请求生成作为非框架类型html文件的响应的主体区的过程中，与实现Servlet呈 现的请求URI的动作类的完全匹配类名相关联的所有镶嵌悬挂（除了悬挂于标题区上的镶嵌 悬挂）根据由4个变量最小X、最小Y、最大X和最大Y (若有）所定义的矩形区被挑选出 和滤除，否则排除所有镶嵌悬挂；位于矩形区中的那些镶嵌悬挂被滤除。矩形区以上或以下的 那些被编组成片。每一片代表具有相同X值的一个或多个镶嵌悬挂的组。随后创建只有一行 的html表元素，并且后续在该行中按其Y值的次序创建与该片中的每一个镶嵌悬挂相对应的 每一个单元格。每一个镶嵌悬挂引用一个镶嵌，并且该镶嵌所代表的内容被汇总以填充相应的 单元格。在完成一片之后，前往下一片。矩形区左侧和右侧的那些连同该矩形区一起被编组为 一片。随后创建只有一行并且有3个单元格的html表元素，其中第一单元格维持左侧区，第 二单元格维持该矩形区，而第三单元格维持右侧区。如果左侧有一个以上镶嵌悬挂，则将其编 组成多片；每一片代表具有相同X值的一个或多个镶嵌悬挂的组；随后创建只有一行的html 表元素，并且后续在该行中按其Y值的次序创建与该片中的每一个镶嵌悬挂相对应的每一个 单元格;每一个镶嵌悬挂引用一个镶嵌，并且该镶嵌所代表的内容被汇总以填充相应的单元格； 在完成一片之后，前往下一片。如果右侧有一个以上镶嵌悬挂，则进行与左侧相同的操作。该 过程保持继续直至完成所有片。</p>
    <p>响应的整个内容可逐片生成并按恰当顺序保存在缓冲器中，在完成之际，随后将整个内 容作为一段送出给请求用户的web浏览器。以另一种方式，可在响应的生成期间流线化地逐 段将响应送出给用户的web浏览器而无需等待生成整个内容，但每一段必须位于要送出的顺 序中的正确位置否则在用户的web浏览器中的显示将会混乱。整个过程可在一个线程中顺序 地逐步执行或者在多线程环境中并行地执行。通常，多线程执行将进行得更快但的确需要额外计算资源来进行协调和同步。在流线化中， 一段内容可在其生成时即刻被保存到缓冲器中，或 者其必须等待直至收到通知时才轮到它。送出的一段或多段内容的次序通过缓冲器来处理。</p>
    <p>根据相应镶嵌悬挂中保持的X值和Y值以有序方式从左到右并从顶到底将多个镶嵌悬挂 于页面上或实现Servlet呈现的请求URI的动作类上（除了悬挂于标题区上的镶嵌）。每一个 单独镶嵌在获取由该镶嵌代表或与之绑定的相应内容时可由线程个别地处理。每一个镶嵌部署 一线程来处理其内容获取。所有线程并行地一起工作以生成对请求的快速响应。在嵌套镶嵌的 情形中，悬挂于嵌套镶嵌上的每一个镶嵌部署一新线程来个别地处理其内容获取。所有线程并 行地一起工作以便将悬挂于此嵌套镶嵌上的子镶嵌的所有子内容汇聚在一起。</p>
    <p>为组织多个线程并提供用于编程的结构，定义了 6种类型的线程类：有限元矩阵 (FeaMatrix)、有限元片（FeaSlice)、有限元格（FeaLattice)、有限元镶嵌悬挂 (FeaMosaicHanger)、有限元镶嵌（FeaMosaic)、以及有限元框（FeaBox)。</p>
    <p>有限元矩阵线程代表处理页面、请求URI的动作类、嵌套镶嵌、或一组镶嵌悬挂的顶级 线程。负责在收到请求之际生成响应或者负责生成由嵌套镶嵌所代表之内容的线程，产生有限 元矩阵线程，并将分别在页面上或请求URI的动作类上或嵌套镶嵌上的所有找到的镶嵌悬挂 (除了悬挂于标题区上的镶嵌）的集合传递到有限元矩阵线程中。 一般地，当面对一组镶嵌悬 挂时，线程产生有限元矩阵线程来处理由这组镶嵌悬挂所代表的内容的生成。</p>
    <p>有限元片线程用于处理编组有相同X值的镶嵌悬挂的每一个片，其将由有限元矩阵线程 产生，其处理分别在页面、请求URI的动作类、或嵌套镶嵌上的镶嵌悬挂的排序和编组。有 限元矩阵不产生或产生至少一个有限元片线程。</p>
    <p>除了用于处理片的一行html表的起始或标题的有限元格线程之外，有限元格线程还被用 于处理该一行html表中的每一个单元格。每一个单元格保持相应的镶嵌悬挂。有限元格线程 由处理片的有限元片线程产生。有限元片产生至少两个或更多有限元格线程。</p>
    <p>有限元镶嵌悬挂线程用于处理镶嵌悬挂以找出与镶嵌悬挂相关联的镶嵌是否为嵌套镶 嵌，如果该镶嵌为嵌套镶嵌，则有限元镶嵌悬挂线程产生新的有限元矩阵线程并传入悬挂于该 嵌套镶嵌上的所有找到的镶嵌悬挂；如果不是嵌套镶嵌，则有限元镶嵌悬挂线程产生新有限元 镶嵌线程。除了处理一行html表的起始或标题的有限元格线程之外，处理包含有镶嵌悬挂的 单元格的有限元格线程产生有限元镶嵌悬挂。有限元格仅能产生一个有限元镶嵌悬挂线程。</p>
    <p>有限元镶嵌线程用于获取镶嵌所代表的内容。有限元镶嵌线程由处理与镶嵌相关联的镶 嵌悬挂的有限元镶嵌悬挂线程产生。有限元镶嵌悬挂仅能产生一个有限元镶嵌线程。</p>
    <p>有限元框线程在片涉及矩形区并且该片代表包括三个单元格：左侧单元格、矩形区单元 格、和右侧单元格的一行html表的情形中使用。有限元框线程用于代表这三个单元格中每一 个中包含的内容。除了处理一行html表的起始或标题的有限元格线程之外，每一个有限元格 线程并不产生有限元镶嵌悬挂，而是为这三个单元格中的每一个产生有限元框线程。有限元格 仅能产生一个有限元框线程。如果这三个单元格中的任一个包含至少一个镶嵌悬挂，则其有限 元框线程将产生新有限元矩阵线程来处理这些镶嵌悬挂。图3代表示例性实施例并示出多个线程300的层次组织及其产生过程。有限元矩阵线程 311是该层次组织中的最顶级线程，由负责在收到请求之际生成响应的线程产生，其产生有限 元片线程323和有限元片线程325;有限元片线程323代表具有相同X值的水平或行悬挂位置 的一组镶嵌悬挂，其分别产生用于处理与有限元片线程323相关联的仅一行html表的起始和 标题的有限元格线程330、用于html表中的单元格中的镶嵌悬挂的有限元格线程331和有限 元格线程333;有限元格线程331产生有限元镶嵌悬挂线程341并且有限元镶嵌悬挂线程341 后续产生有限元镶嵌线程351以获取与有限元镶嵌351相关联的镶嵌所代表的内容;有限元格 线程333产生有限元镶嵌悬挂线程343并且有限元镶嵌悬挂线程343后续产生有限元矩阵线程 353，其指示与有限元镶嵌悬挂线程343相关联的镶嵌是嵌套镶嵌，并且发现悬挂于该嵌套镶 嵌上的镶嵌悬挂的集合被传递给有限元矩阵线程353以进行进一步处理；有限元矩阵线程353 产生有限元片线程363;有限元片线程363产生用于处理与有限元片线程363相关联的仅一行 html表的起始和标题的有限元格线程370、以及有限元格线程373，有限元格线程373后续产 生有限元镶嵌悬挂线程383，有限元镶嵌悬挂线程383后续产生有限元镶嵌线程393;有限元 片线程325与涉及矩形区的片相关联，并且该片代表包括三个单元格：左侧单元格、矩形区单 元格、和右侧单元格的仅一行html表；有限元片线程325产生用于处理与有限元片线程325 相关联的仅一行html表的起始和标题的有限元格线程337、以及用于处理html表中的三个单 元格中的每一个的有限元格线程335;有限元格线程335产生有限元框线程345并且有限元框 线程345后续产生有限元矩阵线程355，并且与有限元框线程345相关联的镶嵌悬挂的集合被 传递给有限元矩阵线程355以进行进一步处理；有限元矩阵线程355产生有限元片线程365; 有限元片线程365产生用于处理与有限元片线程365相关联的仅一行html表的起始和标题的 有限元格线程377、以及有限元格线程375，有限元格线程375后续产生有限元镶嵌悬挂线程 385，有限元镶嵌悬挂线程385后续产生有限元镶嵌线程395。</p>
    <p>一些线程大概将运行较快并且比可能面临复杂和耗时任务的其他线程更快完成其任务， 并且很可能还未轮到它将所生成内容保存到缓冲器中。然而，该内容必须以有序顺序被保存到 缓冲器中并被发送到用户的web浏览器以便恰当地出现，因此已完成的线程在所生成的内容 能被放入缓冲器中之前必须等待信号或标记。一旦线程收到指示现在轮到它将所生成内容放入 缓冲器中的信号或标记时，其应前进到这样做，同时其应设置或开启序列中下一个线程的信号 或标记并通知所有线程其已完成。这就是"有限元标记（Feaflag)"的来源。</p>
    <p>定义有限元标记类并且有限元标记的实例包括布尔字段和有限元标记类自身的实例的数 组。如果布尔字段为真，则意味着与有限元标记实例相关联的线程现在可将其生成的内容保存 到缓冲器中。布尔字段的默认值为假。有限元标记的实例具有有限元标记的实例的数组这一事 实使得其成为嵌套结构。嵌套级别是无限的。</p>
    <p>在创建新有限元矩阵线程之际，创建线程将实例化有限元标记的两个实例并将其传递给 新生成的有限元矩阵线程。在一个实施例中， 一个有限元标记实例名为"矩阵标记 (MatrixFlag)"，而另一个有限元标记实例名为"矩阵标记结束（MatrixFlagEnd)"。创建线程还为有限元矩阵线程传入一个或多个找到的相关镶嵌悬挂的集合以便根据其X值将它们 编组成片，并且根据其Y值安排其在片中的次序。在完成排序和编组之际，实例化大小等于 片数目的名为"片标记（sliceFlag)"的有限元标记实例的数组，其中每一个有限元标记实例</p>
    <p>(sliceflag[indexl])对应于一片，在此indexl始于0。数组sliceflag被设为有限元标记实例的 矩阵标记的数组；同时，实例化大小等于一片中的镶嵌悬挂数目加上用于一行html表的起始 或标题的一个的名为"格标记（latticeFlag)"的有限元标记实例的数组，其中第一有限元标 记实例（latticeFlag [O])对应于一行html表的起始或标题，而其余的每一个有限元标记实例</p>
    <p>(latticeFlag [index2])对应于片中的单元格，并且数组latticeFlag被设为片的有限元标记实例</p>
    <p>(sliceflag[indexl])的有限元标记实例的数组，直至完成所有片。</p>
    <p>从其中每一个有限元标记实例对应于除矩阵标记结束以外的线程的结构推导出有限元标</p>
    <p>记实例的顺序，如下所述： MatrixFlag, sliceflag [0],</p>
    <p>latticeFlag O[O], latticeFlag O[l]，.. .， latticeFlag O[nO], sliceflag [1],</p>
    <p>latticeFlag l[O], latticeFlag l[l],…，latticeFlag l[nl], sliceflag [m]，</p>
    <p>latticeFlag m[O]， latticeFlag m[l],…,latticeFlag m[nm], MatrixFlagEnd</p>
    <p>可通过将每一个有限元标记实例的布尔字段值翻转为真来实行信令过程链，其中使每一 个有限元标记实例翻转下一个，以矩阵标记（MatrixFlag)开始，将sliceflag [O]和latticeFlag 0[0] 作为一个单元，随后是latticeFlag O[l]，…，直至最后latticeFlag O[nO];然后将sliceflag [l]和 latticeFlag l[O]作为一个单元，然后是latticeFlag l[l]，…，直至最后latticeFlag l[nl];…；并 且随后将sliceflag [m]和latticeFlag m[0]作为一个单元，然后是latticeFlag m[l]，…，直至最后 latticeFlag m[nm];并且随后是矩阵标记结束（MatrixFlagEnd)。矩阵标记标注链的开始点或 进入点，而矩阵标记结束标注链的结束点或退出点。在此，"作为一个单元"意P未着其布尔字 段值同时被设为真并作为一个单元或一个步骤来对待。</p>
    <p>矩阵标记标注由创建线程产生的有限元矩阵线程的开始点或进入点；有限元矩阵线程后 续不产生或产生与每一个sliceflag [indexl]相对应的多个有限元片线程；每一个有限元片线程 后续产生与每一个latticeFlag [index2]相对应的至少两个或多个有限元格线程;每一个有限元格 线程后续产生或者有限元镶嵌悬挂线程或者有限元框线程；在有限元镶嵌悬挂线程的情形中， 有限元镶嵌悬挂线程后续产生或者有限元镶嵌线程或者新的子有限元矩阵线程;在有限元框线 程的情形中，有限元框线程后续产生新的子有限元矩阵线程。结束时，矩阵标记结束标注有限元矩阵线程的结束点或退出点。如果矩阵标记结束中的布尔字段为真，意味着该层次组织中的 所有线程（包括所有新的子有限元矩阵线程，其代表线程及其派生线程（若有）的层次组织的 分支）都已完成，若创建线程正在等该完成，则其可现在前进到下一步。</p>
    <p>由于有限元镶嵌悬挂线程或有限元框线程与其创建有限元格线程是一对一的关系，因此 其共享并使用创建有限元格线程的latticeFlag [index2]。</p>
    <p>在有限元镶嵌悬挂线程或有限元框线程创建新的子有限元矩阵线程时，实例化有限元标 记的两个实例并将其传递给新创建的有限元矩阵线程。在一个实施例中， 一个有限元标记实例 名为"子矩阵标记"，其标注子有限元矩阵的开始点和进入点；而另一个有限元标记实例名为 "子矩阵标记结束"，其标注子有限元矩阵的结束点和退出点。子矩阵标记被指派给有限元格 线程的latticeFlag [index2]，该有限元格线程是有限元镶嵌悬挂线程或有限元框线程的创建线程 并且其后续是子有限元矩阵线程的创建线程。当latticeFlag [index2]的布尔字段被翻转为真时， 子矩阵标记的布尔字段也变为真。创建子有限元矩阵线程的有限元镶嵌悬挂线程或有限元框线 程负责通过子矩阵标记的subSliceFlag[]数组的第一元素（subSliceFlag [O])禾H s油SliceFlag [0] 的subLatticeFlag []数组的第一元素（subLatticeFlag [O])来信令子有限元矩阵线程，并且将每 一个元素（subSliceFlag[O]和subLatticeFlag [O])的布尔字段的值设为真。对子矩阵标记结束的 布尔字段上的"真"值的通知标注子有限元矩阵线程及其所有派生线程的结束，并且最后一个 线程（与子矩阵标记的subSliceFlag []的最后元素的subLatticeFlag []的最后元素相关联）负责 信令较高层中的下一个线程，或者如果这也是该较高层中的最后元素则信令并将矩阵标记结束 的布尔字段的值设为真。</p>
    <p>一公共和共享对象被用于线程层次中多线程的同步。在一个实施例中，名为"一oSync" 的对象被用作多线程执行环境中的响应生成过程的所有线程的同步对象，线程通过执行以下程 序块送出通知：</p>
    <p>synchronized(_oSync) {</p>
    <p>一oSync.notifyA110j</p>
    <p>并通过执行另一个程序块来等待接收通知：</p>
    <p>synchronized (_。Sync) { &#8212;oSync.wait(timeout》</p>
    <p>timeout (超时）代表线程等待的最大持续期，若超过，则该线程将无论如何中断。 在创建有限元矩阵线程之际，创建线程在其能够开始或进入信令链之前将等待所创建的 有限元矩阵线程完成排序并通知返回，如果其所创建的有限元矩阵线程不是线程层次的最前一 个或顶层一个而在子层，则创建线程还需要等待轮到它进行信令。在一个实施例中，所创建的 有限元矩阵线程自身被用作另一个同步对象并具有一个布尔字段用以指示排序是否完成， 一旦 完成排序，其将布尔字段值设为真并通过执行以下程序块向等待的创建线程送出通知：synchronized(this) { this.notify();</p>
    <p>在被通知和验证排序完成后，创建线程将中断等待并前进至下一个。</p>
    <p>在对请求生成响应时，在一线程执行环境中，该任务是极其直截了当的：每当生成一段 内容并且其准备好在线程前进时离开，执行线程就顺序地逐段送出内容；典型实现使用打印写 入（PrintWriter)来打印一段内容或对象并调用flush()方法来要求底层输出流（outputstream) 在Java编程语言环境中送出数据。在此，输出流可用作输出数据流的临时缓冲区。另一种方 式是将所有段一起保存在缓冲器中并作为一段将其全部送出，而在缓冲器中需要恰当地保持各 段的顺序。</p>
    <p>在与信令链同步的线程层次组织的执行环境中，用于内容排列的缓冲器区被用来处理由 每一个线程生成的内容的存储和送出。通过信令过程链恰当地保持缓冲器中内容的顺序，每一 个线程等待轮到其将所生成的内容放入缓冲器中。整组线程是同步的并且像一个线程或所谓的 虚拟线程那样工作。在其创建时，缓冲器区已准备好存储但或许不能立即输送并将内容送出给 用户的web浏览器，因为诸如准备响应的标题区等一些预处理任务需要一定时间才能完成， 因此诸如具有布尔值的关键字等对象被用作标记（"开始标记"）来标注缓冲器何时能开始送 出内容。 一旦开始标记翻转为真，则在线程将一段内容放入缓冲器的同时，该内容连同当前驻 留在缓冲器中的任何内容一起立即被输送并被送出给用户。在该层次组织中的所有线程都完成 其工作后，具有另一个布尔值的同一个关键字(key)被用作标记（"结束标记"）来标记该层 次中的所有线程的执行结束。如果该层次组织中的一个线程产生信令链不能触及的一个或多个 新线程，则不能用该组恰当地维护从该一个或多个新线程生成的内容的次序或顺序。该新线程 随后需要新缓冲器和具有两个标记的新关键字来使其内容生成过程与触及线程协调和同步。细 节解释如下。</p>
    <p>对象数组（key[])被用作关键字数组或关键字链以反映一系列线程的产生过程以及与缓 冲器层次相关联的一系列缓冲器。缓冲器层次中的缓冲器与线程、虚拟线程、或长运行方法相 关联，其中对象数组中的每一个元素作为与两个标记相关联的一关键字，其一个标记（开始标 记）用于指示所保存和正保存到此缓冲器中的内容可立即被移至更高层缓冲器中，以及在最顶 层缓冲器的情形中指示所保存和正保存到此缓冲器中的内容可立即被送出给用户的web浏览 器；另一个标记（结束标记）用于标注线程、虚拟线程、或长运行方法的执行的结束，并且可 从层次中移除该缓冲器。</p>
    <p>涉及两种公共方法：第一种方法由每一个线程或长运行方法用于将一段所生成的内容保 存到缓冲器层次中其对应的缓冲器中，并且如果开始标记指示新生成的内容连同先前保存的内 容一起可被移至更高层缓冲器中，则前进至这样做；第二种方法由每一个线程或长运行方法用 于号召缓冲器层次中其对应的缓冲器将该缓冲器中保存的所有内容移至更高层缓冲器中&#8212;&#8212; 如果开始标记指示允许这样做，否则该方法将等待开始标记开启或翻转为真，在将该缓冲器中保存的所有内容被移至更高层缓冲器中之后，该缓冲器可被移除，该方法随后将结束标记开启 或翻转为真并通知等待该结束标记的一个或多个其他线程。详细解释如下。</p>
    <p>从仅有一个元素的对象数组（key[])中最前一个元素key[0]开始，其与最顶层线程即线 程0相关联，缓冲器即缓冲器O被用于顺序地存储从线程O及其派生线程生成的内容。key[O] 和开始标记（布尔值）被存储在存储器块中以指示是否轮到线程0将内容移入更高层或在这种 情形中的送出给用户的web浏览器。当布尔值翻转为真时，被保存到缓冲器O中的一段内容 连同当前仍驻留在缓冲器0中的任何内容一起可立即被移至更高层或者在这种情形中送出给 用户的web浏览器。key[O]和结束标记（布尔值）被存储在另一个存储器块中以指示线程0及 其派生线程是否己完成。</p>
    <p>如果线程O产生新线程即线程Ol，则生成具有两个元素的新对象数组（keyOl[])，其中 第一元素（keyOl[O])复制于线程O的key[O]元素，而新生成的对象作为第二元素（keyOl[l])。 创建新缓冲器即缓冲器Ol以顺序地存储从线程Ol及其派生线程生成的内容。key01[l]及其开 始标记被存储在存储器块中以指示缓冲器01中所保存或正保存的内容是否可被移至更高层缓 冲器即缓冲器O中。keyOl[l]及其结束标记被存储在另一个存储器块中以指示线程Ol及其派 生线程是否已完成。</p>
    <p>如果线程0产生另一个新线程即线程02，则生成具有两个元素的新对象数组（key02[P ， 其中第一元素（key02[0])复制于线程0的key[0]元素，而新生成的对象作为第二元素</p>
    <p>(key02[1])。仓ll建新缓冲器即缓冲器02以顺序地存储从线程02及其派生线程生成的内容。 key02[l]及其开始标记被存储在存储器块中以指示缓冲器02中所保存或正保存的内容是否可 被移至更高层缓冲器即缓冲器O中。key02[l]及其结束标记被存储在另一个存储器块中以指示 线程02及其派生线程是否已完成。</p>
    <p>如果线程0在其执行中调用长运行方法03，则生成具有两个元素的新对象数组(key03[p， 其中第一元素（key03[0])复制于线程0的key[O]元素，而新生成的对象作为第二元素</p>
    <p>(key03[1])。创建新缓冲器即缓冲器03以顺序地存储从方法03生成的内容。key03[l]及其 开始标记被存储在存储器块中以指示缓冲器03中所保存或正保存的内容是否可被移至更高层 缓冲器即缓冲器O中。key03[l]及其结束标记被存储在另一个存储器块中以指示该长运行方法 是否己完成。</p>
    <p>如果在长运行方法03内调用了另一个长运行方法31，则生成具有3个元素的新对象数 组（key31[])，其中前两个元素（key31[0]和key31[1])复制于方法03的对象数组（分别为 key03[0]和key03[1])，而新生成的对象作为第三元素（key31[2])。创建新缓冲器即缓冲器 31以顺序地存储从方法31及其嵌套长运行方法生成的内容。key31[2]及其开始标记被存储在 存储器块中以指示缓冲器31中所保存或正保存的内容是否可被移至更高层缓冲器即缓冲器03 中。key31[2]及其结束标记被存储在另一个存储器块中以指示方法31及其嵌套长运行方法是 否己完成。</p>
    <p>如果在长运行方法03内调用了新线程即线程32,则生成具有3个元素的新对象数组(key32[])，其中前两个元素(key32[0]和key32[l])复制于方法03的对象数组（分别为key03[0] 和key03[lp ，而新生成的对象作为第三元素（key32[2])。创建新缓冲器即缓冲器32以顺序 地存储从线程32及其派生线程生成的内容。key32[2]及其开始标记被存储在存储器块中以指 示缓冲器32中所保存或正保存的内容是否可被移至更高层缓冲器即缓冲器03中。key32[2]及 其结束标记被存储在另一个存储器块中以指示线程32及其派生线程是否已完成。</p>
    <p>如果线程Ol产生新线程即线程ll,则生成具有3个元素的新对象数组（keyll[])，其 中前两个元素（keyl l[O]和keyl 1 [1])复制于线程01的对象数组（分别为key01 [O]和key01 [1])， 而新生成的对象作为第三元素（keyl1[2])。创建新缓冲器即缓冲器11以顺序地存储从线程 11及其派生线程和其长运行方法生成的内容。keyll[2]及其开始标记被存储在存储器块中以指 示缓冲器ll中所保存或正保存的内容是否可被移至更高层缓冲器即缓冲器Ol中。keyll[2]及 其结束标记被存储在另一个存储器块中以指示线程11及其派生线程和其长运行方法是否已完 成。</p>
    <p>图4是逐侧示出相关联关键字的缓冲器层次400的示例性实施例。与关键字410相关联 的缓冲器430是缓冲器层次中的最顶层缓冲器，保存在缓冲器430中的内容被直接送出给用户 的浏览器；与关键字411相关联的缓冲器431是缓冲器430下的子缓冲器，保存在或正保存到 缓冲器431中的内容轮到它时被立即移至缓冲器430中；与关键字413相关联的缓冲器433 是缓冲器430下的子缓冲器，保存在或正保存到缓冲器433中的内容轮到它时被立即移至缓冲 器430中；与关键字415相关联的缓冲器435是缓冲器433下的子缓冲器，保存在或正保存到 缓冲器435中的内容轮到它时被立即移至缓冲器433中；与关键字417相关联的缓冲器437 是缓冲器433下的子缓冲器，保存在或正保存到缓冲器437中的内容轮到它时被立即移至缓冲 器433中。</p>
    <p>在一个实施例中，定义Java编程语言类Servlet处理（ServletProcessor)。作为Servlet 处理类的实例变量的名为"开始散列表"的散列表（Hashtable)被用于存储关键字及其开始标 记值，在此有限元标记实例被用作开始标记；作为Servlet处理类的另一个实例变量的名为"结 束散列表"的另一个散列表被用于存储关键字及其结束标记值，在此另一个有限元标记实例被 用作结束标记；作为Servlet处理类的另一个实例变量的名为"打印散列表"的又一个散列表 被用于存储关键字及其相应的缓冲器，在此矢量（Vector)被用作存储内容的缓冲器， 一段内 容可被添加到矢量作为其元素，并且其他段的内容可后续相应地被添加到该矢量，矢量的元素 可被清空并被移至或添加至另一个矢量；作为Servlet处理类的实例变量的名为"&#8212;oSync"的 对象被用作用于同步从实例化Servlet处理类的实例的当前线程产生的所有派生线程及长运行 方法的公共和共享对象。</p>
    <p>这两种公共方法被实现为Servlet处理类中的公有实例方法。</p>
    <p>第一种方法：print(Object key[], Object obj)被线程或长运行方法用来将一段内容（由"obj" 表示）保存到缓冲器层次中其对应的缓冲器中；缓冲器被对象数组key[]的最后元素标识为打 印散列表中的关键字，并且开始标记由打印散列表中的相同关键字标识。更高层缓冲器被对象数组key[]中的最后元素标识为打印散列表中的关键字。</p>
    <p>第二种方法：pritited(Object key[])被线程或长运行方法用来号召缓冲器层次中其对应的缓 冲器将该缓冲器中所保存的所有内容移至更高层缓冲器中&#8212;&#8212;如果开始标记指示允许这样 做，否则该方法将等待同步对象&#8212;oSync直至开始标记开启或翻转为真，在保存在缓冲器中的 所有内容被移至更高层缓冲器中之后，该缓冲器可被移除，该方法随后将结束标记翻转为真并 通过&#8212;oSync.notifyAUO方法通知其他一个或多个线程。缓冲器被对象数组key[]的最后元素标识 为打印散列表中的关键字，并且开始标记和结束标记分别被开始散列表和结束散列表中的相同 关键字标识。更高层缓冲器被对象数组key[]中的最后元素标识为打印散列表中的关键字。</p>
    <p>在一个实施例中，与信令链同步的线程层次从最顶层有限元矩阵线程开始，其仅用一个 元素printid[O]在对象数组printid[]中传递。printid[O]用作在打印散列表中标识缓冲器的关键字。 在创建最顶层有限元矩阵线程的创建线程中诸如准备响应的标题区等一些预处理任务己完成 时，打印散列表中该关键字的开始标记被设为真。对象数组printid[]后续被无修改地向下传递 至有限元矩阵线程的派生线程：有限元片线程、有限元格线程、有限元框线程、和有限元镶嵌 悬挂线程，以及子有限元矩阵线程（若有）。每一个线程在信令链上等待轮到它并随后通过执 行print(Object key[], Object obj)方法将一段生成的内容保存到缓冲器中，在此对象数组printid[] 是key[]而obj是需要保存的所生成内容。有限元镶嵌悬挂后续可产生信令链不能触及的有限 元镶嵌线程，并且不能恰当地维护在整个响应生成过程中其生成的内容的顺序；因此对于有限 元镶嵌线程和长运行方法，生成新对象数组，其中第一元素复制于printid[O],而新生成的对象 作为与新缓冲器、开始标记、和结束标记相关联的第二元素。通过这样做，以恰当顺序的响应 的构造和递送就能很好地组织和同步。</p>
    <p>层叠样式表（CSS)是用于向html文件添加样式（例如，字体、颜色、间距）的简单机 制。样式表定义将如何显示html元素。样式表允许以许多方式来指定样式信息。样式可在单 个html元素内指定（内嵌样式），在html文件的〈head〉元素内指定（内部样式表），或者在 外部CSS文件中指定。在单个html文件内可引用多个外部样式表。html文件中的每一个html 元素由唯一 ID来标识，外部CSS文件存储该ID及其相关的样式表信息。</p>
    <p>当一个镶嵌或多个镶嵌悬挂于页面上时，将它们根据其镶嵌悬挂的X值编组成片（除了 悬挂于标题区上的镶嵌，若有的话）。随后创建只有一行的html表以包含片，其中根据其Y 值的次序使每一个单元格与该片中的每一个镶嵌的镶嵌悬挂相对应。该html表可用表ID来标 识和指定，行可用行ID来标识和指定，而每一个单元格可用其单元格ID来标识和指定。与 每一个ID相关联的样式表信息随后可被存储在数据库表或外部CSS文件中供以后引用。</p>
    <p>每一个html表可通过相应片的X值唯一地与其他html表区别开，在此该X值被当^"表 索引"，html表中的行元素可通过添加行因子或"行索引"来标识；随后该行中的每一个单 元格元素可通过添加该行中每一个单元格的索引信息的单元格因子来标识；并且最后，页面的 标识符可用作前缀以便全球唯一地形成元素的ID (表ID、行ID、单元格ID)。</p>
    <p>在一个实施例中，html表的表ID是页面的标识符、作为表索引的与该html表相关联的片的X值、代表行索引的字符串"0"以及代表单元格索引的字符串"0"的串联；该htall表 中唯一一行的行ID是页面的标识符、作为表索引的与该html表相关联的片的相同X值、代 表行索引的字符串"1"以及代表单元格索引的字符串"0"的串联；第一单元格的单元格ID 是页面的标识符、作为表索引的与该html表相关联的片的相同X值、代表行索引的字符串"l" 以及代表单元格索引的字符串"l"的串联；第二单元格的单元格ID是页面的标识符、作为 表索引的与该html表相关联的片的相同X值、代表行索引的字符串"1"以及代表单元格索 引的字符串"2"的串联；并且后续单元格的单元格ID可通过递增单元格索引来组成。</p>
    <p>在悬挂于镶嵌（父镶嵌）上的一个或多个镶嵌的情形中，父镶嵌的标识符被用作前缀以 替代页面的标识符，从而组成元素的ID (表ID、行ID、单元格ID);在悬挂于请求URI的 动作类上的一个或多个镶嵌的情形中，动作类的名称被用作前缀以替代页面的标识符，从而组 成元素的ID (表ID、行ID、单元格ID)。</p>
    <p>在一个实施例中，名为"Css元素"的数据库表中的记录保持页面的标识符、页面呈现 类的完全匹配类名、表索引、行索引、单元格索引、以及样式表信息的信息，该记录标识页面 上的CSS元素（表ID、行ID、单元格ID);同一数据库表中的另一条记录保持镶嵌的标识 符、镶嵌呈现类的完全匹配类名、表索引、行索引、单元格索引、以及样式表信息的信息，该 记录标识镶嵌上的CSS元素（表ID、行ID、单元格ID);同一数据库表中的又一条记录保 持请求URI的动作类的完全匹配类名、表索引、行索引、单元格索引、以及样式表信息的信 息，该记录标识请求URI的动作类上的CSS元素（表ID、行ID、单元格ID)。</p>
    <p>在一个实施例中，管理Css (ManageCss)类被用于显示页面、嵌套镶嵌、或请求URI 的动作类上的所有顶层CSS元素（不包括嵌套CSS元素），从而作者可在另一个类管理Css 元素（ManageCssElement)中进入具体CSS元素以编辑其样式表信息，并随后将该记录存储 在"Css元素"数据库表中。所有表索引、行索引和单元格索引信息都是从存储在会话（session) 中的助手类有限元助手（FeaHelper)检索的。在有限元矩阵线程已挑选出页面、嵌套镶嵌、 或请求URI的动作类上的所有镶嵌悬挂后，其实例化有限元助手类的实例并将表索引、行索 引和单元格索引信息插入有限元助手实例中并将其存储在会话中供以后检索。</p>
    <p>页面、嵌套镶嵌、或请求URI的动作类全部都具有相应的外部CSS文件用于存储其顶层 CSS元素（表ID、行ID、单元格ID)的样式表信息。此外，嵌套镶嵌的外部CSS文件还包 括所有派生镶嵌的CSS元素的样式表信息。如果镶嵌的CSS元素的样式表信息改变，贝幅镶 嵌的祖先的所有外部CSS文件也被更新。这将使得html文件引用其外部CSS文件的工作更容 易，因为所有派生镶嵌的样式表信息已被累积在顶层镶嵌的CSS文件中。</p>
    <p>在一个实施例中，在Servlet处理类中实现实例方法beginO。既然如此，其准备html文 件的〈head〉区且使用其"REL"属性被设为"样式表"的《nJO html元素，并引用页面的外部 CSS文件或请求URI的动作类的外部CSS文件以及所有顶层镶嵌的外部CSS文件；对于通过 树形镶嵌悬挂操作产生的转移镶嵌悬挂，还引用树形镶嵌悬挂的相关联页面的外部CSS文件。 一个或多个静态CSS文件也可包括在〈head〉区中。如果html文件是动态地生成的，则还可包括与会话以及与会话的相同寿命相关联的临时外部CSS文件，这意味着用户可通过改变样式</p>
    <p>表信息并将其保存在临时CSS文件中来仅针对该会话临时修改外表和感觉以供引用。改变后 的样式表信息通过Ajax (异步JavaScript和XML)连同CSS元素ID和属性以及属性的新值 被传送回服务器侧。该方法还找出悬挂于标题区上的镶嵌并获取嵌入标题区的镶嵌的内容。</p>
    <p>在一个实施例中，在一个web浏览器中，在html框架中呈现页面的html文件，在另一 个html框架中进行用以定义和修改页面的CSS元素的样式表信息的管理Css和管理Css元素。 在提交改变时，第一框架立即被重载或刷新以反映对样式表定义的该新改变。这提供了良好的 WYSIWYG (所见即所得）编辑环境。</p>
    <p>将镶嵌作为组件展出以作为服务或web服务。当一个或多个其他网站请求该服务并标识 镶嵌时，该镶嵌所代表并嵌入其外部CSS文件（若有）的内容被发送给请求网站，该请求网</p>
    <p>站后续将该内容嵌入其一个或多个网页中。该服务还可充当用于从另一个网站获取信息并随后 将其送回给请求网站的代表或代理。这使得网站聚合以及一个网站中的内容能在一个或多个其</p>
    <p>他网站中重用。网站聚合在组件级上松散地耦合和集成，并且适用于发布/订阅系统和动态网 络拓扑结构。</p>
    <p>针对谁具有创建和管理网站中其自己的内容并管理网站中其他人的内容定义许可机制。 该机制还适用于与网站相关联的任何其他数据。各种级别的许可被定义为：无、读取、编辑、 删除、创建，其各自比前一个具有更多权限并分别用数字O、 1、 2、 3、 4来表示；许可的角色 被定义为：创建者、管理员，其分别用数字l、 2来表示。创建者角色仅能处理其自己的内容， 而管理员角色具有更多权限并且能处理其他人的内容。</p>
    <p>定义许可组（PermissionGroup)类并且许可组被用于定义具有由开始时间"startTime" 和停止时间"stopTime"标识的有效时段的许可组，在该时段中，该组及其相关定义生效。</p>
    <p>许可组许可（PermissionGroupPermission)类定义许可组对一种类型的实体的许可角色和 许可级别；在此实体的完全匹配类名被用作参考。可将多个许可组许可指派给许可组。</p>
    <p>许可组成员（PermissionGraupMember)类定义许可组的用户列表，其中只有该列表中的 用户能执行指定许可允许的一个或多个动作。</p>
    <p>许可组位置（PermissionGroupLocation)类定义许可组的位置列表，其中用户必须来自该 列表中的位置才能执行指定许可允许的一个或多个动作。在此，位置意味着用户的计算机IP 地址。</p>
    <p>名为"许可"的数据库表维持许可组的因子的所有可能组合的最高许可级别的所有记录； 在此，因子组合意味着用户、位置、实体的完全匹配类名、许可角色的组合。这些记录并非是 在定义它们时生成的，而是在用户传入在后续激发许可级别检&#26619;的请求时生成的，随后生成一 条或多条相关记录。这些记录以预定义间隔规律地更新。通过这样做，"许可"数据库表可避 免过密并提供更快和更高效的许可级别检查过程。</p>
    <p>关于"许可"数据库表，许可类被定义并用于维持"许可"数据库表中的记录的信息， 以及实现名为"获取许可级别（getPermissionLevel)"的方法，该方法通过提供用户、位置、实体的完全匹配类名、以及许可角色的信息来取回许可级别。</p>
    <p>在一个实施例中，在基类Servlet基（ServletBase,&#8212;种抽象类）中实现名为"检查访问 (checkAccess)"的公共使用方法，该Servlet基继承(extend)HttpServlet类。基类可被请求 URI的动作类继承，因此一些公共使用方法可放入基类中。方法"检&#26619;访问"返回Integer[][]， 即作为整数的许可级别的二维数组;第一维代表在执行动作时涉及的不同类型的实体类并且该 维的长度等于不同类型的实体类的数目；第二维代表许可角色，第二维的长度为2，其第一索 弓l代表"创建者"的许可角色而其第二索引代表"管理员"的许可角色。</p>
    <p>在一个实施例中，管理页面（ManagePage)类，即请求URI "/servlet/ManagePage"的动 作类和Servlet基的子类以及Servlet呈现（ServletPresentation)的实现，使用页面类并调用"检 &#26619;访问"方法来检查用户的许可级别，以便确定用户是否能创建或管理页面并提供基于浏览器 的用户接口用于处理这些任务。管理镶嵌（ManageMosaic)类，即另一个请求URI "/servlet/ManageMosaic"的动作类和Servlet基的子类以及Servlet呈现的实现，使用镶嵌类并 调用"检查访问"方法来检查用户的许可级别，以便确定用户是否能创建或管理镶嵌并提供基 于浏览器的用户接口用于处理这些任务。</p>
    <p>为了规定页面的可访问性，针对谁具有访问和管理页面的权限定义访问机制。各种级别 的访问被定义为：无、读取、编辑、删除、创建，其各自比前一个具有更多权限并分别用数字 0、 1、 2、 3、 4来表示；在此访问级别等于相应的许可级别，但访问级别将总是处于具有处理</p>
    <p>其他人的页面的能力的"管理员"许可角色。使用了两种类型的定义：第一种是公共访问</p>
    <p>(PublicAccess )类，其标注在指定访问级别上公共可访问的页面；第二种是访问组 (AccessGroup)，详细描述如下。</p>
    <p>定义访问组类并且访问组被用于定义具有由开始时间"startTime "和停止时间"stopTime " 标识的有效时段的访问组，在该时段中，该组及其相关定义生效。其还具有标识当前谁拥有该 访问组的字段"所有者"、标注其被修改的最近时间的字段"修改时间"。作为实体的子集， 访问组的呈现是通过实现实体呈现接口的访问组呈现（AccessGroupPresentation)类进行的。</p>
    <p>访问组成员（AccessGroupMember)类定义访问组的用户列表，其中只有该列表中的用 户才能访问以指定访问级别指派给该访问组的页面。</p>
    <p>访问组位置（AccessGroupLocation)类定义访问组的位置列表，其中只有来自该列表内 的位置的用户才能访问以指定访问级别指派给该访问组的页面。在此，位置意味着用户的计算 机IP地址。</p>
    <p>在定义页面的访问级别时，页面访问类的实例以及名为"页面访问"的数据库表维持页 面的标识符、公共访问类的完全匹配类名、以及访问级别的信息。页面与公共访问类可以仅具 有一对一的关系；页面访问类的又一个实例以及名为"页面访问"的相同数据库表维持页面的 标识符、访问组的标识符、访问组呈现类的完全匹配类名、以及访问级别的信息。可按不同访 问级别向页面指派多个访问组。页面不能一起被指派公共访问和访问组两者。页面类中名为"访 问类名"的字段维持公共访问类或访问组呈现类的完全匹配类名，若其什么都不维持，则页面是私有的并且未被定义任何可访问性。</p>
    <p>页面的公共访问的访问级别可通过仅用页面的标识符和公共访问类的完全匹配类名检&#26619; 名为"页面访问"的数据库表来获得。对于访问组，名为"访问"的数据库表被用于维持访问 组的因子的所有可能组合的最高访问级别的所有记录，在此，因子组合意味着用户、位置、以 及页面的标识符的组合。这些记录并非是在定义它们时生成的，而是在用户访问页面并激发访 问级别检查时生成的，并且随后一条或多条相关记录被生成并以预定义间隔被规律更新。通过 这样做，"访问"数据库表可避免过密并提供更快和更高效的访问级别检&#26619;过程。</p>
    <p>关于"访问"数据库表，访问类被定义并用于维持"访问"数据库表中的记录的信息， 以及实现名为"获取访问级别（getAccessLevel)"的方法，该方法通过提供用户、位置、以 及页面的标识符的信息来取回访问级别。</p>
    <p>在一个实施例中，在基类Servlet基（抽象类，不能被实例化并用作子类使用的一些公共 使用实例变量和方法的基或占位符）中实现名为"检&#26619;访问"的另一种公共使用方法。"检&#26619; 访问"方法需要实体实例的标识符和实体的实体呈现实现类的信息，并返回Interger[][]，即作 为整数的访问级别的二维数组；第一维代表在执行动作时涉及的页面类并且该维的长度等于 1;第二维代表许可角色，该维度的长度为2，其第一索引代表"创建者"的许可角色而其第 二索引代表"管理员"的许可角色，但访问级别总是为"管理员"许可角色。如果实体实例不 是页面，则必须通过页面映射类来获得其映射页面，否则返回空。</p>
    <p>在一个实施例中，管理页面类，即请求URI "/servlet/ManagePage"的动作类和Servlet 基的子类以及Servlet呈现的实现，使用页面的标识符和页面呈现类并调用"检&#26619;访问"方法 来检&#26619;用户的访问级别，以便确定用户是否能访问和管理页面。管理镶嵌类，即请求URI '7servlet/ManageMosaic"的动作类和Servlet基的子类以及Servlet呈现的实现，使用镶嵌的标 识符和镶嵌呈现类并调用"检查访问"方法来检&#26619;用户的访问级别，以便确定用户是否能访问 和管理镶嵌。</p>
    <p>页面的可访问性可被个别地管理。 一组页面的可访问性可通过对目录树应用一些过滤条 件以滤除页面并指派可访问性定义来管理。</p>
    <p>当用户开始请求并拜访网站时，会话被声明并在用户的拜访期间持续，当用户离开时， 该会话将等待直至流逝了预定义的超时时段并随后终止。会话被指派唯一ID以标识其自身。 会话横跨多个请求并用于存储用户（客户机侧）与网站（服务器侧）之间的交换信息。会话中 存储的数据使用"设置属性（setAttribute)"方法来保存以及使用"获取属性（getAttribute)" 方法通过名称和值对来检索。这些行为通常实现在web应用中，web应用包括提供这些服务 的web容器。</p>
    <p>在一个实施例中，Servlet会话（ServletSession)类被定义并被用作访问和操纵存储在会 话中的适配器或外观。当收到请求时，Servlet会话的新实例被实例化并用会话的会话ID来标 识。</p>
    <p>在实例化Servlet会话实例时，名为"会话范围散列表"的存储器区或散列表通过将会话ID作为关键字被检索（或者若尚不存在则被创建），并被用于存储会话范围宽度信息，因此 处理任何请求的线程可访问会话范围宽度信息。会话范围散列表通过方法设置属性(会话ID, 会话范围散列表)以会话ID作为其关键字被保存在会话中。</p>
    <p>在实例化Servlet会话实例时，名为"请求范围散列表"的另一个存储器区或散列表通过 将请求的URI作为关键字被检索（或者若尚不存在则被创建），并被用于存储对特定请求URI 的累积请求范围宽度信息，因此处理任何请求的线程可访问关于特定请求URI的累积请求范 围宽度信息。请求范围散列表可通过方法设置属性(请求URI,请求范围散列表)以请求URJ作 为其关键字被保存在会话中，或者在嵌套散列表中通过方法放入(请求URI,请求范围散列表) 以请求URI作为其关键字被保存在会话范围散列表中。</p>
    <p>请求的getParameterMapO方法返回包含参数名作为关键字以及参数值作为映射值的不变 java.util.Map实例。参数映射中的关键字是字符串类型的。参数映射中的值是字符串数组类型 的。每当用增加的新参敏值对或相同参数但新值代替了旧值来拜访相同的请求URI时，将该 映射输入其请求范围散列表中。通过这样做，历史和累积信息针对请求URJ被存储，并且准 备好被处理任何具有不同请求URI的请求的线程访问。请求范围散列表的寿命与会话持续相 同的时间。最当前的请求信息在请求时仍被维护和访问，并且与累积存储器散列表不同。</p>
    <p>在组合Ajax (异步JavaScript和XML技术）的权限时，其提供异常编程架构用于基于 web的应用开发。当具有不同请求URI的多个请求需要一起工作并且彼此协作时，该架构尤 为有用。例如，在客户机侧，用户接口在一个web浏览器中具有多个框架并且每一个框架呈 现对不同请求URI的响应，不同框架之间的数据和信息交换可通过JavaScript、文档对象模型 等来完成。在客户机侧与服务器侧之间，客户机侧的数据和信息可通过Ajax被送回服务器侧 并被保存到请求范围散列表中而无需重载网页。数据和信息根据每一个请求的请求URI被结 构化地组织和保存在服务器中，它们在会话的寿命期间可在任何时间被服务器侧或客户机侧访 问和改变。</p>
    <p>在 一 个实施例中，web浏览器的左侧主体中的框架被用于通过名为 "/servlet/ExploreDirectoiy (开发目录）"的请求RUI来显示页面目录树的导航视图。其中， 父页面由名为"父页面"的参数标识。相同web浏览器的右侧主体中的第二框架被用于通过 名为'7servlet/PageChildList (页面孩子列表）"的请求RUI来显示父页面的子页面的列表。</p>
    <p>当第二框架转到"/servlet/ManagePage (管理页面）"的另一个请求URI以创建新页面 时，从"/servlet/ExploreDirectory"的请求范围散列表中检索"父页面"信息并使其成为新创 建的页面的父页面。</p>
    <p>当第二框架转到'7servlet/ManageMosaic (管理镶嵌）"的另一个请求URI以创建新镶 嵌时，从"/servlet/ExpIoreDirectory"的请求范围散列表中检索"父页面"信息并使其成为新 创建的页面的父页面，该新创建的页面以Servlet基中实现的名为"映射页面"的方法映射新 创建的镶嵌。</p>
    <p>当第二框架转到"/servlet/ManageDocument (管理文档）"的另一个请求URI以创建新文档时，从"/servlet/ExploreDirectory"的请求范围散列表中检索"父页面"信息并使其成为 新创建的页面的父页面，该新创建的页面以Servlet基中实现的名为"映射页面"的相同方法 映射新创建的文档。"/servlet/ManageDOcument"的底层动作类是管理文档，其实现Servlet 呈现并且是Servlet基的子类。</p>
    <p>当第二框架转到"/servlet/ManageMusic (管理音乐）"的另一个请求URI以创建新音乐 时，从"/servld/ExploreDirectory"的请求范围散列表中检索"父页面"信息并使其成为新创 建的页面的父页面，该新创建的页面以Servlet基中实现的名为"映射页面"的相同方法映射 新创建的音乐。"/servlet/ManageMusic"的底层动作类是管理音乐，其实现Servlet呈现并且 是Servlet基的子类。</p>
    <p>当第二框架转到"/servlet/ManagePicture (管理图片）"的另一个请求URI以创建新图片 时，从'7servlet/ExploreDkectory"的请求范围散列表中检索"父页面"信息并使其成为新创 建的页面的父页面，该新创建的页面以Servlet基中实现的名为"映射页面"的相同方法映射 新创建的图片。"/servlet/ManagePicture"的底层动作类是管理图片，其实现Servlet呈现并且 是Servlet基的子类。</p>
    <p>对于"/servlel/ManageVideo (管理视频）"、'7servlet/ManageSearchBox (管理搜索框）"、 "/servlet/ManageAccessGroup (管理访问组）"是相同的。这里的要点是使得无需在每一个请 求URI的请求中携带或嵌入"父页面"信息，其可以仅被存储在一处，即使该信息可被存储 在会话范围散列表中供每一个请求访问，但将每一种信息放入一个平坦的地方将是混乱的并且 不是最优方法。"/servlet/ManageVideo "的底层动作类是管理视频，而 "/servlet/ManageSearchBox"的底层动作类是管理搜索框，以及"/servlet/ManageAccessGroup" 的底层动作类是管理访问组，其全部实现Servlet呈现并且是Servlet基的子类。</p>
    <p>在一个实施例中，开发（Explorer)类，艮卩"/servlet/Explorer"的动作类和Servlet基的子 类，实现Servlet呈现。开发类的实例生成一组4个框架，其在web浏览器中被组织成3个框 架集。</p>
    <p>第一个框架在顶主体区并且由ID "F0"标识。F0呈现一系列html按钮，html按钮呈现 将被调用的每一个菜单或动作选择，其后续将改变其他框架的URL并重载这些框架。按钮或 菜单由与名为"菜单索引"的数字相对应的"菜单Id"标识。F0的内容由将菜单类作为其动 作类的请求URI "/servlet/Menu (菜单）"生成。"/servlet/Menu"是框架F0的属性"src"的值。</p>
    <p>第二个框架在左侧主体区并且由ID "F1"标识。Fl呈现目录树导航视图。其"src"属 性的可能值为："/servlet/ExplorePublicDirectory   (开发公共目录）"、 "/servlet/ExploreAccessGroupDirectory (开发访问组目录)"、"/servlet/ExploreDirectory (开 发目录)"、"/servlet/ExploreAccess (开发访问)"、"/servlet/ExploreAssembly (?f发?匚编)"， 其分别使得其动作类为开发公共目录、开发访问组目录、开发目录、开发访问和开发汇编。</p>
    <p>第三个框架在右侧主体区但在上方位置并且由ID "F2"标识。F2以详细模式或以&#32302;略图模式呈现子页面的列表显示，其还呈现实体的页面显示以及其他管理和编辑界面等。其"src" 属性的可能值为："/servlet/PageChildPublicList (页面孩子公共列表）"、 "/servlet/PageChildAccessGroupList (页面孩子访问组列表）"、"/servlet/PageCWldList (页 面孩子列表）"、'7servlet/PageChildAccessList (页面孩子访问列表）"、"/servlet/Page (页</p>
    <p>面）"，其分别使得其动作类为页面孩子公共列表、页面孩子访问组列表、页面孩子列表、页 面孩子访问列表以及页面Servlet。每一个请求URI可调用其自己的和另一个请求以进行进一 步动作。</p>
    <p>第四个框架在右侧主体区但在底部位置并且由ID "F3"标识。F3呈现将进行操作的动 作界面并且随后在框架Fl和F2上反映结果等。其"src"属性的可能值为： "/servlet/ManagePageAccessTree (管理页面访问树）"、"/servlet/HangMosaic (悬挂镶嵌）"， 其各自的相应动作类为管理页面访问树、悬挂镶嵌。每一个请求URI可调用其自己的和另一 个请求以进行进一步动作。</p>
    <p>由ID "FS0"标识的第一框架集元素封入所有框架，并且其将FO与其余的分开，其余的 被组织成ID为"FS1"的另一个框架集。字符串"23, *"被定义为FS0的"行"属性的初始 值，这意味着对F0的高度定义为23像素以及对FS1的其余高度。字符串"100%"被定义为 FS0的"列"属性的初始值，这意味着F0和FS1两者皆延伸至web浏览器的整个宽度。</p>
    <p>第二框架集FS1封入Fl 、 F2和F3，但将Fl与F2和F3分开。F2和F3被组织成ID为 "FS2"的另一个框架集。FS1的"行"属性的初始值被定义为"100%"，这意味着F1和FS2 两者皆延伸至FS1的整个高度；FS1的"列"属性的初始值被定义为"20%， 80%"，这意味 着Fl占用FS1的宽度的20%而FS2占用FS1的宽度的80%。</p>
    <p>第三框架集FS2封入F2和F3。其"行"属性的初始值被定义为"60%，40%"，这意味 着F2占用FS2的高度顶部的60%而FS3占用FS2的高度底部的40%。 FS2的"列"属性的初 始值被定义为"100%"，这意味着F2和F3两者皆延伸至FS2的整个宽度。FS2的"行"属 性的初始值取决于初始要求可具有诸如"*,0"或"80%, 20"的变化，但这实际上并不重要。</p>
    <p>重要的是当用户调整框架的大小时，在需要重载时或调用刷新时系统如何能跟踪这些改 变并且维护新大小。其次重要的是在不同菜单Id或菜单索引选择下跟踪每一个框架的URL(统 一资源定位符）或"href"属性。将所有框架的ID作为自变量传入以获取web浏览器中每一 个框架的高度和宽度信息并且以Ajax函数调用来将这些数据送回给服务器侧的名为"保存大 小"的JavaScript函数被嵌入框架F0和F3中，从而监听框架的调整大小事件。将框架的ID 作为自变量传入以获取该框架的URL或"href"属性并且以Ajax函数调用来将该信息送回给 服务器侧的名为"保存Url"的另一个JavaScript函数被嵌入每一个框架中，从而监听每一个 框架的加载事件。在服务器侧，开发类的实例接收该信息，处理该信息并且将其存储在其请求 范围散列表中。当在"/servlet/Explorer"上以菜单索引调用请求时，根据指定的菜单索引或通 过使用默认值0，动作类开发检索每一个框架的所保存URL以及大小信息，大小信息被用于 重构对每一个框架集的"行"和"列"属性的定义。因此，恰当的框架布局和URL信息能被维护并如期望地返回用户。所有这些提供用以与之交互的良好用户界面。</p>
    <p>在菜单索引=0时，在左手侧，框架F1显示一组"公共"页面的目录树导航视图。这 些页面已被授予公共访问。Fl的请求URI为"/servlet/ExplorePublicDirectoiy"，其对应于底 层动作类开发公共目录。有两种导航模式："目录视图"和"页面视图"。"目录视图"仅向 下导航至目录页面（父页面）。并且当用户点击目录页面时，在右手侧，框架F2示出该父页 面的子页面的列表，其在"详细"视图模式下列出详细信息而在"&#32302;略图"视图模式下列出代 表每一个子页面的&#32302;略图。F2的请求URI为"/servlet/PageChildPublicList"，其对应于底层动 作类页面孩子公共列表。另一方面，"页面视图"可向下导航至目录树中的每一个页面，并且 当用户点击树中的任一个页面中时，该页面的html文件将出现在右手侧的框架F2中。F2的 请求URI为"/servlet/Page"，其对应于底层动作类页面Servlet，页面Servlet是Servlet基类的 子类并实现Servlet呈现。</p>
    <p>在菜单索引=l时，在左手侧，框架F1显示一组"共享"页面的目录树导航视图。这 些页面已被授予 一 个或多个用户访问组。Fl的请求URI为 "/servlet/ExploreAccessGroupDirectory"，其对应于底层动作类开发访问组目录。有两种导航 模式："目录视图"和"页面视图"。"目录视图"仅向下导航至目录页面（父页面）。并且 当用户点击目录页面时，在右手侧，框架F2示出该父页面的子页面的列表，其在"详细"视 图模式下列出详细信息而在"&#32302;略图"视图模式下列出代表每一个子页面的&#32302;略图。F2的请 求URI为"/servlet/PageChildAccessGroupList"，其对应于底层动作类页面孩子访问组列表。 另一方面，"页面视图"可向下导航至目录树中的每一个页面，并且当用户点击树中的任一个 页面中时，该页面的html文件将出现在右手侧的框架F2中。F2的请求URI为'7servlet/Page"， 其对应于底层动作类页面Servlet。</p>
    <p>在菜单索引=2时，在左手侧，框架F1显示一组"根"页面的目录树导航视图。这些 页面是用户拥有或用户对其具有管理员权限的所有页面。Fl的请求URI为 "/servlet/ExploreDirectoiy"，其对应于底层动作类开发目录。有两种导航模式："目录视图" 和"页面视图"。"目录视图"仅向下导航至目录页面（父页面）。并且当用户点击目录页面 时，在右手侧，框架F2示出该父页面的子页面的列表，其在"详细"视图模式下列出详细信 息而在"&#32302;略图"视图模式下列出代表每一个子页面的&#32302;略图。F2的请求URI为 "/servlet/PageChildList"，其对应于底层动作类页面孩子列表。另一方面，"页面视图"可向 下导航至目录树中的每一个页面，并且当用户点击树中的任一个页面中时，该页面的html文 件将出现在右手侧的框架F2中。F2的请求URI为"/servlet/Page"，其对应于底层动作类页 面Servlet。存在名为"新目录"的html按钮用于调用对目录或目类型页面的创建。还存在名 为"新"的另一个html按钮用于在父页面是目类型页面的情况下调用对专用实体页面的创建， 或者在父页面是目录页面的情况下调用对来自实体列表的可选实体页面的创建。存在名为"剪 切"和"粘贴"的两个html按钮。它们用于在整个目录结构中四处移动页面或目录树。</p>
    <p>图6是菜单索引=2的基于浏览器的用户接口 600的示例性实施例，其中框架F0 611在顶主体区并指向请求URI的"/servlet/Menu"，其呈现一系列html按钮，这些按钮呈现将被 调用的每一个菜单或动作选择，框架F1 613指向请求URI "/servlet/ExploreDirectory"用于对 目录树结构进行查看和导航并指定父页面，而框架F2 615指向请求URT/servlet/PageChildList" 用于查看指定父页面的子页面的列表以及用于创建和管理页面。</p>
    <p>在菜单索引=3时，在左手侧，框架F1显示三组页面（公共、共享、根）的目录树导 航视图。"导航"仅向下导航至目录页面。Fl的请求URI为"/servlet/ExploreAccess"，其对 应于底层动作类开发访问。 一旦目录页面（父页面）被点击，在右手侧，框架F2指向请求 URI "/servlet/PageChildAccessList"，其示出父页面的子页面具有关于每一个页面的可访问性 和访问类型（不同访问级别的私有、公共、访问组）的详细信息的列表。点击子页面的标题左 侧嵌入了链接的图标将用户接口向下引导至请求URI "/servlet/ManagePageAccess"，其对应 于底层动作类管理页面访问，其中可个别地管理用户的可访问性。另一方面，在右手侧，框架 F3服务请求URI "/servlet/ManagePageAccessTree"的请求，其中恰当的访问类型和访问级别 可被定义并应用于自所选父页面开始的页面目录树， 一旦通过点击提交按钮应用，结果立即反 映在框架F2上。</p>
    <p>图7是菜单索引=3的基于浏览器的用户接口 700的示例性实施例，其中框架F0 711在 顶主体区并指向请求URI的"/servlet/Menu"，其呈现一系列html按钮，这些按钮呈现将被 调用的每一个菜单或动作选择，框架F1 713指向请求URI "/servlet/ExploreAccess"用于对目 录树结构进行查看和导航并指定父页面，而框架F2 715指向请求URI 'Vservlet/PageChildAccessList"用于&#26619;看父页面的子页面的列表的可访问性，以及F3 717指向 请求URI "/servlet/ManagePageAccessTree"用于创建和修改从指定父页面开始的整个页面树的 可访问性。</p>
    <p>在菜单索引=4时，在左手侧，框架F1显示两组页面的目录树导航视图。第一组仅包 括与镶嵌实体映射的一个或多个页面，但排除与其他实体映射的页面。第二组包括所有页面， 除了不与如何实体映射的特定和引用类型的页面。框架Fl服务请求URI</p>
    <p>"/servlet/ExploreAssembly"的请求，其对应于底层动作类开发汇编。当选择第一组中的页面 之一时，在右手侧，框架F2通过对应于底层动作类页面Servlet的请求URI "/servlet/Page"的 请求示出该页面代表的html文件。在右手侧，框架F3示出名为"视图模式"、"编辑模式"、</p>
    <p>"编辑CSS"以及"树操作"的一些嵌入html按钮，连同用于输入X和Y值的悬挂位置的两 个输入区，该呈现通过对应于底层动作类悬挂镶嵌（HangMosaic)的请求URI</p>
    <p>"/servlet/HangMosaic"的请求来服务。当选择第二组中的页面之一 （专用类型，与特定实体 映射）时，框架F3还示出对该特定实体的嵌入呈现，从而作者可使用该实体以悬挂于选自第 一组的页面或镶嵌上。"视图模式"是默认的。当通过点击按钮调用"编辑模式"时，框架 F2的视图示出一些嵌入html按钮用于每一个镶嵌的移除和编辑，其中示出其悬挂位置信息， 并以粗体显现每一片的html表和单元格元素的边界以示出嵌套结构信息。在有限元格和有限 元镶嵌悬挂线程中通过将Servlet处理的实例中名为"&#8212;iMode"的字段从"正常"调整为"管理"来达成此结果。在此，"正常"和"管理"分别为数字0和1。当通过点击引导至对应于 底层动作类树形悬挂镶嵌的请求URI "/servlet/HangMosaicOnTree"的请求的按钮调用"树操 作"时，出现过滤条件用于从选自第一组的页面开始并根据所选过滤条件选择将实体悬挂于目 录树中的那些页面上。当调用引导至对应于底层动作类管理Css的请求URI</p>
    <p>"/servlet/ManageCss"的请求的"编辑CSS"时，框架F3示出并列出每一片的相应表及其行 和单元格元素以及每一个元素的样式表信息，提供用于每一个元素的名为"编辑"的html按 钮用于向下抵达每一个个别元素的管理接口以通过请求URI "/servlet/ManageCssElement"的 请求以及底层动作类管理Css元素来管理其样式表信息。</p>
    <p>图8是用于在菜单索引=4时显示和汇编页面的基于浏览器的用户接口 800的示例性实施 例，其中框架F0 811在顶主体区并指向请求URI的"/servlet/Menu"，其呈现一系列html按 钮，这些按钮呈现将被调用的每一个菜单或动作选择，框架Fl 813指向请求URI</p>
    <p>"/servlet/ExploreAssembly"用于&#26619;看和选择页面和镶嵌以及&#26619;看和选择与特定实体映射的镶 嵌和页面，框架F2 815指向请求URI "/servlet/Page"用于在视图模式（"正常"模式）或编 辑模式（"管理"模式）下查看所选页面，框架F3 817指向请求URI "/servlet/HangMosaic" 用于将所选镶嵌或实体悬挂于所选页面上。</p>
    <p>图9是用于在菜单索弓1=4时显示和汇编页面的基于浏览器的用户接口 900的示例性实施 例，其中框架F0 911在顶主体区并指向请求URI的"/servlet/Menu"，其呈现一系列html按 钮，这些按钮呈现将被调用的每一个菜单或动作选择，框架Fl 913指向请求URI</p>
    <p>"/servlet/ExploreAssembly"用于&#26619;看和选择页面和镶嵌以及&#26619;看和选择与特定实体映射的镶 嵌和页面，框架F2 915指向请求URI "/servlet/Page"用于在编辑模式（"管理"模式）下&#26619; 看所选页面，框架F3 917指向请求URI "/servlet/HangMosaic"用于将所选镶嵌或实体悬挂于 所选页面上。</p>
    <p>图10是用于在菜单索引4时显示和管理页面的CSS元素的样式表信息的基于浏览器的 用户接口 1000的示例性实施例，其中框架F0 1011在顶主体区并指向请求URI的 "/servlet/Menu"，其呈现一系列html按钮，这些按钮呈现将被调用的每一个菜单或动作选择， 框架Fl 1013指向请求URI "/servlet/ExploreAssembly"用于&#26619;看和选择页面和镶嵌以及&#26619;看 和选择与特定实体映射的镶嵌和页面，框架F2 1015指向请求URI "/servlet/Page"用于在视图 模式（"正常"模式）或编辑模式（"管理"模式）下查看所选页面，框架F3 1017指向请求 URI "/servlet/ManageCss"，其示出并列出每一片的相应表及其行和单元格元素以及每一个元 素的样式表信息，其中提供用于每一个元素的名为"编辑"的html按钮用于向下抵达每一个 个别元素的管理接口以管理其样式表信息。</p>
    <p>在一个实施例中，作为实体的子集，图片被定义为实体的子类并用于代表图片。其相应 的呈现类图片呈现（PicturePresentation)实现用于图片的呈现的实体呈现接口 。实现方法之一 是 getPresentation(HttpServletRequest req, HttpServletResponse resp, ServletSession ss, ServletProcessor sp, ServletBase sb, Object[] printid, Object identifier),其返回一对象。在此，标识符标识图片实体。图片实体的创建和编辑是通过对应于底层动作类管理图片（ManagePicture) 的请求URI "/servlet/ManagePicture"的请求进行的。管理图片继承Servlet基类并实现Servlet 呈现接口 。 实现方法getPresentation(HttpServletRequest req, HttpServletResponse resp, ServletSession ss, ServletProcessor sp, ServletBase sb, Object[] printid, Object identifier)负责对请求 构造响应。在图片实体的创建和修改期间，图片源文件可被上传或改变，并且出于带宽考虑创 建&#32302;略图或中等大小图片并将其用于代替原始源文件呈现图片以进行快速响应。&#32302;略图或中等 大小图片的创建可能要花费一定时间才能完成。为了减少用户等待的时间并加速响应，通过从 管理图片的"张贴（doPost)"方法内产生线程并向web应用服务器送出请求以处理异步任务 来将这些任务放入异步进程中。完成此操作的结构和工作流在以下描述。</p>
    <p>服务器动作界面（ServerActionlnterface)界面定义在服务器侧执行异步任务的公共方法 签名，该方法签名作为无返回的performAction(H邻ServletRequestreq, HttpServletResponse resp， ServletSession ss, ServletProcessor sp, ServletBase sb)。</p>
    <p>服务器动作（ServerAction)类及其相应的名为"服务器动作"的数据库表被定义并用于 维持标识异步任务的标识符、发起任务的位置、服务器动作界面的实现类的完全匹配类名、用 户信息、用户的语言偏好、发起任务的时序、在发起任务时随机创建并用于以后认证的用户名 和口令的相关联信息。</p>
    <p>继承Servlet基类的服务器动作控制器（ServerActionController)类被定义并用于处理对 用于开始异步任务的请求的接收和派遣。相应的请求URI是"/servlet/ServerActionController"。 在收到请求之际并且在恰当的认证之后，服务器动作控制器实例化服务器动作界面的实现类的 实例并调用其performAction方法，且随后在执行该方法后返回。服务器动作界面的实现类可 以可任选地进一步指定可从perfonnAction方法内实例化和执行的动作类。当然，该动作类的 完全匹配类名还需要在请求中指定&#8212;&#8212;若希望如此，performAction方法随后可解析它并进行 处理。</p>
    <p>在管理图片内部，将具有相关联信息、此外还有实现服务器动作界面的图片呈现的完全 匹配类名、以及诸如创建图片元数据（CreatePictureMetaData)、创建子类型图片 (CreateSubTypePicture)、以及创建多个子类型图片（CreateSubTypePictures)等动作类的完 全匹配类名的请求发送至"/servlet/ServerActionCon加Iler"。在收到该请求之际并且在用存储 在数据库表"服务器动作"中的值验证所附用户名和口令之后，服务器动作控制器实例化图片 呈现的实例并调用其执行动作方法。在执行动作方法内部，动作类的完全匹配类名被解析并实 例化一实例，且随后被执行。创建图片元数据解析图片的元数据，诸如其宽度和高度信息；创 建子类型图片创建图片的中等大小图片;创建多个子类型图片创建图片的缩略图和中等大小的 图片。</p>
    <p>在一个实施例中，作为实体的子集，音乐被定义为实体的子类并用于代表音乐。其相应 的呈现类音乐呈现（MusicPresentation)实现用于音乐的呈现的实体呈现界面。实现方法之一 是   getPresentation(HttpServletRequest   req，   H邻ServletResponse   resp,   ServletSession ss,ServletProcessorsp,ServletBasesb,Object[]printid， Object identifier),其返回一对象。在此，标识 符标识音乐实体。音乐实体的创建和编辑是通过对应于底层动作类管理音乐（ManageMusic) 的请求URI "/servlet/ManageMusic"的请求进行的。管理音乐继承Servlet基类并实现Servlet 呈王见界面。方'法getPresentation(HttpServletRequest req, HttpServletResponse resp, ServletSession ss， ServletProcessor sp, ServletBase sb， Object[] printid, Object identifier)负责对请求构造响应。在音乐 实体的创建或修改期间，音乐源文件可被上传和改变，音乐的元数据被解码和用于呈现音乐。 解码可能费时不久。为了减少用户等待的时间并加速响应，通过从管理音乐的"doPost"方法 内产生线程将该任务放入异步进程中，并且将具有相关联信息、此外还有实现服务器动作界面 的音乐呈现的完全匹配类名、以及诸如创建音乐元数据（CreateMusicMetaData)等动作类的完 全匹配类名的请求发送至'7servle1/ServerActionController"。在收到该请求之际并且在用存储 在数据库表"服务器动作"中的值验证所附用户名和口令之后，服务器动作控制器实例化音乐 呈现的实例并调用其执行动作方法。在performAction方法内部，动作类创建音乐元数据的完 全匹配类名被解析并实例化一实例，且随后被执行。创建音乐元数据解析音乐的元数据，诸如 作者、专辑、年代、曲目、流派、版权、以及评级等。</p>
    <p>在收到请求之际，页面Servlet类（ServletBase基类的子类）的实例解析名为"模式"的 参数以获得其值。该值将设置Servlet处理的实例中名为"&#8212;iMode"的字段的值。其具有4个 可能值"正常"、"管理"、"半静态"、"全静态"，其分别对应于0、 1、 2和3。该值决 定所生成的响应是像在"正常"和"管理"的情形中那样送回给用户的web浏览器，还是像 在"半静态"和"全静态"的情形中那样被写下并保存在本地文件中供以后检索。每一种模式 的差别简要地解释如下。</p>
    <p>"正常"是默认模式。</p>
    <p>当模式处于"管理"时，出现一些嵌入html按钮用于每一个镶嵌的移除和编辑，其中示 出其悬挂位置信息，连同粗体出现的每一片的html表和单元格元素的边界以示出嵌套结构信 息。该结果在有限元格和有限元镶嵌悬挂线程中达成。</p>
    <p>当模式处于"半静态"时，所生成的响应被保存到本地文件（半静态文件）中供以后检 索，其中以页面的标识符作为其文件名以及".htm"作为其文件扩展。在收到相同页面上的请 求之际并取决于一些过滤条件（诸如老化），代替再次动态地生成响应，此文件可被检索并送 回给用户。半静态文件中的嵌入链接若它们并非链接至静态资源则处于诸如"/servlet/Page" 等动态样式以访问页面。</p>
    <p>当模式处于"全静态"时，所生成的响应被保存到本地文件（全静态文件）中供以后检 索，并以页面的标识符作为其文件名以及".htm"作为其文件扩展来构成"电子书（eBook)"。 此文件在被请求之际被送回给用户。嵌入式链接处于诸如"标识符.html"等静态样式以访问 页面的html文件。在完成之际，与网站相关联的所有全静态文件和相关静态资源被复制到本 地硬驱动的文件夹中，这构成可从web浏览器启动并查看的电子书，并且能在无需web应用 服务器或web服务器的情况下浏览所有页面。该文件夹中的整个内容还可被烧制成CD、DVD，或可被复制到USB闪存驱动中进行存储或四处携带以供以后像纸书那样浏览，除了需要带有 web浏览器的计算机。</p>
    <p>当在会话期间连贯地拜访或请求页面时，在收到该请求之际，页面Servlet类的实例将通 过其"setRefreshFlag (设置刷新标记）"方法把Servlet处理的实例中名为"_blRefresh"的字 段的值设为真。在这种条件下，页面的html文件被动态地生成并被送回给用户。在搜索框呈 现中实现了高速缓存机制，其在存储器块（散列表）中存储上次访问的搜索结果和呈现，在下 次访问相同搜索框时，代替再次进行搜索并处理呈现，将返回存储在该高速缓存中的内容。然 而，如果字段"_blRefreSh"的值为真，则此特征被禁用并且将完整地进行搜索和呈现。</p>
    <p>在到达生成响应和收到通知的结尾时，无自变量且无返回并且实现在Servlet处理中的方 法endO送出缓冲器层次中的任何内容残留并将其清空。如果响应封入框架集，则"々html〉" 被附于响应的结尾，否则"&lt;body&gt;&lt;/html&gt;"被附于响应的结尾以完成整个响应生成过程。取 决于页面的标识符是否已被放入开始散列表中的关键字"有限元.页面"下，这发生在页面 Servlet的实例中，end()方法可通过对具有标识页面的标识符和指定应对请求和后续检索生成 半静态文件的值为"半静态"的"模式"参数的请求URI "/servlet/Page"的请求产生新线程 来送出请求。</p>
    <p>在处理文件上传（文档、图片、音乐、视频等）时，上传的文件被解析、流线化、并保 存在媒体服务器中，该媒体服务器负责管理文件的存储、检索、和删除。所生成的指针和文件 的扩展被用作文件的存储、删除和检索的句柄。如果发现传入请求是"多部分/格式-数据 (multipart/form-data)"类型，则在上传期间的解析和流线化在多部分请求（MultipartRequest) 类的实例中处理。多部分请求类是Servlet会话类的超类。</p>
    <p>媒体类被定义并用于呈现文件。媒体，即媒体类的实例，用指针和文件扩展来标识，该 文件扩展可为空。如果媒体服务器正好在相同的计算机机器中，则媒体使用缓冲的输入流通过 媒体客户机（MediaClient)类的实例方法调用或本地获取来检索文件。如果媒体服务器正好在 相同的计算机机器中，则通过媒体客户机类的实例方法调用或本地进行来删除媒体。作为媒体 客户机的实例，在被实例化时，建立用于与媒体服务器通信的套接字，并使用缓冲的输出流来 送出命令和相关参数，并且使用缓冲的输入流从媒体服务器检索文件。媒体服务器包括两部分: 媒体服务器（MediaServer)类和媒体处理（MediaProcessor)类。媒体服务器在默认端口 （9498) 上建立服务器套接字（ServerSocket)并监听传入请求。 一旦收到请求，媒体服务器将把该请 求传递给媒体处理类的实例，媒体处理的该实例将相应地处理该请求以删除文件、保存文件、 或检索文件。</p>
    <p>媒体接口 （Medialnterface)接口定义实体的实体呈现实现类可实现的公共方法签名，因 此可使用一般方式来检索并未保存在数据库中的外部文件，无论其是文档、图片、音乐还是视 频等。在一个实施例中，作为媒体的图片由其扩展和图片类中的指针来标识，实现媒体接口的 图片呈现的实例通过获取媒体（getMedia)方法获取该媒体，并且随后通过媒体的获取缓冲输 入流"getBufferedlnputStream"方法获得缓冲的输入流以送出该图片。媒体具有不同的子类型，诸如图片的&#32302;略图和中等大小图片；子类型默认值为0。</p>
    <p>在一个实施例中，获取媒体（GetMedia)类，即请求URI "/servlet/GetMedia"的动作类 和Servlet基的子类，被用于检索媒体和送出给用户。在检索实体的实体呈现实现类的完全匹 配类名和标识实体的标识符、以及用于认证的用户名和口令之际，通过其缓冲的输入流标识和 检索媒体，随后使用响应的输出流将输入流送出给请求用户。媒体可进一步由默认值为O的子 类来标识。在创建或修改实体期间生成用户名和口令并将其存储在映射页面中。它们随后在实 体的呈现生成过程期间被检索和附连至媒体链接。</p>
    <p>在一个实施例中，作为实体的子集和实体类的子类，简单文本（SimpleText)被标识并 用于代表不包括html代码片段的纯文本块，从而纯文本块可简单地从其源复制并粘贴到简单 文本的实例中，并且通过实现实体呈现接口的简单文本呈现（SimpleTextPresentation)类的实 例呈现为html文件。创建、读取、更新和移除通过作为Servlet基的子类和实现Servlet呈现的 管理简单文本（ManageSimpleText)来管理。</p>
    <p>在一个实施例中，作为实体的子集和实体类的子类，Html文本（HtmlText)被标识并用 于代表html代码片段块，从而作者可创建或将html代码片段块复制到Html文本的实例中， 并且通过实现实体呈现接口的Html文本呈现（HtmlTextPresentation)类的实例呈现为html文 件。创建、读取、更新和移除通过作为Servlet基的子类和实现Servlet呈现的管理Html文本 (ManageHtmlText)来管理。</p>
    <p>在一个实施例中，作为实体的子集和实体类的子类，收藏（Favorite)类被定义并用于代 表微软的因特网浏览器的收藏夹中的收藏链接。收藏的url链接从其底层文件被解析和提取并 且被保存至收藏的实例，其随后通过实现实体呈现接口的收藏呈现（FavoritePresentation)类 的实例被呈现。创建、读取、更新和移除通过作为Servlet基的子类和实现Servlet呈现的管理 收藏（ManageFavorite)来管理。</p>
    <p>在一个实施例中，作为实体的子集和实体类的子类，网页（Webpage)类被定义并用于 代表保存在本地硬驱动的文件夹中的html文件及其相关联内容。保存在本地硬驱动的文件夹 中的html文件及其相关联内容来自在web浏览器环境中诸如在微软因特网浏览器中进行的动 作，用户点击浏览器顶级菜单中的"文件"并随后点击"保存为..."，其弹出询问将保存至其 中的文件名的对话窗，并且对话窗中的默认"保存为类型："为"网页，完整（气htm,气html)"。 网页的实例通过实现实体呈现接口的网页呈现（WebpagePresentation)类的实例来呈现。创建、 读取、更新和移除通过作为Servlet基的子类和实现Servlet呈现的管理网页（ManageWebpage) 来管理。</p>
    <p>可手动地逐一创建文档、图片、音乐、视频并将其映射到页面。另一方面，在指定文件 夹的路径和要创建的相应实体之后，可创建本地硬驱动中的文件的文件夹并通过映射线程自动 将其映射到页面。本地文件或文件夹的路径信息随所创建的相应实体一起被保存。</p>
    <p>在一个实施例中，管理目录映射（ManageDirectoryMap)类继承Servlet基并实现Servlet 呈现接口。在其doGet (获取）方法中，产生线程以连同动作类创建目录映射(CreateDirectoryMap)的完全匹配类名一起将异步请求送出至服务器动作控制器，并通过调 用在创建目录映射类的实例的执行动作方法内部实例化的映射目录（MapDirectory)类的实例 来要求弹出对话窗。在对话窗内部，用户可导航至文件夹并随后从潜在实体呈现的完全匹配类 名的列表中选择文件夹的实体类型，该列表是由目录过滤（DircctoryFilter)类的实例生成的。 一旦用户作出选择，该信息就被保存到本地文件夹中并且该文件夹的路径被返回作为响应，文 件夹的路径在文件分隔符用点"."字符代替后被用作本地文件的文件名。管理目录映射还显 示当前所选文件夹、其指定实体类型、从文件夹向下至进行映射的深度、维持映射页面的父页 面、以及对映射页面的访问定义的列表。访问定义将从父页面中继承。管理目录映射父 (ManageDirectoiyMapParent)处理对所选文件夹的父页面的选择。映射文件系统线程 (MapFileSystemThread)线程将通过调用映射文件系统（MappingFileSytem)类的映射页面 (mapPage)实例方法来开始映射文件夹和文件，该方法根据文件夹的指定实体类型向下逐个 导航至每一个文件夹、每一个文件，创建相应的实体和与其映射的页面并处理其他相关联任务。 在该过程期间，文件的路径被转换成相对URL，其随后被用于嵌入链接以检索该文件。在完 成映射过程之际，生成每一个页面的半静态和全静态html文件，并且随后与网站相关联的所 有全静态文件和相关静态资源被复制到本地硬驱动的文件夹中，以构成可从web浏览器启动 并查看的电子书，并且能在无需web服务器或web应用服务器的情况下浏览所有页面。</p>
    <p>图11是用于显示和管理所选本地文件夹及其指定实体类型的列表的基于浏览器的用户 接口 1100的示例性实施例，其中框架F0 1111在顶主体区并指向请求URI的"/servle1/Menu"， 其呈现一系列html按钮，这些按钮呈现将被调用的每一个菜单或动作选择，框架F1 1113指 向请求URI "/servlet/ManageDirectoryMap"用于&#26619;看和管理所选本地文件夹及其指定实体类型 的列表，弹出对话窗1115允许用户导航至本地文件夹并随后从实体列表中选择文件夹的实体 类型。</p>
    <p>同时，由于文件夹及其文件是由用户任意选择的，因此这些信息被在映射文件系统线程 中实现的类方法"获取公共目录（getPublicDirectories)"收集作为目录路径的列表，并在该 网站被部署在Apache Tomcat web应用服务器上时被传递至Apache Tomcat的默认Servlet。目 录路径信息在实现Servlet上下文监听（ServletContextListener)的Servlet上下文管理</p>
    <p>(ServletContextManager)类中被搜集并被放入Servlet上下文中，从而其能在默认Servlet的 服务资源（serveResource)方法中被检索。</p>
    <p>如果页面被映射到本地文件或文件夹并且用户通过打开与web应用服务器位于相同计算 机机器上的web浏览器来浏览该页面，嵌入页面的呈现中的指向请求URI</p>
    <p>"/servlet/OpenFileSystem (打开文件系统）"并连同至该页面所映射的本地文件或文件夹的路 径信息一起提供的链接可被调用以通过诸如Windows浏览器等计算机机器的文件管理程序来 打开该文件或文件夹。"/servlet/OpenFileSystem"的底层动作类是打开文件系统类（Servlet 基的子类）。如果web应用服务器在后端运行而不能与用户交互，则需要在不同端口上的前 端并行运行的相同web应用服务器，在这种情形中，打开文件系统的实例将带有相关信息的请求转发给前端web应用服务器的"/servlet/ServerActionController "并要求打开路径(OpenPath) 类（服务器动作接口的实现）的动作来打开该文件或文件夹。这提供了将web环境与本地文 件管理程序集成的无缝工作环境。在一个实施例中，符号"@"被用作链接的标题以指示这种 特征的意义。</p>
    <p>在一个实施例中，Apache Tomcat被用作web应用服务器，其在Java虚拟机（JVM)上 运行并包括用于向web应用提供服务的web容器；用户打开的web浏览器可在与web应用服 务器相同的计算机机器上运行或者可在具有至web应用服务器的计算机机器的通信连接的不 同或远程计算机机器上运行。</p>
    <p>web应用服务器包括本质上是与servlet交互的web服务器的组件的web容器。web容器 负责管理servlet的生命周期、将URL映射到特定servlet并确保该URL请求方具有正确的访 问权利。</p>
    <p>Servlet是接收请求（Servlet请求）并基于该请求生成响应（Servlet响应）的对象。Servlet API封装javax.servlet.http定义通用servlet (HttpServlet)请求（HttpServlet请求）和响应 (HttpServlet响应）、以及跟踪web服务器与客户机之间的多个请求和响应的会话（Http会话） 的HTTP子类。</p>
    <p>在一个实施例中，Servlet基类继承HttpServlet类以接收web容器提供的响应以及用于检 索请求和送出响应。Servlet基实现具有4个自变量的开始方法：HttpServlet请求的实例、 HttpServlet响应的实例、Servlet会话的实例、以及Servlet处理的实例，该开始方法产生封装 Servlet处理实例的begin()方法的新线程；Servlet基还实现具有4个自变量的结束方法： HttpServlet请求的实例、HttpServlet响应的实例、Servlet会话的实例、以及Servlet处理的实例， 该结束方法封装Servlet处理实例的end()方法；Servlet基还提供用于将开始方法和结束方法封 装在一起的常规方法dolt (完成）。</p>
    <p>在一个实施例中，Servlet请求的实例被传入以实例化多部分请求类的实例，用于在传入 请求是"多部分/格式-数据"类型的情况下解析参数值对和二进制流上传。Servlet会话类继承 多部分请求类。</p>
    <p>在一个实施例中，Servlet处理类的实例通过传入HttpServlet请求、HttpServlet响应、Servlet 会话、和Servlet基的实例作为其构造函数的4个自变量来实例化。Servlet处理负责处理传入 请求和生成响应。</p>
    <p>作为一般抽象类，有限元抽象（FeaAbstract)类的实例维持HttpServlet请求、HttpServlet 响应、Servlet会话、Servlet处理和Servlet基的实例的信息。有限元抽象类的所有实例还共享 根据用户的不同语言偏好提供国际化和本土化支持的资源类的实例。 有限元类被定义为用于实际实现和实例化的有限元抽象类的子类。 有限元矩阵类继承有限元类并实现Java编程语言的可运行接口 ，从而有限元矩阵的实例 可作为线程来执行。有限元矩阵的实例还被传入对象数组的信息作为关键字链、矩阵标记的有 限元标记实例以及矩阵标记结束的另一个有限元标记实例和镶嵌悬挂的列表，并且在根据其X和Y值挑选出镶嵌悬挂的列表之后生成一组片和每一个片中的格的信息。</p>
    <p>有限元片类继承有限元矩阵类。有限元片的实例代表一片并且被传入一组片的片的索引 信息，并作为线程被执行。</p>
    <p>有限元格类继承有限元片类。有限元格的实例代表片中的格并且被传入片中的格的索引 信息以及该格代表的对象，并且作为线程被执行。</p>
    <p>有限元镶嵌悬挂类继承有限元矩阵类。有限元镶嵌悬挂的实例代表一镶嵌悬挂并且被传 入一片的格的索引信息和镶嵌悬挂的标识符，并作为线程被执行。</p>
    <p>有限元框类继承有限元格类。有限元框的实例代表关于片中的矩形区的一组镶嵌悬挂并 且被传入片中的格的索引信息以及该组镶嵌悬挂，并且作为线程被执行。</p>
    <p>有限元镶嵌类继承有限元类并实现Java编程语言的可运行接口 ，从而有限元镶嵌的实例 可作为线程来执行。有限元镶嵌的实例被传入对象数组的信息作为关键字链以及标识镶嵌的标 识符，并作为线程来执行。</p>
    <p>在一个实施例中，数据库为SQL (结构化查询语言）类型关系数据库管理系统（MS SQL、 Oracle、 Apache Derby或MySQL)之一。JDBC (Java数据库连接）驱动器用于访问和操作保 存在数据库中的数据。</p>
  </div>
  </div></div><div class="patent-section patent-tabular-section"><a id="forward-citations"></a><div class="patent-section-header"><span class="patent-section-title"> 被以下专利引用</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">引用专利</th><th class="patent-data-table-th"> 申请日期</th><th class="patent-data-table-th">公开日</th><th class="patent-data-table-th"> 申请人</th><th class="patent-data-table-th">专利名</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN101984438A?cl=zh">CN101984438A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2010年11月27日</td><td class="patent-data-table-td patent-date-value">2011年3月9日</td><td class="patent-data-table-td ">杭州万格网络科技有限公司</td><td class="patent-data-table-td ">一种在线自助建站、创建应用服务与开发在线软件的方法</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN101984438B?cl=zh">CN101984438B</a></td><td class="patent-data-table-td patent-date-value">2010年11月27日</td><td class="patent-data-table-td patent-date-value">2012年9月5日</td><td class="patent-data-table-td ">杭州万格网络科技有限公司</td><td class="patent-data-table-td ">一种在线自助建站、创建应用服务与开发在线软件的方法</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN102622376A?cl=zh">CN102622376A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2011年1月28日</td><td class="patent-data-table-td patent-date-value">2012年8月1日</td><td class="patent-data-table-td ">北京千橡网景科技发展有限公司</td><td class="patent-data-table-td ">用于合并层叠样式表文件的方法和设备</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN102768683A?cl=zh">CN102768683A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2012年6月29日</td><td class="patent-data-table-td patent-date-value">2012年11月7日</td><td class="patent-data-table-td ">北京奇虎科技有限公司</td><td class="patent-data-table-td ">一种图片信息的搜索方法及搜索装置</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN102768683B?cl=zh">CN102768683B</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2012年6月29日</td><td class="patent-data-table-td patent-date-value">2015年11月25日</td><td class="patent-data-table-td ">北京奇虎科技有限公司</td><td class="patent-data-table-td ">一种图片信息的搜索方法及搜索装置</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN103164201A?cl=zh">CN103164201A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2011年12月15日</td><td class="patent-data-table-td patent-date-value">2013年6月19日</td><td class="patent-data-table-td ">航天信息软件技术有限公司</td><td class="patent-data-table-td ">Web页面生成方法</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN104462455A?cl=zh">CN104462455A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2014年12月16日</td><td class="patent-data-table-td patent-date-value">2015年3月25日</td><td class="patent-data-table-td ">北京京东尚科信息技术有限公司</td><td class="patent-data-table-td ">网络数据的展示处理方法和装置</td></tr></table><div class="patent-section-footer">* 由审查员引用</div></div><div class="patent-section patent-tabular-section"><a id="classifications"></a><div class="patent-section-header"><span class="patent-section-title">分类</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> </th><th class="patent-data-table-th"> </th></tr></thead><tr><td class="patent-data-table-td ">国际分类号</td><td class="patent-data-table-td "><span class="nested-value"><a href="https://www.google.com/url?id=XtJ1BwABERAJ&amp;q=http://web2.wipo.int/ipcpub/&amp;usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&amp;notion=scheme&amp;version=20130101&amp;symbol=G06F0017240000">G06F17/24</a></span></td></tr><tr><td class="patent-data-table-td "> 合作分类</td><td class="patent-data-table-td "><span class="nested-value"><a href="https://www.google.com/url?id=XtJ1BwABERAJ&amp;q=http://worldwide.espacenet.com/classification&amp;usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06F17/3089">G06F17/3089</a></span>, <span class="nested-value"><a href="https://www.google.com/url?id=XtJ1BwABERAJ&amp;q=http://worldwide.espacenet.com/classification&amp;usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06F17/2247">G06F17/2247</a></span></td></tr><tr><td class="patent-data-table-td "> 欧洲专利分类号</td><td class="patent-data-table-td "><span class="nested-value">G06F17/22M</span>, <span class="nested-value">G06F17/30W7</span></td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="legal-events"></a><div class="patent-section-header"><span class="patent-section-title">法律事件</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> 日期</th><th class="patent-data-table-th">代码</th><th class="patent-data-table-th">事件</th><th class="patent-data-table-th">说明</th></tr></thead><tr><td class="patent-data-table-td patent-date-value">2009年12月23日</td><td class="patent-data-table-td ">C06</td><td class="patent-data-table-td ">Publication</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">2010年2月17日</td><td class="patent-data-table-td ">C10</td><td class="patent-data-table-td ">Request of examination as to substance</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">2013年8月21日</td><td class="patent-data-table-td ">C02</td><td class="patent-data-table-td ">Deemed withdrawal of patent application after publication (patent law 2001)</td><td class="patent-data-table-td "></td></tr></table><div class="patent-section-footer"></div></div><div class="modal-dialog" id="patent-images-lightbox"><div class="patent-lightbox-controls"><div class="patent-lightbox-rotate-controls"><div class="patent-lightbox-rotation-text">旋转</div><div class="rotate-icon rotate-ccw-icon"></div><div class="rotate-icon rotate-cw-icon"></div></div><div class="patent-lightbox-index-counter"></div><a class="patent-lightbox-fullsize-link" target="_blank">原始图片</a><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_right.png" alt="Next page"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_left.png" alt="Previous page"width="21" height="21" /></div></div><div class="modal-dialog-content"><div class="patent-lightbox-image-holder"><div class="patent-lightbox-placeholder"></div></div></div></div><script>_OC_initPatentsAtb({image_not_available_html: " 未提供图片。\x3ca href\x3d//docs.google.com/viewer?url\x3dpatentimages.storage.googleapis.com/pdfs/a0e0900312244c8de42d/CN101611399A.pdf\x3e查看 PDF\x3c/a\x3e"});</script></div></div></div></div></div><script>(function() {var href = window.location.href;if (href.indexOf('?') !== -1) {var parameters = href.split('?')[1].split('&');for (var i = 0; i < parameters.length; i++) {var param = parameters[i].split('=');if (param[0] == 'focus') {var elem = document.getElementById(param[1]);if (elem) {elem.focus();}}}}})();</script><script>_OC_addFlags({LockSrc:"/books/javascript/lock_50a6672b5f82ffbd39b7a9e87fd4594c.js", Host:"https://www.google.com/", IsBooksRentalEnabled:1, IsBrowsingHistoryEnabled:1, IsWebReaderSvgEnabled:0, IsImageModeNotesEnabled:1, IsOfflineBubbleEnabled:1, IsFutureOnSaleVolumesEnabled:1, IsBooksUnifiedLeftNavEnabled:1, IsMobileRequest:0, IsZipitFolderCollectionEnabled:1, IsAdsDisabled:0, IsEmbeddedMediaEnabled:1, IsImageModeAnnotationsEnabled:1, IsMyLibraryGooglePlusEnabled:1, IsImagePageProviderEnabled:1, IsBookcardListPriceSmall:0, IsInternalUser:0, IsBooksShareButtonEnabled:0, IsDisabledRandomBookshelves:0});_OC_Run({"enable_p13n":false,"is_cobrand":false,"sign_in_url":"https://www.google.com/accounts/Login?service=\u0026continue=https://www.google.com/patents%3Fcl%3Dzh%26hl%3Dzh-CN\u0026hl=zh-CN"}, {"volume_id":"","is_ebook":true,"volumeresult":{"has_flowing_text":false,"has_scanned_text":true,"can_download_pdf":false,"can_download_epub":false,"is_pdf_drm_enabled":false,"is_epub_drm_enabled":false,"download_pdf_url":"https://www.google.com/patents/download/%E7%BD%91%E9%A1%B5_%E7%BD%91%E7%AB%99%E5%BB%BA%E6%A8%A1%E5%92%8C%E7%94%9F%E6%88%90.pdf?id=XtJ1BwABERAJ\u0026hl=zh-CN\u0026output=pdf\u0026sig=ACfU3U0KraxzUNeKlMN4tw8Eu1HNY1wAbw"},"sample_url":"https://www.google.com/patents/reader?id=XtJ1BwABERAJ\u0026hl=zh-CN\u0026printsec=frontcover\u0026output=reader\u0026source=gbs_atb_hover","is_browsable":true,"is_public_domain":true}, {});</script><div id="footer_table" style="font-size:83%;text-align:center;position:relative;top:20px;height:4.5em;margin-top:2em"><div style="margin-bottom:8px"><a href="https://www.google.com/search?hl=zh-CN"><nobr>Google&nbsp;首页</nobr></a> - <a href="//www.google.com/patents/sitemap/"><nobr>站点地图</nobr></a> - <a href="http://www.google.com/googlebooks/uspto.html"><nobr>美国专利商标局 (USPTO) 专利信息批量下载</nobr></a> - <a href="/intl/zh-CN/privacy/"><nobr>隐私权政策</nobr></a> - <a href="/intl/zh-CN/policies/terms/"><nobr>服务条款</nobr></a> - <a href="https://support.google.com/faqs/answer/2539193?hl=zh-CN"><nobr> 关于 Google 专利</nobr></a> - <a href="//www.google.com/tools/feedback/intl/zh-CN/error.html" onclick="try{_OC_startFeedback({productId: '72792',locale: 'zh-CN'});return false;}catch(e){}"><nobr>发送反馈</nobr></a></div></div> <script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-27188110-1");pageTracker._setCookiePath("/patents/");pageTracker._trackPageview();</script> </body></html>