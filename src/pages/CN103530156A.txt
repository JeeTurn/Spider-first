<!DOCTYPE html><html><head><title>专利 CN103530156A - 动态加载和调用程序的方法及装置 -  Google 专利</title><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){var d=void 0!=b?b:(new Date).getTime();this.t[a]=[d,c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(e){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_",
"_wtsrt",d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})();
</script><link rel="stylesheet" href="/patents/css/_50a6672b5f82ffbd39b7a9e87fd4594c/kl_intl_patents_bundle.css" type="text/css" /><script src="/books/javascript/atb_50a6672b5f82ffbd39b7a9e87fd4594c__zh_cn.js"></script><script>function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: "zh",gaTrack: true,gaId: "UA-27188110-1",multilanguagePage: true});}</script><script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><meta name="DC.type" content="Patent"><meta name="DC.title" content="动态加载和调用程序的方法及装置"><meta name="DC.contributor" content="荣涛" scheme="inventor"><meta name="DC.contributor" content="北京奇虎科技有限公司" scheme="assignee"><meta name="DC.contributor" content="奇智软件（北京）有限公司" scheme="assignee"><meta name="DC.date" content="2013-10-17" scheme="dateSubmitted"><meta name="DC.description" content="本发明公开了一种动态加载和调用程序的方法及装置。其中方法包括：由主系统发起对调用程序的调用请求；所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述调用程序将所述调用程序的实例赋值给所述被调用程序的实例；由所述调用程序发起对所述被调用程序的调用请求；由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法。利用本发明提供的方案，只需下载程序包即可加载和调用，简化了用户使用程序的方式。"><meta name="DC.date" content="2014-1-22"><meta name="DC.relation" content="CN:101924798:A" scheme="references"><meta name="DC.relation" content="US:8370824" scheme="references"><meta name="citation_reference" content="MINGLI198611: &quot;android如何动态的加载类----app插件技术&quot;, 《HTTP://BLOG.CSDN.NET/MINGLI198611/ARTICLE/DETAILS/8858076》, 27 April 2013 (2013-04-27), pages 1 - 6"><meta name="citation_reference" content="网友: &quot;Android透过反射启动未安装的APK中的Activity&quot;, 《我的异常网 HTTP://WWW.MYEXCEPTION.CN/ANDROID/1217391.HTML》, 20 February 2013 (2013-02-20), pages 1 - 7"><meta name="citation_patent_publication_number" content="CN:103530156:A"><meta name="citation_patent_application_number" content="CN:201310487438"><link rel="canonical" href="https://www.google.com/patents/CN103530156A?cl=zh"/><meta property="og:url" content="https://www.google.com/patents/CN103530156A?cl=zh"/><meta name="title" content="专利 CN103530156A - 动态加载和调用程序的方法及装置"/><meta name="description" content="本发明公开了一种动态加载和调用程序的方法及装置。其中方法包括：由主系统发起对调用程序的调用请求；所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述调用程序将所述调用程序的实例赋值给所述被调用程序的实例；由所述调用程序发起对所述被调用程序的调用请求；由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法。利用本发明提供的方案，只需下载程序包即可加载和调用，简化了用户使用程序的方式。"/><meta property="og:title" content="专利 CN103530156A - 动态加载和调用程序的方法及装置"/><meta property="og:type" content="book"/><meta property="og:site_name" content="Google Books"/><meta property="og:image" content="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><link rel="image_src" href="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><script>if (window['_OC_timingAction']) {window['_OC_timingAction']('patents_refpage');}</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}@media all{.gb1{height:22px;margin-right:.5em;vertical-align:top}#gbar{float:left}}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb4{color:#00c !important}.gbi .gb4{color:#dd8e27 !important}.gbf .gb4{color:#900 !important}

#gbar { padding:.3em .6em !important;}</style></head><body ><div id=gbar><nobr><a class=gb1 href="https://www.google.com/search?cl=zh&hl=zh-CN&sa=N&tab=tw">搜索</a> <a class=gb1 href="https://www.google.com/search?cl=zh&hl=zh-CN&tbm=isch&source=og&sa=N&tab=ti">图片</a> <a class=gb1 href="https://maps.google.com/maps?cl=zh&hl=zh-CN&sa=N&tab=tl">地图</a> <a class=gb1 href="https://play.google.com/?cl=zh&hl=zh-CN&sa=N&tab=t8">Play</a> <a class=gb1 href="https://www.youtube.com/results?cl=zh&hl=zh-CN&sa=N&tab=t1">YouTube</a> <a class=gb1 href="https://news.google.com/nwshp?hl=zh-CN&tab=tn">新闻</a> <a class=gb1 href="https://mail.google.com/mail/?tab=tm">Gmail</a> <a class=gb1 href="https://drive.google.com/?tab=to">云端硬盘</a> <a class=gb1 style="text-decoration:none" href="https://www.google.com/intl/zh-CN/options/"><u>更多</u> &raquo;</a></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a target=_top id=gb_70 href="https://www.google.com/accounts/Login?service=&continue=https://www.google.com/patents%3Fcl%3Dzh%26hl%3Dzh-CN&hl=zh-CN" class=gb4>登录</a></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div><div role="alert" style="position: absolute; left: 0; right: 0;"><a href="https://www.google.com/patents/CN103530156A?cl=zh&amp;hl=zh-CN&amp;output=html_text" title="屏幕阅读器用户请注意：点击此链接可进入无障碍模式。阅读器在无障碍模式下具有同样的基本功能，但可让用户获得更好的体验。"><img border="0" src="//www.google.com/images/cleardot.gif"alt="屏幕阅读器用户请注意：点击此链接可进入无障碍模式。阅读器在无障碍模式下具有同样的基本功能，但可让用户获得更好的体验。"></a></div><div class="kd-appbar"><h2 class="kd-appname"><a href="/patents?hl=zh-CN"> 专利</a></h2><div class="kd-buttonbar left" id="left-toolbar-buttons"><a id="appbar-write-review-link" href=""></a><a id="appbar-view-print-sample-link" href=""></a><a id="appbar-view-ebook-sample-link" href=""></a><a id="appbar-patents-prior-art-finder-link" href="https://www.google.com/patents/related/CN103530156A"></a><a id="appbar-patents-discuss-this-link" href="https://www.google.com/url?id=4TnuCAABERAJ&amp;q=http://patents.stackexchange.com/redirect/google-patents%3Fpublication%3DCN103530156A&amp;usg=AFQjCNHOYDTZVIkY0dRx5k71PLa7l4jTLg" data-is-grant="false"></a><a id="appbar-read-patent-link" href="//docs.google.com/viewer?url=patentimages.storage.googleapis.com/pdfs/fde23c479135539b0c9d/CN103530156A.pdf"></a><a id="appbar-download-pdf-link" href="//patentimages.storage.googleapis.com/pdfs/fde23c479135539b0c9d/CN103530156A.pdf"></a><a class="appbar-content-language-link" data-selected="true" data-label="中文" href="/patents/CN103530156A?cl=zh&amp;hl=zh-CN"></a><a class="appbar-content-language-link" data-label="英语" href="/patents/CN103530156A?cl=en&amp;hl=zh-CN"></a></div><div class="kd-buttonbar right" id="right-toolbar-buttons"></div></div><div id="books-microdata" itemscope=""itemtype="http://schema.org/Book"itemid="https://www.google.com/patents/CN103530156A?cl=zh" style="display:none"><span itemprop="description">本发明公开了一种动态加载和调用程序的方法及装置。其中方法包括：由主系统发起对调用程序的调用请求；所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述调用程序将所述调用程序的实例...</span><span itemprop="url">https://www.google.com/patents/CN103530156A?cl=zh&amp;utm_source=gb-gplus-share</span><span class="main-title" itemprop="name">专利 CN103530156A - 动态加载和调用程序的方法及装置</span><img itemprop="image" src="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"alt="专利 CN103530156A - 动态加载和调用程序的方法及装置" title="专利 CN103530156A - 动态加载和调用程序的方法及装置"></div><div style="display: none"><ol id="ofe-gear-menu-contents" class="gbmcc"><li class="gbe gbmtc"><a class="gbmt goog-menuitem-content" id="" href="https://www.google.com/advanced_patent_search?hl=zh-CN"> 高级专利搜索</a></li></ol></div><div id="volume-main"><div id="volume-center"><div class=vertical_module_list_row><div id=intl_patents class=about_content><div id=intl_patents_v><table class="patent-bibdata patent-drawings-missing"><tr><td class="patent-bibdata-heading"> 公开号</td><td class="single-patent-bibdata">CN103530156 A</td></tr><tr><td class="patent-bibdata-heading">发布类型</td><td class="single-patent-bibdata">申请</td></tr><tr><td class="patent-bibdata-heading"> 专利申请号</td><td class="single-patent-bibdata">CN 201310487438</td></tr><tr><td class="patent-bibdata-heading">公开日</td><td class="single-patent-bibdata">2014年1月22日</td></tr><tr><td class="patent-bibdata-heading"> 申请日期</td><td class="single-patent-bibdata">2013年10月17日</td></tr><tr><td class="patent-bibdata-heading"> 优先权日<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="优先日期属于假设性质，不具任何法律效力。Google 对于所列日期的正确性并没有进行法律分析，也不作任何陈述。"></span></td><td class="single-patent-bibdata">2013年10月17日</td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">公告号</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/WO2015055074A1?hl=zh-CN&amp;cl=zh">WO2015055074A1</a></span></span></td></tr><tr class="patent-bibdata-list-row alternate-patent-number"><td class="patent-bibdata-heading"> 公开号</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value">201310487438.2, </span><span class="patent-bibdata-value">CN 103530156 A, </span><span class="patent-bibdata-value">CN 103530156A, </span><span class="patent-bibdata-value">CN 201310487438, </span><span class="patent-bibdata-value">CN-A-103530156, </span><span class="patent-bibdata-value">CN103530156 A, </span><span class="patent-bibdata-value">CN103530156A, </span><span class="patent-bibdata-value">CN201310487438, </span><span class="patent-bibdata-value">CN201310487438.2</span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading"> 发明者</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22%E8%8D%A3%E6%B6%9B%22">荣涛</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading"> 申请人</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=inassignee:%22%E5%8C%97%E4%BA%AC%E5%A5%87%E8%99%8E%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8%22">北京奇虎科技有限公司</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=inassignee:%22%E5%A5%87%E6%99%BA%E8%BD%AF%E4%BB%B6%EF%BC%88%E5%8C%97%E4%BA%AC%EF%BC%89%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8%22">奇智软件（北京）有限公司</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">导出引文</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/CN103530156A.bibtex?cl=zh">BiBTeX</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN103530156A.enw?cl=zh">EndNote</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN103530156A.ris?cl=zh">RefMan</a></span></span></td></tr><tr class="patent-internal-links"><td colspan=2><span class="patent-bibdata-value"><a href="#backward-citations">专利引用</a> (2),</span> <span class="patent-bibdata-value"><a href="#npl-citations">非专利引用</a> (2),</span> <span class="patent-bibdata-value"><a href="#forward-citations"> 被以下专利引用</a> (1),</span> <span class="patent-bibdata-value"><a href="#classifications">分类</a> (2),</span> <span class="patent-bibdata-value"><a href="#legal-events">法律事件</a> (2)</span> </td></tr><tr><td colspan=2 class="patent-bibdata-external-link-spacer-top"></td></tr><tr class="patent-bibdata-external-link-spacer-bottom"></tr><tr><td colspan=2><span class="patent-bibdata-heading">外部链接:&nbsp;</span><span><span class="patent-bibdata-value"><a href="https://www.google.com/url?id=4TnuCAABERAJ&amp;q=http://211.157.104.87:8080/sipo/zljs/hyjs-yx-new.jsp%3Frecid%3D201310487438&amp;usg=AFQjCNGAOooxmvlIM-EXLLxEeh9kKQ4uSQ"> 中国国家知识产权局</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/url?id=4TnuCAABERAJ&amp;q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DCN%26NR%3D103530156A%26KC%3DA%26FT%3DD&amp;usg=AFQjCNGcrgQz1ib2oAUeCyk8mCKrcBsEFg"> 欧洲专利数据库 (Espacenet)</a></span></span></td></tr><tr class="patent-bibdata-group-spacer"></tr></table><div class="number-and-title"><span class="patent-title"><invention-title mxw-id="PT132975904" lang="ZH" load-source="patent-office">动态加载和调用程序的方法及装置</invention-title>
      </span><br><span class="patent-number">CN 103530156 A</span></div><div class="patent-section patent-abstract-section"><div class="patent-section-header"><span class="patent-section-title"> 摘要</span></div><div class="patent-text"><abstract mxw-id="PA129471949" lang="ZH" load-source="patent-office">
    <div class="abstract">本发明公开了一种动态加载和调用程序的方法及装置。其中方法包括：由主系统发起对调用程序的调用请求；所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述调用程序将所述调用程序的实例赋值给所述被调用程序的实例；由所述调用程序发起对所述被调用程序的调用请求；由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法。利用本发明提供的方案，只需下载程序包即可加载和调用，简化了用户使用程序的方式。</div>
  </abstract>
  </div></div><div class="patent-section patent-claims-section"><div class="patent-section-header"><span class="patent-section-title">权利要求<span class="patent-section-count">(10)</span></span></div><div class="patent-text"><div mxw-id="PCLM58590324" lang="ZH" load-source="patent-office" class="claims">
    <div class="claim"> <div num="1" class="claim">
      <div class="claim-text">1.一种动态加载和调用程序的方法，其包括:  由主系统发起对调用程序的调用请求；  所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；  所述调用程序将所述调用程序的实例赋值给所述被调用程序的实例；  由所述调用程序发起对所述被调用程序的调用请求；  由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="2" class="claim">
      <div class="claim-text">2.根据权利要求1所述的方法，其中，所述调用程序为已安装的用于调用插件的应用，所述被调用程序为未安装的APK插件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="3" class="claim">
      <div class="claim-text">3.根据权利要求1或2所述的方法，其中，所述调用程序通过判断所述调用程序的实例不为空来确定成功加载所述被调用程序。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="4" class="claim">
      <div class="claim-text">4.根据权利要求3所述的方法，其中，所述被调用程序通过判断所述被调用程序的实例不为空来确定所述被调用程序以插件的形式被调用。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="5" class="claim">
      <div class="claim-text">5.根据权利要求1-4任一项所述的方法，其中，所述由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法进一步包括:  由主系统根据程序的生命周期或者调用程序自身调用所述调用程序中的资源加载方法，加载所述调用程序或所述被调用程序的资源；  由所述调用程序根据程`序的生命周期调用所述被调用程序中的资源加载方法，加载所述被调用程序的资源。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="6" class="claim">
      <div class="claim-text">6.根据权利要求1-4任一项所述的方法，其中，所述由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法进一步包括:  由主系统通过所述调用程序反射调用所述被调用程序中的组件和服务对应的方法；由主系统调用所述调用程序中的除了上述组件和服务以外的其他组件和服务对应的方法；  由所述调用程序调用所述调用程序和所述被调用程序中均不存在的组件和服务对应的方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="7" class="claim">
      <div class="claim-text">7.根据权利要求1-6任一项所述的方法，其中，在所述调用程序加载被调用程序生成相关句柄及文件之前进一步包括:对所述被调用程序进行合法性鉴权。</div>
    </div>
    </div> <div class="claim"> <div num="8" class="claim">
      <div class="claim-text">8.一种动态加载和调用程序的装置，其包括:主系统、调用程序运行模块以及被调用程序运行模块；其中，所述主系统包括:第一调用请求发起单元和第一调用单元；所述调用程序运行模块包括:加载单元、赋值单元、第二调用请求发起单元以及第二调用单元；  所述第一调用请求发起单元适于发起对调用程序的调用请求；  所述加载单元适于加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；  所述赋值单元适于将所述调用程序的实例赋值给所述被调用程序的实例；  所述第二调用请求发起单元适于发起对所述被调用程序的调用请求；  所述第一调用单元适于根据程序的生命周期调用所述调用程序对应的方法；所述第二调用单元适于根据程序的生命周期调用所述被调用程序对应的方法。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="9" class="claim">
      <div class="claim-text">9.根据权利要求8所述的装置，其中，所述调用程序运行模块为已安装的用于调用插件的应用，所述被调用程序运行模块为未安装的APK插件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="10" class="claim">
      <div class="claim-text">10.根据权利要求8或9所述的装置，其中，所述调用程序运行模块适于通过判断所述调用程序的实例不为空来确`定成功加载所述被调用程序。</div>
    </div>
  </div> </div>
  </div></div><div class="patent-section patent-description-section"><div class="patent-section-header"><span class="patent-section-title"> 说明</span></div><div class="patent-text"><div mxw-id="PDES64977886" lang="ZH" load-source="patent-office" class="description">
    <p>动态加载和调用程序的方法及装置</p>
    <p>技术领域</p>
    <p>[0001]	本发明涉及插件处理技术领域，具体涉及一种动态加载和调用程序的方法及装置。</p>
    <p>背景技术</p>
    <p>[0002]	类加载器(class loader)是Java&#8482;中的一个很重要的概念。类加载器负责加载Java类的字节代码到Java虚拟机(Virtual Machine)中。同时,类加载器是Java语言的一个创新，也是Java语言流行的重要原因之一。它使得Java类可以被动态加载到Java虚拟机中并执行。类加载器从JDK1.0就出现了，最初是为了满足在Web容器和OSGI中得到了广泛的使用。</p>
    <p>[0003]	Java虚拟机使用Java类的方式如下:Java源程序(.java文件)在经过Java编译器编译之后被转换成Java字节代码(.class文件)。类加载器负责读取Java字节代码，并转换成java.lang.Class类的一个实例。每个这样的实例用来表示一个Java类。通过此实例的newlnstance()方法就可以创建出该类的一个对象。</p>
    <p>[0004]	Java中的类加载器大致分为两类，一类是系统提供的，另一类是由Java应用开发人员编写的。系统提供的类加载器主要有下面三个:</p>
    <p>[0005]	&#9830;引导加载器(Bootstrap class loader):用来加载Java核心库,它是由原生代码来实现的，并不继承于Java.lang.ClassLoader0</p>
    <p>[0006]	&#9830;扩展加载器(Extensions class loader):用来加载 Java 扩展库。Java VM 的实现会提供一个扩展库目录。该类加载器在此目录中查找并加载相关的Java类。</p>
    <p>[0007]	&#9830;系统加载器(System class loader):根据设定的环境变量来加载Java类。Java应用的类都是由它完成加载的。</p>
    <p>[0008]	除了系统提供的类加载器以外，开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足特殊的需求。</p>
    <p>[0009]	以在智能手机的安卓(Android)平台上加载APK (Android Package)格式的程序包为例。在加载APK之前，系统必须先安装APK，具体安装过程包括:首先要把该APK下载到本地，然后调用系统安装程序，用户逐步确认后系统复制该APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik_cache目录下,并在data/data目录下创建对应的应用数据目录。上述安装APK的步骤繁琐复杂，用户需要反复点击和确认后才能实现APK的加载，不利于APK的推广。</p>
    <p>发明内容</p>
    <p>[0010]鉴于上述问题，提出了本发明以便提供一种克服上述问题或者至少部分地解决上述问题的动态加载和调用程序的方法和相应的动态加载和调用程序的装置。</p>
    <p>[0011]	根据本发明的一个方面，提供了一种动态加载和调用程序的方法，其包括:由主系统发起对调用程序的调用请求；所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述调用程序将所述调用程序的实例赋值给所述被调用程序的实例；由所述调用程序发起对所述被调用程序的调用请求；由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法。</p>
    <p>[0012]	根据本发明的另一方面，提供了一种动态加载和调用程序的装置，其包括:主系统、调用程序运行模块以及被调用程序运行模块；其中，所述主系统包括:第一调用请求发起单元和第一调用单元；所述调用程序运行模块包括:加载单元、赋值单元、第二调用请求发起单元以及第二调用单元；</p>
    <p>[0013]	所述第一调用请求发起单元适于发起对调用程序的调用请求；所述加载单元适于加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述赋值单元适于将所述调用程序的实例赋值给所述被调用程序的实例；所述第二调用请求发起单元适于发起对所述被调用程序的调用请求；所述第一调用单元适于根据程序的生命周期调用所述调用程序对应的方法；所述第二调用单元适于根据程序的生命周期调用所述被调用程序对应的方法。</p>
    <p>[0014]	根据本发明提供的动态加载和调用程序的方法及装置，主系统利用调用程序作为媒介实现对被调用程序的加载和调用，具体地，在主系统发起对调用程序的调用请求之后，调用程序加载被调用程序；在加载过程中，将调用程序的实例赋值给被调用程序的实例；之后调用程序能够发起对被调用程序的调用请求；进而通过主系统调用调用程序对应的方法，调用程序调用被调用程序对应的方法，实现了被调用程序的加载和调用。利用本发明提供的方案，跳过上述繁琐复杂的安装步骤，只需下载程序包即可加载和调用。</p>
    <p>[0015]	上述说明仅是本发明技术方案的概述，为了能够更清楚了解本发明的技术手段，而可依照说明书的内容予以实施，并且为了让本发明的上述和其它目的、特征和优点能够更明显易懂，以下特举本发明的具体实施方式。</p>
    <p>附图说明</p>
    <p>[0016]	通过阅读下文优选实施方式的详细描述，各种其他的优点和益处对于本领域普通技术人员将变得清楚明了。附图仅用于示出优选实施方式的目的，而并不认为是对本发明的限制。而且在整个附图中，用相同的参考符号表示相同的部件。在附图中:</p>
    <p>[0017]	图1示出了根据本发明一个实施例的动态加载和调用程序的方法的流程图；</p>
    <p>[0018]	图2示出了本发明实施例一个应用场景的方法流程图；</p>
    <p>[0019]	图3示出了本发明实施例的调用程序的抽象父类的定义示意图；</p>
    <p>[0020]	图4示出了本发明实施例的APK包(插件)的抽象父类的定义示意图；</p>
    <p>[0021]	图5示出了本发明实施例中调用程序以插件形式调用APK包的生命周期时序图；</p>
    <p>[0022]	图6示出了本发明实施例中调用程序以插件形式调用APK资源加载时序图；</p>
    <p>[0023]	图7示出了根据本发明一个实施例的动态加载和调用程序的装置的结构框图。</p>
    <p>具体实施方式</p>
    <p>[0024]	下面将参照附图更详细地描述本公开的示例性实施例。虽然附图中显示了本公开的示例性实施例，然而应当理解，可以以各种形式实现本公开而不应被这里阐述的实施例所限制。相反，提供这些实施例是为了能够更透彻地理解本公开，并且能够将本公开的范围完整的传达给本领域的技术人员。</p>
    <p>[0025]	为了解决现有技术中在加载和调用程序包之前必须先安装程序包的技术问题，本发明提供了一种动态加载和调用程序的方法，跳过上述繁琐复杂的安装步骤，通过相应的机制只需下载程序包即可加载和调用。图1示出了根据本发明一个实施例的动态加载和调用程序的方法的流程图。如图1所示，本实施例包括如下步骤:</p>
    <p>[0026]	步骤S101，由主系统发起对调用程序的调用请求。</p>
    <p>[0027]	其中，主系统指的是系统平台，例如手机平台；调用程序可以为已安装的用于调用插件的应用，例如手机卫士等软件都可以作为调用程序。由于调用程序为已安装的应用，所以在主系统的Manifest, xml中已经注册过，因此主系统可以先发起对调用程序的调用请求。</p>
    <p>[0028]	步骤S102，调用程序加载被调用程序生成相关句柄及文件，并得到调用程序的实例。</p>
    <p>[0029]	调用程序使用Java中的类加载器加载被调用程序，在加载过程中会在相应的目录下生成句柄及文件，并得到加载后的对象以及调用程序的实例。</p>
    <p>[0030]	步骤S103，调用程序将调用程序的实例赋值给被调用程序的实例。</p>
    <p>[0031]	调用程序将上述调用程序的实例赋值给被调用程序的实例，以调用者的实例作为被调用者的实例。</p>
    <p>[0032]	步骤S104，由调用程序发起对被调用程序的调用请求。</p>
    <p>[0033]	在将调用程序的实例赋值给被调用程序的实例之后，调用程序通过invoke方法发起对被调用程序的调用请求。</p>
    <p>[0034]	步骤S105，由主系统根据程序的生命周期调用调用程序对应的方法，由调用程序根据程序的生命周期调用被调用程序对应的方法。</p>
    <p>[0035]	根据本实施例提供的动态加载和调用程序的方法，主系统利用调用程序作为媒介实现对被调用程序的加载和调用，具体地，在主系统发起对调用程序的调用请求之后，调用程序加载被调用程序；在加载过程中，将调用程序的实例赋值给被调用程序的实例；之后调用程序能够发起对被调用程序的调用请求；进而通过主系统调用调用程序对应的方法，调用程序调用被调用程序对应的方法，实现了被调用程序的加载和调用。利用本实施例提供的方法，跳过上述繁琐复杂的安装步骤，只需下载程序包即可加载和调用。</p>
    <p>[0036]	下面以本发明提供的方法应用于智能手机的安卓平台上加载和调用APK程序包的场景为例，进一步的详述本发明的技术方案。在以下实施例中，被调用程序为未安装的APK包，也可称为APK插件。</p>
    <p>[0037]	图2示出了本发明实施例一个应用场景的方法流程图。该应用场景是在Android平台上通过对系统运行过程的模拟和优化，实现动态加载APK包及其所有逻辑和资源，动态调用该APK包中的组件(Activity)和服务(Services)等,如此便可实现Android平台的插件化编程。</p>
    <p>[0038]	如图2所示，该方法包括步骤:</p>
    <p>[0039]	步骤S201，启动软件，该软件为用于调用插件的调用程序，例如手机卫士等软件。</p>
    <p>[0040]	步骤S202，收集Android系统平台的信息，包括Android的版本、终端厂商信息、终端型号等。</p>
    <p>[0041]	由于Android系统的开放性，各家终端厂商所使用的系统基本都经过了 二次开发，使得市场上的Android终端比较繁杂，收集这些信息的意义在于能够准确地获取与其适配的APK包。</p>
    <p>[0042]	步骤S203，在收集完相关信息后，将这些信息传至云端服务器，由云端服务器返回适配结果。</p>
    <p>[0043]	这样做的目的是为了使适配规则更加准确、灵活。在云端服务器返回的适配结果集里面会包含APK包的URL地址。</p>
    <p>[0044]	步骤S204，根据APK包的URL地址下载APK包。</p>
    <p>[0045]	步骤S205，对下载得到的APK包进行合法性鉴权。</p>
    <p>[0046]	为了避免APK包被非法篡改，或者在网络传输过程中数据出错，需要对APK包进行合法性鉴权。具体步骤包括:提取APK包的包信息(PackageInfo);根据PackageInfo获取签名(Signature)对象；取得Signature的MD5值；比较其MD5值与合法签名是否一致，如一致，则鉴权通过，继续下面步骤；如不一致，则鉴权错误，返回错误信息，停止加载。</p>
    <p>[0047]	步骤S206，动态加载和调用APK包。</p>
    <p>[0048]	为了方便调用APK包提供的功能，规避过多的使用反射机制，本发明将调用APK包提供的功能抽象为两个抽象父类。其中调用程序的抽象父类为CallPluginActivity,APK 包的抽象父类为 PluginActivity。CallPluginActivity 和 PluginActivity 均为抽象类，需要子类实现其相应的方法，因此本文后续描述的CallPluginActivity均也代表CallPluginActivity 的实现类,PluginActivity 均也代表 PluginActivity 的实现类，后面将不再赘述。</p>
    <p>[0049]	本实施例中，调用程序为已经安装的用于调用插件的应用。APK包(插件)为已经下载，可以作为插件调用，也可以和普通APK &#8212;样正常安装的Android应用。</p>
    <p>[0050]	调用程序的抽象父类CallPluginActivity主要是为了向APK包(插件)中的PluginActivity提供实例，即上下文Context,并完成APK包的合法性鉴权和通过反射机制加载APK包(插件)。在本发明实施例的一个例子中，调用程序的抽象父类的定义如图</p>
    <p>3所示。其中，onCreateO方法由Android系统调用，用于发起对调用程序的调用请求。checkApkO方法用于对APK包进行合法性鉴权。LoadAPKO方法用于判断是否需要加载APK并生成DexClassLoader和PackageInfo等句柄及文件，并通过反射方法得到对应的PluginActivity 实例(变量名为:pluginActivity)。getOtherResources O 方法用于通过反射方法加载APK包的资源并生成Resources句柄(变量名为:pluginRes)。为了实现对应的功能，需要在子类中重写父类定义的如下方法:</p>
    <p>[0051]	重写以下方法替换当前CallPluginActivity的资源、样式为APK包中的资源、样式:</p>
    <p>[0052]</p>
    <p>@Override</p>
    <p>[0053]</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00081.png"> <img id="idf0001" file="CN103530156AD00081.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00081.png" class="patent-full-image" alt="Figure CN103530156AD00081"> </a> </div>
    <p>[0054]	//判断pluginActivity及pluginRes是否成功加载，若成功加载返回APK包的Resources资源；否则以系统默认方式加载Resources资源；</p>
    <p>[0055]	# +getResources O: Resources// 返回一个资源句柄(android, content, res.Resources)</p>
    <p>[0056]	# +getTheme (): Theme// 返回一个样式句柄(android, content.res.Resources.Theme)</p>
    <p>[0057]	# +getAssets():AssetManager// 返回一个样式句柄(android, content, res.AssetManager)</p>
    <p>[0058]	本文中代码后的内容是代码的注释内容。</p>
    <p>[0059]	重写以下方法便于反射调用APK包(插件)中的PluginActivity、PluginService等组件:</p>
    <p>[0060].+startActivity (Intent): void// 启动一个 Activity，当 Activity 关闭时，不返回任何信息</p>
    <p>[0061]	# +startActivityForResult(Intent, int):void// 启动一个 Activity，当Activity关闭时，会有一个返回值</p>
    <p>[0062]	# +onActivityResult (int, int, Intent): void// 当以 startActivityForResult函数启动的Activity完成时，会有一个Intent作为返回值</p>
    <p>[0063]	# +startService (Intent): void// 启动一个服务(android, app.Service)</p>
    <p>[0064]	重写以下方法使APK包(插件)中的PluginActivity的生命周期与调用程序CallPluginActivity的生命周期一致，如onStart、onResume方法，其他方法以此类推。</p>
    <p>[0065]	重写父类onResume方法，调用invoke方法。</p>
    <p>[0066]</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00091.png"> <img id="idf0002" file="CN103530156AD00091.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00091.png" class="patent-full-image" alt="Figure CN103530156AD00091"> </a> </div>
    <p>[0067]	//invokeMethod方法:根据方法名称参数(String methodName)通过反射方式调用pluginActivity中对应的名称的方法</p>
    <p>[0068]	z+onRestoreInstanceState (Bundle): void// 当 Activity 之前被销毁再被重建时，可以从Bundle参数中恢复保存的状态</p>
    <p>[0069]	z+onStart (): void</p>
    <p>[0070]	z+onRestart (): void//当Activity从停止状态返回到前台时，收到一个onRestart O的调用，系统还会调用onStart O方法,该方法在Activity变得可见时都会发生(不管是被重启还是第一次被创建)</p>
    <p>[0071]	z+onResume O: void//每次Activity进入前台时,系统都会调用该方法,包括第一次创建时</p>
    <p>[0072]	z+onSaveInstanceState (Bundle): void// 当 Activity 要停止时，系统调用该方法，Activity可以用一个键-值对集合保存状态信息</p>
    <p>[0073]	z+onPause (): void//当系统调用onPause O时，在技术上意味着Activity仍是部分可见的，而其他情况下意味着用户正在离开Activity，并且将到达关闭(Stopped)状态[0074]	z+onStop (): void// 当 Activity 收到 onStop O 方法的调用时，该 Activity 将不再可见，并且释放不需要的资源</p>
    <p>[0075]	z+onDestroy O: void//Activity 的第一个生命周期回调函数是 onCreate O，而它的最后一个回调函数是onDestooyO ;系统调用该方法作为一个最终信号，表明Activity实例将要被完全从系统内存中清除</p>
    <p>[0076]	APK包(插件)的抽象父类的主要功能是完成APK包(插件)的构建和提供符合Android标准的Activity和Service等。在本发明实施例的一个例子中，APK包(插件)的抽象父类的定义如图4所示。其中，onCreateO方法由调用程序调用，用于发起对APK包(插件)的调用请求。setCallActivity O由调用程序反射调用并设置自身的实例(pluginActivity)为APK包(插件)的实例(baseActivity)。具体实现方法如下:</p>
    <p>[0077]</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00101.png"> <img id="idf0003" file="CN103530156AD00101.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00101.png" class="patent-full-image" alt="Figure CN103530156AD00101"> </a> </div>
    <p>[0078]	}//由调用程序反射调用并设置自身实例为被调用程序的baseActivity变量</p>
    <p>[0079]	为了实现APK包(插件)子类对应的功能，需要在子类中重写父类定义的如下方法。</p>
    <p>[0080]	重写以下方法使APK包(插件)中的PluginActivity的生命周期受调用程序CallPluginActivity的生命周期控制,如:onStart、onResume方法,其他方法以此类推；以baseActivity变量是否为空来判断PluginActivity是由调用程序以插件形式启动,还是以Android正常启动(非插件调用的方式):</p>
    <p>[0081]</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00102.png"> <img id="idf0004" file="CN103530156AD00102.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00102.png" class="patent-full-image" alt="Figure CN103530156AD00102"> </a> </div>
    <p>[0082]	Η判断baseActivity是否为空，若不为空则是插件形式调用；否则为调用系统默认方法</p>
    <p>[0083]	+onCreate (Bundle): void</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00111.png"> <img id="idf0005" file="CN103530156AD00111.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00111.png" class="patent-full-image" alt="Figure CN103530156AD00111"> </a> </div>
    <p>[0092]	关于以上 方法的注释参见前文的描述。其中，在onCreateO方法里，可以执行基本的应用程序启动逻辑(这些逻辑只在Activity的整个生命活动中发生一次)。</p>
    <p>[0093]	以baseActivity变量是否为空来判断PluginActivity是否由调用程序以插件形式调用，如果是插件形式，则调用baseActivity对应方法，正常启动的话调用其父类对应</p>
    <p>方法，其他方法以此类推:</p>
    <p>[0094]</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00112.png"> <img id="idf0006" file="CN103530156AD00112.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00112.png" class="patent-full-image" alt="Figure CN103530156AD00112"> </a> </div>
    <p>[0096]	Η判断baseActivity是否为空，若不为空则加载调用程序资源，否则调用加载资源</p>
    <div class="patent-image small-patent-image"> <a href="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00113.png"> <img id="idf0007" file="CN103530156AD00113.tif" img-content="drawing" img-format="tif" src="//patentimages.storage.googleapis.com/CN103530156A/CN103530156AD00113.png" class="patent-full-image" alt="Figure CN103530156AD00113"> </a> </div>
    <p>[0104]	关于以上方法的注释参见前文的描述。</p>
    <p>[0105]	总而言之，调用程序与APK包(插件)之间调用的总策略为:</p>
    <p>[0106]	V CallPluginActivity通过判断pluginActivity是否为空来确定是否成功加载APK包(插件)及其资源；如果判断出pluginActivity不为空，则确定成功加载APK包(插件)及其资源，并实例化对应的Activity。</p>
    <p>[0107]	PluginActivity通过判断baseActivity是否为空来确定本Activity是否由调用程序以插件的形式调用；如果判断出baseActivity不为空，则确定本Act ivity是由调用程序以插件的形式调用。</p>
    <p>[0108]	图5示出了本发明实施例中调用程序以插件形式调用APK包的生命周期时序图。如图5所示，主要包括如下步骤:</p>
    <p>[0109]步骤	S501，由 Android 系统调用 CallPluginActivity 的 onCreateO 方法，即Android系统发起对CallPluginActivity的调用请求。</p>
    <p>[0110]步骤	S502，CallPluginActivity 执行 checkApkO 方法，对 APK 包(插件)进行合法性鉴权。有关合法性鉴权的具体步骤可参见上述实施例的描述。</p>
    <p>[0111]	步骤S503，CallPluginActivity执行LoadAPKO方法判断是否需要加载APK包(插件)并生成DexClassLoader和PackageInfo等句柄及文件，并通过反射方法得到对应的PluginActivity 实例(变量名为:pluginActivity)。</p>
    <p>[0112]步骤	S504，CallPluginActivity 反射调用 PluginActivity 的 setCallActivity方法，设置自身实例到PluginActivity中(变量名为:baseActivity)，利用CallPluginActivity 自身的上下文 Context 充当 PluginActivity 的上下文 Context。</p>
    <p>[0113]步骤	S505，CallPluginActivity 通过 invoke 方法反射调用 PluginActivity 的onCreate O 方法，即 CallPluginActivity 发起对 PluginActivity 的调用请求。</p>
    <p>[0114]步骤	S506，由 Android 系统根据 Activity 生命周期调用 CallPluginActivity 对应的方法，方法如下:</p>
    <p>[0115]	+onRestorelnstanceState (Bundle): void</p>
    <p>[0116]	+onStart (): void</p>
    <p>[0117]	+onRestart O: void</p>
    <p>[0118]	+onResume (): void</p>
    <p>[0119]	+onSavelnstanceState(Bundle): void</p>
    <p>[0120]	+onPause (): void</p>
    <p>[0121]	+onStop (): void</p>
    <p>[0122]	+onDestroyO:void</p>
    <p>[0123]	关于以上方法的注释参见前文的描述。</p>
    <p>[0124]	步骤S507，由CallPluginActivity根据Activity生命周期通过invoke方法反射调用PluginActivity对应的方法，方法同步骤S506。</p>
    <p>[0125]	图6示出了本发明实施例中调用程序以插件形式调用APK资源加载时序图。如图6所示，主要包括如下步骤:</p>
    <p>[0126]	步骤S601，由主系统根据程序的生命周期或者调用程序自身调用调用程序中的资源加载方法，加载调用程序或被调用程序的资源。具体地，由Android系统根据Activity生命周期或者 CallPluginActivity 自身调用 getResources、getTheme、getAssets 等资源加载方法，加载调用程序或APK包(插件)资源。</p>
    <p>[0127]	步骤S602，由调用程序根据程序的生命周期调用被调用程序中的资源加载方法，加载被调用程序的资源。具体地，由CallPluginActivity根据Activity生命周期通过invoke 方法反射调用 PluginActivity 的 getResources、getTheme、getAssets 等资源加载方法，加载APK包(插件)资源。[0128]	另外,调用程序还可以以插件形式调用APK包(插件)内部PluginActivity,其时序主要包括:</p>
    <p>[0129]首先，由主系统通过调用程序反射调用被调用程序中的组件和服务对应的方法。具体地，由Android系统通过CallPluginActivity反射调用APK包(插件)中的Activity 和 Service 对应的方法,常用方法有:startActivity&gt;startActivityForResult&gt;startService、onActivityResult 等。</p>
    <p>[0130]	然后，由主系统调用调用程序中的除了上述组件和服务以外的其他组件和服务对应的方法。具体地，由Android系统直接调用CallPluginActivity中的除了 APK包(插件)中的Activity和Service以外的其他Activity和Service对应的方法,常用方法与上个步骤相同。</p>
    <p>[0131]	最后，由调用程序调用调用程序和被调用程序中均不存在的组件和服务对应的方法。具体地，由CallPluginActivity调用调用程序和APK包(插件)中均不存在的Activity和Service对应的方法，常用方法与上个步骤相同。</p>
    <p>[0132]	另外，本发明实施例还提供了如下常用事件监听接口，该接口主要用于Android的系统事件的传递，例如电量、信号、网络监听等。</p>
    <p>[0133]	〈action android:name="android, net.conn.CONNECTIVITY_CHANGE</p>
    <p>[0134]	//监听网络连接状态变化的接口</p>
    <p>[0135]	〈action androidIname=^android.1ntent, action.BATTERY_CHANGEDV&gt;</p>
    <p>[0136]	//监听充电状态或者电池电量变化的接口</p>
    <p>[0137]	〈action android:name=〃android, intent, action.SCREEN_0FF〃/&gt;</p>
    <p>[0138]	//监听屏幕被关闭的接口</p>
    <p>[0139]	〈action android:name=〃android, intent, action.SCREEN_0N〃/&gt;</p>
    <p>[0140]	Η监听屏幕被打开的接口</p>
    <p>[0141]	〈action android:name=〃android.1ntent, action.SIG_STR〃/&gt;</p>
    <p>[0142]	Η监听电话的信号强度变化的接口</p>
    <p>[0143]	〈action android:name=〃android, intent, action.SERVICE_STATE〃/&gt;</p>
    <p>[0144]	Η监听电话服务的状态变化的接口</p>
    <p>[0145]	根据上述实施例提供的方法，实现了在Android平台上动态加载和调用APK包(插件)及其所有逻辑和资源，动态调用该APK中的Activity和Service,进而实现了 Android平台的插件化编程。与现有的动态加载jar包的方案相比，本发明至少具有优点:</p>
    <p>[0146]	1.将jar文件改为APK文件，简化了签名流程；</p>
    <p>[0147]	2.Activity的生命周期由调用程序负责；</p>
    <p>[0148]	3.通过本发明提供的方法可以调用APK中的Activity的所有布局、图片、样式等资源文件，以及该Activity的自身的所有逻辑；</p>
    <p>[0149]	4.本发明跳过了繁琐复杂的安装步骤，无需安装只需下载APK即可完成加载和调用；</p>
    <p>[0150]	5.本发明中，APK即是插件又是独立的APK，可以单独安装使用，提升了便利性；</p>
    <p>[0151]	6.通常情况下，Android程序为了兼容大多数系统版本，如:Android2.2、Android4.0.3、Android4.1、Android4.2 等，一般都会使用较低版本的 SDK,如:SDK ApiLevel8即Android2.2,这样的程序在Android4.XX系统中不能充分发挥高版本Android系统的特性，而本发明提供的动态加载APK包(插件)的方法可以根据Android系统版本加载相应的插件，充分发挥系统特性。</p>
    <p>[0152]	图7示出了根据本发明一个实施例的动态加载和调用程序的装置的结构框图。如图7所示，该装置包括:主系统700、调用程序运行模块710以及被调用程序运行模块720。其中，主系统700包括第一调用请求发起单元701和第一调用单元702 ;调用程序运行模块710包括:加载单元711、赋值单元712、第二调用请求发起单元713以及第二调用单元714。主系统700指的是系统平台，例如手机平台；调用程序运行模块710可以为已安装的用于调用插件的应用，例如手机卫士等软件；被调用程序运行模块720可以为未安装的APK插件。</p>
    <p>[0153]	第一调用请求发起单元701适于发起对调用程序的调用请求。由于调用程序在主系统的Manifest, xml中已经注册过，因此主系统可以先发起对调用程序的调用请求。</p>
    <p>[0154]	加载单元711适于加载被调用程序生成相关句柄及文件，并得到调用程序的实例。</p>
    <p>[0155]	赋值单元712适于将调用程序的实例赋值给被调用程序的实例。</p>
    <p>[0156]	第二调用请求发起单元713适于发起对被调用程序的调用请求。</p>
    <p>[0157]	第一调用单元702适于根据程序的生命周期调用调用程序对应的方法</p>
    <p>[0158]	第二调用单元714适于根据程序的生命周期调用被调用程序对应的方法。</p>
    <p>[0159]	可选地，调用程序运行模块710还包括:鉴权单元715，适于对被调用程序进行合法性鉴权。</p>
    <p>[0160]	在上述Android系统平台上动态加载和调用APK包(插件)的应用场景中，主系统700为Android系统，第一调用请求发起单元701通过调用CallPluginActivity的onCreate ()方法发起对CallPluginActivity的调用请求。鉴权单元715执行checkApkO方法，对APK包(插件)进行合法性鉴权。加载单元711执行LoadAPKO方法判断是否需要加载APK包(插件)并生成DexClassLoader和PackageInfo等句柄及文件，并通过反射方法得到对应的PluginActivity实例(变量名为:pluginActivity)。赋值单元712反射调用PluginActivity 的 setCallActivity 方法,设置自身实例到PluginActivity 中(变量名为:baseActivity),利用 CallPluginActivity 自身的上下文 Context 充当 PluginActivity 的上下文Context。第二调用请求发起单元713通过反射调用PluginActivity的onCreate O方法发起对被调用程序的调用请求。第一调用单元702根据Activity生命周期调用CallPluginActivity对应的方法；第二调用单元714根据Activity生命周期通过invoke方法反射调用PluginActivity对应的方法。</p>
    <p>[0161]	其中，调用程序运行模块710适于通过判断调用程序的实例不为空来确定成功加载被调用程序。被调用程序运行模块720适于通过判断被调用程序的实例不为空来确定被调用程序以插件的形式被调用。</p>
    <p>[0162]	为了能够使调用程序以插件形式调用APK资源，第一调用单元702进一步适于根据程序的生命周期调用调用程序中的资源加载方法，加载调用程序或被调用程序的资源。具体地，第一调用单元702根据Activity生命周期调用getResources、getTheme、getAssets等资源加载方法，加载调用程序或APK包(插件)资源。第二调用单元714进一步适于根据程序的生命周期调用被调用程序中的资源加载方法，加载被调用程序的资源。具体地，第二调用单元714根据Activity生命周期通过invoke方法反射调用PluginActivity 的 getResources、getTheme、getAssets 等资源加载方法，加载 APK 包(插件)资源。</p>
    <p>[0163]	为了能够使调用程序以插件形式调用APK包(插件)内部PluginActivity,第一调用单元702进一步适于:通过第二调用单元714反射调用被调用程序中的组件和服务对应的方法；以及调用调用程序中的除了上述组件和服务以外的其他组件和服务对应的方法。具体地，第一调用单元702通过第二调用单元714反射调用APK包(插件)中的Activity 和 Service 对应的方法,常用方法有:startActivity&gt;startActivityForResult&gt;startService、onActivityResult 等。第一调用单兀 702 直接调用 CallPluginActivity中的除了 APK包(插件)中的Activity和Service以外的其他Activity和Service对应的方法，常用方法与上述相同。第二调用单元714进一步适于调用调用程序和被调用程序中均不存在的组件和服务对应的方法。具体地，第二调用单元714调用调用程序和APK包(插件)中均不存在的Activity和Service对应的方法,常用方法与上述相同。</p>
    <p>[0164]	根据本实施例提供的动态加载和调用程序的装置，主系统利用调用程序作为媒介实现对被调用程序的加载和调用，具体地，在第一调用请求发起单元发起对调用程序的调用请求之后，加载单元加载被调用程序；在加载过程中，赋值单元将调用程序的实例赋值给被调用程序的实例；之后第二调用请求发起单元发起对被调用程序的调用请求；通过第一调用单元调用调用程序对应的方法，第二调用单元调用被调用程序对应的方法，实现了被调用程序的加载和调用。利用本实施例提供的装置，在加载和调用程序时跳过上述繁琐复杂的安装步骤，只需下载程序包即可实现加载和调用。</p>
    <p>[0165]	在Android系统平台上动态加载和调用APK包(插件)的应用场景中，通过本发明提供的装置可以调用APK中的Activity的所有布局、图片、样式等资源文件，以及该Activity的自身的所有逻辑；APK即是插件又是独立的APK，可以单独安装使用，提升了便利性；本发明提供的动态加载APK包(插件)的装置可以根据Android系统版本加载相应的插件，充分发挥系统特性。</p>
    <p>[0166]	在此提供的算法和显示不与任何特定计算机、虚拟系统或者其它设备固有相关。各种通用系统也可以与基于在此的示教一起使用。根据上面的描述，构造这类系统所要求的结构是显而易见的。此外，本发明也不针对任何特定编程语言。应当明白，可以利用各种编程语言实现在此描述的本发明的内容，并且上面对特定语言所做的描述是为了披露本发明的最佳实施方式。</p>
    <p>[0167]	在此处所提供的说明书中，说明了大量具体细节。然而，能够理解，本发明的实施例可以在没有这些具体细节的情况下实践。在一些实例中，并未详细示出公知的方法、结构和技术，以便不模糊对本说明书的理解。</p>
    <p>[0168]	类似地，应当理解，为了精简本公开并帮助理解各个发明方面中的一个或多个，在上面对本发明的示例性实施例的描述中，本发明的各个特征有时被一起分组到单个实施例、图、或者对其的描述中。然而，并不应将该公开的方法解释成反映如下意图:即所要求保护的本发明要求比在每个权利要求中所明确记载的特征更多的特征。更确切地说，如下面的权利要求书所反映的那样，发明方面在于少于前面公开的单个实施例的所有特征。因此，遵循具体实施方式的权利要求书由此明确地并入该具体实施方式，其中每个权利要求本身都作为本发明的单独实施例。</p>
    <p>[0169]	本领域那些技术人员可以理解，可以对实施例中的设备中的模块进行自适应性地改变并且把它们设置在与该实施例不同的一个或多个设备中。可以把实施例中的模块或单元或组件组合成一个模块或单元或组件，以及此外可以把它们分成多个子模块或子单元或子组件。除了这样的特征和/或过程或者单元中的至少一些是相互排斥之外，可以采用任何组合对本说明书(包括伴随的权利要求、摘要和附图)中公开的所有特征以及如此公开的任何方法或者设备的所有过程或单元进行组合。除非另外明确陈述，本说明书(包括伴随的权利要求、摘要和附图)中公开的每个特征可以由提供相同、等同或相似目的的替代特征来代替。</p>
    <p>[0170]	此外，本领域的技术人员能够理解，尽管在此所述的一些实施例包括其它实施例中所包括的某些特征而不是其它特征，但是不同实施例的特征的组合意味着处于本发明的范围之内并且形成不同的实施例。例如，在下面的权利要求书中，所要求保护的实施例的任意之一都可以以任意的组合方式来使用。</p>
    <p>[0171]	本发明的各个部件实施例可以以硬件实现，或者以在一个或者多个处理器上运行的软件模块实现，或者以它们的组合实现。本领域的技术人员应当理解，可以在实践中使用微处理器或者数字信号处理器(DSP )来实现根据本发明实施例的动态加载和调用程序的装置中的一些或者全部部件的一些或者全部功能。本发明还可以实现为用于执行这里所描述的方法的一部分或者全部的设备或者装置程序(例如，计算机程序和计算机程序产品)。这样的实现本发明的程序可以存储在计算机可读介质上，或者可以具有一个或者多个信号的形式。这样的信号可以从因特网网站上下载得到，或者在载体信号上提供，或者以任何其他形式提供。</p>
    <p>[0172]	应该注意的是上述实施例对本发明进行说明而不是对本发明进行限制，并且本领域技术人员在不脱离所附权利要求的范围的情况下可设计出替换实施例。在权利要求中，不应将位于括号之间的任何参考符号构造成对权利要求的限制。单词“包含”不排除存在未列在权利要求中的元件或步骤。位于元件之前的单词“一”或“一个”不排除存在多个这样的元件。本发明可以借助于包括有若干不同元件的硬件以及借助于适当编程的计算机来实现。在列举了若干装置的单元权利要求中，这些装置中的若干个可以是通过同一个硬件项来具体体现。单词第一、第二、以及第三等的使用不表示任何顺序。可将这些单词解释为名称。</p>
    <p>[0173]	本发明公开:A1、一种动态加载和调用程序的方法，其包括:由主系统发起对调用程序的调用请求；所述调用程序加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述调用程序将所述调用程序的实例赋值给所述被调用程序的实例；由所述调用程序发起对所述被调用程序的调用请求；由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法。A2、根据Al所述的方法，其中，所述调用程序为已安装的用于调用插件的应用，所述被调用程序为未安装的APK插件。A3、根据Al或A2所述的方法，其中，所述调用程序通过判断所述调用程序的实例不为空来确定成功加载所述被调用程序。A4、根据A3所述的方法，其中，所述被调用程序通过判断所述被调用程序的实例不为空来确定所述被调用程序以插件的形式被调用。A5、根据A1-A4任一项所述的方法，其中，所述由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法进一步包括:由主系统根据程序的生命周期或者调用程序自身调用所述调用程序中的资源加载方法，加载所述调用程序或所述被调用程序的资源；由所述调用程序根据程序的生命周期调用所述被调用程序中的资源加载方法，加载所述被调用程序的资源。A6、根据A1-A4任一项所述的方法，其中，所述由所述主系统根据程序的生命周期调用所述调用程序对应的方法，由所述调用程序根据程序的生命周期调用所述被调用程序对应的方法进一步包括:由主系统通过所述调用程序反射调用所述被调用程序中的组件和服务对应的方法；由主系统调用所述调用程序中的除了上述组件和服务以外的其他组件和服务对应的方法；由所述调用程序调用所述调用程序和所述被调用程序中均不存在的组件和服务对应的方法。A7、根据A1-A6任一项所述的方法，其中，在所述调用程序加载被调用程序生成相关句柄及文件之前进一步包括:对所述被调用程序进行合法性鉴权。</p>
    <p>[0174]	本发明还公开了:B8、一种动态加载和调用程序的装置，其包括:主系统、调用程序运行模块以及被调用程序运行模块；其中，所述主系统包括:第一调用请求发起单元和第一调用单元；所述调用程序运行模块包括:加载单元、赋值单元、第二调用请求发起单元以及第二调用单元；所述第一调用请求发起单元适于发起对调用程序的调用请求；所述加载单元适于加载被调用程序生成相关句柄及文件，并得到所述调用程序的实例；所述赋值单元适于将所述调用程序的实例赋值给所述被调用程序的实例；所述第二调用请求发起单元适于发起对所述被调用程序的调用请求；所述第一调用单元适于根据程序的生命周期调用所述调用程序对应的方法；所述第二调用单元适于根据程序的生命周期调用所述被调用程序对应的方法。B9、根据B8所述的装置，其中，所述调用程序运行模块为已安装的用于调用插件的应用，所述被调用程序运行模块为未安装的APK插件。B10、根据B8或B9所述的装置，其中，所述调用程序运行模块适于通过判断所述调用程序的实例不为空来确定成功加载所述被调用程序。B11、根据BlO所述的装置，其中，所述被调用程序运行模块适于通过判断所述被调用程序的实例不为空来确定所述被调用程序以插件的形式被调用。B12、根据B8-B11任一项所述的装置，其中，所述第一调用单元进一步适于:根据程序的生命周期调用所述调用程序中的资源加载方法，加载所述调用程序或所述被调用程序的资源；所述第二调用单元进一步适于根据程序的生命周期调用所述被调用程序中的资源加载方法，加载所述被调用程序的资源。B13、根据B8-B11任一项所述的装置，其中，所述第一调用单元进一步适于:通过所述第二调用单元反射调用所述被调用程序中的组件和服务对应的方法；以及调用所述调用程序中的除了上述组件和服务以外的其他组件和服务对应的方法；所述第二调用单元进一步适于:调用所述调用程序和所述被调用程序中均不存在的组件和服务对应的方法。B14、根据B8-B13任一项所述的装置，其中，所述调用程序运行模块还包括:鉴权单元，适于对所述被调用程序进行合法性鉴权。</p>
  </div>
  </div></div><div class="patent-section patent-tabular-section"><a id="backward-citations"></a><div class="patent-section-header"><span class="patent-section-title">专利引用</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">引用的专利</th><th class="patent-data-table-th"> 申请日期</th><th class="patent-data-table-th">公开日</th><th class="patent-data-table-th"> 申请人</th><th class="patent-data-table-th">专利名</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN101924798A?cl=zh">CN101924798A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2010年9月8日</td><td class="patent-data-table-td patent-date-value">2010年12月22日</td><td class="patent-data-table-td ">北京大学</td><td class="patent-data-table-td ">一种基于文件类型的Android构件透明加载方法及系统</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8370824">US8370824</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2008年7月29日</td><td class="patent-data-table-td patent-date-value">2013年2月5日</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Dynamic class loading</td></tr></table><div class="patent-section-footer">* 由审查员引用</div></div><div class="patent-section patent-tabular-section"><a id="npl-citations"></a><div class="patent-section-header"><span class="patent-section-title">非专利引用</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th colspan="3"class="patent-data-table-th">参考文献</th></tr></thead><tr><td class="patent-data-table-td ">1</td><td class="patent-data-table-td "><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td ">MINGLI198611: "<a href='http://scholar.google.com/scholar?q="android%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%B1%BB----app%E6%8F%92%E4%BB%B6%E6%8A%80%E6%9C%AF"'>android如何动态的加载类----app插件技术</a>", 《HTTP://BLOG.CSDN.NET/MINGLI198611/ARTICLE/DETAILS/8858076》, 27 April 2013 (2013-04-27), pages 1 - 6</td></tr><tr><td class="patent-data-table-td ">2</td><td class="patent-data-table-td "><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td ">网友: "<a href='http://scholar.google.com/scholar?q="Android%E9%80%8F%E8%BF%87%E5%8F%8D%E5%B0%84%E5%90%AF%E5%8A%A8%E6%9C%AA%E5%AE%89%E8%A3%85%E7%9A%84APK%E4%B8%AD%E7%9A%84Activity"'>Android透过反射启动未安装的APK中的Activity</a>", 《我的异常网 HTTP://WWW.MYEXCEPTION.CN/ANDROID/1217391.HTML》, 20 February 2013 (2013-02-20), pages 1 - 7</td></tr></table><div class="patent-section-footer">* 由审查员引用</div></div><div class="patent-section patent-tabular-section"><a id="forward-citations"></a><div class="patent-section-header"><span class="patent-section-title"> 被以下专利引用</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">引用专利</th><th class="patent-data-table-th"> 申请日期</th><th class="patent-data-table-th">公开日</th><th class="patent-data-table-th"> 申请人</th><th class="patent-data-table-th">专利名</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO2015055074A1?cl=zh">WO2015055074A1</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2014年9月25日</td><td class="patent-data-table-td patent-date-value">2015年4月23日</td><td class="patent-data-table-td ">北京奇虎科技有限公司</td><td class="patent-data-table-td ">动态加载和调用程序的方法及装置</td></tr></table><div class="patent-section-footer">* 由审查员引用</div></div><div class="patent-section patent-tabular-section"><a id="classifications"></a><div class="patent-section-header"><span class="patent-section-title">分类</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> </th><th class="patent-data-table-th"> </th></tr></thead><tr><td class="patent-data-table-td ">国际分类号</td><td class="patent-data-table-td "><span class="nested-value"><a href="https://www.google.com/url?id=4TnuCAABERAJ&amp;q=http://web2.wipo.int/ipcpub/&amp;usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&amp;notion=scheme&amp;version=20130101&amp;symbol=G06F0009445000">G06F9/445</a></span></td></tr><tr><td class="patent-data-table-td "> 合作分类</td><td class="patent-data-table-td "><span class="nested-value"><a href="https://www.google.com/url?id=4TnuCAABERAJ&amp;q=http://worldwide.espacenet.com/classification&amp;usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06F9/44521">G06F9/44521</a></span></td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="legal-events"></a><div class="patent-section-header"><span class="patent-section-title">法律事件</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> 日期</th><th class="patent-data-table-th">代码</th><th class="patent-data-table-th">事件</th><th class="patent-data-table-th">说明</th></tr></thead><tr><td class="patent-data-table-td patent-date-value">2014年1月22日</td><td class="patent-data-table-td ">C06</td><td class="patent-data-table-td ">Publication</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">2014年2月26日</td><td class="patent-data-table-td ">C10</td><td class="patent-data-table-td ">Entry into substantive examination</td><td class="patent-data-table-td "></td></tr></table><div class="patent-section-footer"></div></div><div class="modal-dialog" id="patent-images-lightbox"><div class="patent-lightbox-controls"><div class="patent-lightbox-rotate-controls"><div class="patent-lightbox-rotation-text">旋转</div><div class="rotate-icon rotate-ccw-icon"></div><div class="rotate-icon rotate-cw-icon"></div></div><div class="patent-lightbox-index-counter"></div><a class="patent-lightbox-fullsize-link" target="_blank">原始图片</a><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_right.png" alt="Next page"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_left.png" alt="Previous page"width="21" height="21" /></div></div><div class="modal-dialog-content"><div class="patent-lightbox-image-holder"><div class="patent-lightbox-placeholder"></div></div></div></div><script>_OC_initPatentsAtb({image_not_available_html: " 未提供图片。\x3ca href\x3d//docs.google.com/viewer?url\x3dpatentimages.storage.googleapis.com/pdfs/fde23c479135539b0c9d/CN103530156A.pdf\x3e查看 PDF\x3c/a\x3e"});</script></div></div></div></div></div><script>(function() {var href = window.location.href;if (href.indexOf('?') !== -1) {var parameters = href.split('?')[1].split('&');for (var i = 0; i < parameters.length; i++) {var param = parameters[i].split('=');if (param[0] == 'focus') {var elem = document.getElementById(param[1]);if (elem) {elem.focus();}}}}})();</script><script>_OC_addFlags({LockSrc:"/books/javascript/lock_50a6672b5f82ffbd39b7a9e87fd4594c.js", Host:"https://www.google.com/", IsBooksRentalEnabled:1, IsBrowsingHistoryEnabled:1, IsWebReaderSvgEnabled:0, IsImageModeNotesEnabled:1, IsOfflineBubbleEnabled:1, IsFutureOnSaleVolumesEnabled:1, IsBooksUnifiedLeftNavEnabled:1, IsMobileRequest:0, IsZipitFolderCollectionEnabled:1, IsAdsDisabled:0, IsEmbeddedMediaEnabled:1, IsImageModeAnnotationsEnabled:1, IsMyLibraryGooglePlusEnabled:1, IsImagePageProviderEnabled:1, IsBookcardListPriceSmall:0, IsInternalUser:0, IsBooksShareButtonEnabled:0, IsDisabledRandomBookshelves:0});_OC_Run({"enable_p13n":false,"is_cobrand":false,"sign_in_url":"https://www.google.com/accounts/Login?service=\u0026continue=https://www.google.com/patents%3Fcl%3Dzh%26hl%3Dzh-CN\u0026hl=zh-CN"}, {"volume_id":"","is_ebook":true,"volumeresult":{"has_flowing_text":false,"has_scanned_text":true,"can_download_pdf":false,"can_download_epub":false,"is_pdf_drm_enabled":false,"is_epub_drm_enabled":false,"download_pdf_url":"https://www.google.com/patents/download/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%B0%83%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A.pdf?id=4TnuCAABERAJ\u0026hl=zh-CN\u0026output=pdf\u0026sig=ACfU3U0y53N7Yy_Lmze6yduBZTcOAoC_2A"},"sample_url":"https://www.google.com/patents/reader?id=4TnuCAABERAJ\u0026hl=zh-CN\u0026printsec=frontcover\u0026output=reader\u0026source=gbs_atb_hover","is_browsable":true,"is_public_domain":true}, {});</script><div id="footer_table" style="font-size:83%;text-align:center;position:relative;top:20px;height:4.5em;margin-top:2em"><div style="margin-bottom:8px"><a href="https://www.google.com/search?hl=zh-CN"><nobr>Google&nbsp;首页</nobr></a> - <a href="//www.google.com/patents/sitemap/"><nobr>站点地图</nobr></a> - <a href="http://www.google.com/googlebooks/uspto.html"><nobr>美国专利商标局 (USPTO) 专利信息批量下载</nobr></a> - <a href="/intl/zh-CN/privacy/"><nobr>隐私权政策</nobr></a> - <a href="/intl/zh-CN/policies/terms/"><nobr>服务条款</nobr></a> - <a href="https://support.google.com/faqs/answer/2539193?hl=zh-CN"><nobr> 关于 Google 专利</nobr></a> - <a href="//www.google.com/tools/feedback/intl/zh-CN/error.html" onclick="try{_OC_startFeedback({productId: '72792',locale: 'zh-CN'});return false;}catch(e){}"><nobr>发送反馈</nobr></a></div></div> <script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-27188110-1");pageTracker._setCookiePath("/patents/");pageTracker._trackPageview();</script> </body></html>