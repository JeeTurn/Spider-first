<!DOCTYPE html><html><head><title>专利 CN101529382A - 公共组件框架 -  Google 专利</title><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){var d=void 0!=b?b:(new Date).getTime();this.t[a]=[d,c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(e){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_",
"_wtsrt",d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})();
</script><link rel="stylesheet" href="/patents/css/_50a6672b5f82ffbd39b7a9e87fd4594c/kl_intl_patents_bundle.css" type="text/css" /><script src="/books/javascript/atb_50a6672b5f82ffbd39b7a9e87fd4594c__zh_cn.js"></script><script>function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: "zh",gaTrack: true,gaId: "UA-27188110-1",multilanguagePage: true});}</script><script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><meta name="DC.type" content="Patent"><meta name="DC.title" content="公共组件框架"><meta name="DC.contributor" content="A&#183;赤&#183;策&#183;侯" scheme="inventor"><meta name="DC.contributor" content="K&#183;P&#183;洛伊格" scheme="inventor"><meta name="DC.contributor" content="M&#183;蒂尔德斯勒" scheme="inventor"><meta name="DC.contributor" content="N&#183;科尔巴" scheme="inventor"><meta name="DC.contributor" content="R&#183;D&#183;霍姆斯" scheme="inventor"><meta name="DC.contributor" content="路透美国公司" scheme="assignee"><meta name="DC.date" content="2007-9-21" scheme="dateSubmitted"><meta name="DC.description" content="公共组件框架(CCF)提供了容器接口和组件接口以便在多层软件应用中进行通信。可以向/从描述正在其中执行的组件的当前状态的容器传送组件上下文数据。上下文数据可以对应于由与所述组件交互的用户标识的特定实体(例如，金融实体，如公司或股票)。所述容器可以在不同的组件之间传送所述上下文数据以同步和协调组件行为，从而提供更健全和一致的用户体验。除了组件上下文数据以外，还可以在容器和组件之间传送诸如属性、菜单选项以及数据字段之类的其他信息，从而甚至支持将基于Web的组件更完整地集成到容器中。"><meta name="DC.date" content="2009-9-9"><meta name="citation_patent_publication_number" content="CN:101529382:A"><meta name="citation_patent_application_number" content="CN:200780038751"><link rel="canonical" href="https://www.google.com/patents/CN101529382A?cl=zh"/><meta property="og:url" content="https://www.google.com/patents/CN101529382A?cl=zh"/><meta name="title" content="专利 CN101529382A - 公共组件框架"/><meta name="description" content="公共组件框架(CCF)提供了容器接口和组件接口以便在多层软件应用中进行通信。可以向/从描述正在其中执行的组件的当前状态的容器传送组件上下文数据。上下文数据可以对应于由与所述组件交互的用户标识的特定实体(例如，金融实体，如公司或股票)。所述容器可以在不同的组件之间传送所述上下文数据以同步和协调组件行为，从而提供更健全和一致的用户体验。除了组件上下文数据以外，还可以在容器和组件之间传送诸如属性、菜单选项以及数据字段之类的其他信息，从而甚至支持将基于Web的组件更完整地集成到容器中。"/><meta property="og:title" content="专利 CN101529382A - 公共组件框架"/><meta property="og:type" content="book"/><meta property="og:site_name" content="Google Books"/><meta property="og:image" content="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><link rel="image_src" href="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><script>if (window['_OC_timingAction']) {window['_OC_timingAction']('patents_refpage');}</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}@media all{.gb1{height:22px;margin-right:.5em;vertical-align:top}#gbar{float:left}}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb4{color:#00c !important}.gbi .gb4{color:#dd8e27 !important}.gbf .gb4{color:#900 !important}

#gbar { padding:.3em .6em !important;}</style></head><body ><div id=gbar><nobr><a class=gb1 href="https://www.google.com/search?cl=zh&hl=zh-CN&sa=N&tab=tw">搜索</a> <a class=gb1 href="https://www.google.com/search?cl=zh&hl=zh-CN&tbm=isch&source=og&sa=N&tab=ti">图片</a> <a class=gb1 href="https://maps.google.com/maps?cl=zh&hl=zh-CN&sa=N&tab=tl">地图</a> <a class=gb1 href="https://play.google.com/?cl=zh&hl=zh-CN&sa=N&tab=t8">Play</a> <a class=gb1 href="https://www.youtube.com/results?cl=zh&hl=zh-CN&sa=N&tab=t1">YouTube</a> <a class=gb1 href="https://news.google.com/nwshp?hl=zh-CN&tab=tn">新闻</a> <a class=gb1 href="https://mail.google.com/mail/?tab=tm">Gmail</a> <a class=gb1 href="https://drive.google.com/?tab=to">云端硬盘</a> <a class=gb1 style="text-decoration:none" href="https://www.google.com/intl/zh-CN/options/"><u>更多</u> &raquo;</a></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a target=_top id=gb_70 href="https://www.google.com/accounts/Login?service=&continue=https://www.google.com/patents%3Fcl%3Dzh%26hl%3Dzh-CN&hl=zh-CN" class=gb4>登录</a></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div><div role="alert" style="position: absolute; left: 0; right: 0;"><a href="https://www.google.com/patents/CN101529382A?cl=zh&amp;hl=zh-CN&amp;output=html_text" title="屏幕阅读器用户请注意：点击此链接可进入无障碍模式。阅读器在无障碍模式下具有同样的基本功能，但可让用户获得更好的体验。"><img border="0" src="//www.google.com/images/cleardot.gif"alt="屏幕阅读器用户请注意：点击此链接可进入无障碍模式。阅读器在无障碍模式下具有同样的基本功能，但可让用户获得更好的体验。"></a></div><div class="kd-appbar"><h2 class="kd-appname"><a href="/patents?hl=zh-CN"> 专利</a></h2><div class="kd-buttonbar left" id="left-toolbar-buttons"><a id="appbar-write-review-link" href=""></a><a id="appbar-view-print-sample-link" href=""></a><a id="appbar-view-ebook-sample-link" href=""></a><a id="appbar-patents-prior-art-finder-link" href="https://www.google.com/patents/related/CN101529382A"></a><a id="appbar-patents-discuss-this-link" href="https://www.google.com/url?id=FxNtBwABERAJ&amp;q=http://patents.stackexchange.com/redirect/google-patents%3Fpublication%3DCN101529382A&amp;usg=AFQjCNHtwCspLADVdjKQ_14-5vFG9dTE3g" data-is-grant="false"></a><a id="appbar-read-patent-link" href="//docs.google.com/viewer?url=patentimages.storage.googleapis.com/pdfs/7da8cdbf37cd63b1a73e/CN101529382A.pdf"></a><a id="appbar-download-pdf-link" href="//patentimages.storage.googleapis.com/pdfs/7da8cdbf37cd63b1a73e/CN101529382A.pdf"></a><a class="appbar-content-language-link" data-selected="true" data-label="中文" href="/patents/CN101529382A?cl=zh&amp;hl=zh-CN"></a><a class="appbar-content-language-link" data-label="英语" href="/patents/CN101529382A?cl=en&amp;hl=zh-CN"></a><a class="appbar-application-grant-link" data-selected="true" data-label="申请" href="/patents/CN101529382A?hl=zh-CN&amp;cl=zh"></a><a class="appbar-application-grant-link" data-label="授权" href="/patents/CN101529382B?hl=zh-CN&amp;cl=zh"></a></div><div class="kd-buttonbar right" id="right-toolbar-buttons"></div></div><div id="books-microdata" itemscope=""itemtype="http://schema.org/Book"itemid="https://www.google.com/patents/CN101529382A?cl=zh" style="display:none"><span itemprop="description">公共组件框架(CCF)提供了容器接口和组件接口以便在多层软件应用中进行通信。可以向/从描述正在其中执行的组件的当前状态的容器传送组件上下文数据。上下文数据可以对应于由与所述组件交互的用户标识的特定实体(例如， ...</span><span itemprop="url">https://www.google.com/patents/CN101529382A?cl=zh&amp;utm_source=gb-gplus-share</span><span class="main-title" itemprop="name">专利 CN101529382A - 公共组件框架</span><img itemprop="image" src="https://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"alt="专利 CN101529382A - 公共组件框架" title="专利 CN101529382A - 公共组件框架"></div><div style="display: none"><ol id="ofe-gear-menu-contents" class="gbmcc"><li class="gbe gbmtc"><a class="gbmt goog-menuitem-content" id="" href="https://www.google.com/advanced_patent_search?hl=zh-CN"> 高级专利搜索</a></li></ol></div><div id="volume-main"><div id="volume-center"><div class=vertical_module_list_row><div id=intl_patents class=about_content><div id=intl_patents_v><table class="patent-bibdata patent-drawings-missing"><tr><td class="patent-bibdata-heading"> 公开号</td><td class="single-patent-bibdata">CN101529382 A</td></tr><tr><td class="patent-bibdata-heading">发布类型</td><td class="single-patent-bibdata">申请</td></tr><tr><td class="patent-bibdata-heading"> 专利申请号</td><td class="single-patent-bibdata">CN 200780038751</td></tr><tr><td class="patent-bibdata-heading"> 专利合作条约 (PCT) 编号</td><td class="single-patent-bibdata">PCT/US2007/020481</td></tr><tr><td class="patent-bibdata-heading">公开日</td><td class="single-patent-bibdata">2009年9月9日</td></tr><tr><td class="patent-bibdata-heading"> 申请日期</td><td class="single-patent-bibdata">2007年9月21日</td></tr><tr><td class="patent-bibdata-heading"> 优先权日<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="优先日期属于假设性质，不具任何法律效力。Google 对于所列日期的正确性并没有进行法律分析，也不作任何陈述。"></span></td><td class="single-patent-bibdata">2006年9月21日</td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">公告号</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/CA2664161A1?hl=zh-CN&amp;cl=zh">CA2664161A1</a>, </span><span class="patent-bibdata-value"><a href="/patents/CA2664161C?hl=zh-CN&amp;cl=zh">CA2664161C</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN101529382B?hl=zh-CN&amp;cl=zh">CN101529382B</a>, </span><span class="patent-bibdata-value"><a href="/patents/EP2064623A2?hl=zh-CN&amp;cl=zh">EP2064623A2</a>, </span><span class="patent-bibdata-value"><a href="/patents/US7805730?hl=zh-CN&amp;cl=zh">US7805730</a>, </span><span class="patent-bibdata-value"><a href="/patents/US8578395?hl=zh-CN&amp;cl=zh">US8578395</a>, </span><span class="patent-bibdata-value"><a href="/patents/US20080077941?hl=zh-CN&amp;cl=zh">US20080077941</a>, </span><span class="patent-bibdata-value"><a href="/patents/US20100325641?hl=zh-CN&amp;cl=zh">US20100325641</a>, </span><span class="patent-bibdata-value"><a href="/patents/WO2008036399A2?hl=zh-CN&amp;cl=zh">WO2008036399A2</a>, </span><span class="patent-bibdata-value"><a href="/patents/WO2008036399A3?hl=zh-CN&amp;cl=zh">WO2008036399A3</a></span></span></td></tr><tr class="patent-bibdata-list-row alternate-patent-number"><td class="patent-bibdata-heading"> 公开号</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value">200780038751.0, </span><span class="patent-bibdata-value">CN 101529382 A, </span><span class="patent-bibdata-value">CN 101529382A, </span><span class="patent-bibdata-value">CN 200780038751, </span><span class="patent-bibdata-value">CN-A-101529382, </span><span class="patent-bibdata-value">CN101529382 A, </span><span class="patent-bibdata-value">CN101529382A, </span><span class="patent-bibdata-value">CN200780038751, </span><span class="patent-bibdata-value">CN200780038751.0, </span><span class="patent-bibdata-value">PCT/2007/20481, </span><span class="patent-bibdata-value">PCT/US/2007/020481, </span><span class="patent-bibdata-value">PCT/US/2007/20481, </span><span class="patent-bibdata-value">PCT/US/7/020481, </span><span class="patent-bibdata-value">PCT/US/7/20481, </span><span class="patent-bibdata-value">PCT/US2007/020481, </span><span class="patent-bibdata-value">PCT/US2007/20481, </span><span class="patent-bibdata-value">PCT/US2007020481, </span><span class="patent-bibdata-value">PCT/US200720481, </span><span class="patent-bibdata-value">PCT/US7/020481, </span><span class="patent-bibdata-value">PCT/US7/20481, </span><span class="patent-bibdata-value">PCT/US7020481, </span><span class="patent-bibdata-value">PCT/US720481</span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading"> 发明者</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22A%C2%B7%E8%B5%A4%C2%B7%E7%AD%96%C2%B7%E4%BE%AF%22">A&#183;赤&#183;策&#183;侯</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22K%C2%B7P%C2%B7%E6%B4%9B%E4%BC%8A%E6%A0%BC%22">K&#183;P&#183;洛伊格</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22M%C2%B7%E8%92%82%E5%B0%94%E5%BE%B7%E6%96%AF%E5%8B%92%22">M&#183;蒂尔德斯勒</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22N%C2%B7%E7%A7%91%E5%B0%94%E5%B7%B4%22">N&#183;科尔巴</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=ininventor:%22R%C2%B7D%C2%B7%E9%9C%8D%E5%A7%86%E6%96%AF%22">R&#183;D&#183;霍姆斯</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading"> 申请人</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="https://www.google.com/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=inassignee:%22%E8%B7%AF%E9%80%8F%E7%BE%8E%E5%9B%BD%E5%85%AC%E5%8F%B8%22">路透美国公司</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">导出引文</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/CN101529382A.bibtex?cl=zh">BiBTeX</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN101529382A.enw?cl=zh">EndNote</a>, </span><span class="patent-bibdata-value"><a href="/patents/CN101529382A.ris?cl=zh">RefMan</a></span></span></td></tr><tr class="patent-internal-links"><td colspan=2><span class="patent-bibdata-value"><a href="#forward-citations"> 被以下专利引用</a> (1),</span> <span class="patent-bibdata-value"><a href="#classifications">分类</a> (5),</span> <span class="patent-bibdata-value"><a href="#legal-events">法律事件</a> (3)</span> </td></tr><tr><td colspan=2 class="patent-bibdata-external-link-spacer-top"></td></tr><tr class="patent-bibdata-external-link-spacer-bottom"></tr><tr><td colspan=2><span class="patent-bibdata-heading">外部链接:&nbsp;</span><span><span class="patent-bibdata-value"><a href="https://www.google.com/url?id=FxNtBwABERAJ&amp;q=http://211.157.104.87:8080/sipo/zljs/hyjs-yx-new.jsp%3Frecid%3D200780038751&amp;usg=AFQjCNF7e5TrVw8nY12rNucObPRZr6pRww"> 中国国家知识产权局</a>, </span><span class="patent-bibdata-value"><a href="https://www.google.com/url?id=FxNtBwABERAJ&amp;q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DCN%26NR%3D101529382A%26KC%3DA%26FT%3DD&amp;usg=AFQjCNGSbqnogPmRqEQHsr0vJy6qzwKumQ"> 欧洲专利数据库 (Espacenet)</a></span></span></td></tr><tr class="patent-bibdata-group-spacer"></tr></table><div class="number-and-title"><span class="patent-title"><invention-title mxw-id="PT86142238" lang="ZH" load-source="patent-office">公共组件框架</invention-title>
      </span><br><span class="patent-number">CN 101529382 A</span></div><div class="patent-section patent-abstract-section"><div class="patent-section-header"><span class="patent-section-title"> 摘要</span></div><div class="patent-text"><abstract mxw-id="PA62179668" lang="ZH" load-source="patent-office">
    <div class="abstract">公共组件框架(CCF)提供了容器接口和组件接口以便在多层软件应用中进行通信。可以向/从描述正在其中执行的组件的当前状态的容器传送组件上下文数据。上下文数据可以对应于由与所述组件交互的用户标识的特定实体(例如，金融实体，如公司或股票)。所述容器可以在不同的组件之间传送所述上下文数据以同步和协调组件行为，从而提供更健全和一致的用户体验。除了组件上下文数据以外，还可以在容器和组件之间传送诸如属性、菜单选项以及数据字段之类的其他信息，从而甚至支持将基于Web的组件更完整地集成到容器中。</div>
  </abstract>
  </div></div><div class="patent-section patent-claims-section"><div class="patent-section-header"><span class="patent-section-title">权利要求<span class="patent-section-count">(23)</span></span></div><div class="patent-text"><div mxw-id="PCLM22787663" lang="ZH" load-source="patent-office" class="claims">
    <div class="claim"> <div num="1" class="claim">
      <div class="claim-text">1.一种在组件软件对象和软件容器对象之间进行电子通信的计算机实现的方法，包括：    在容器对象上启动注册函数，向所述函数传递与所述容器对象内的组件对象支持的通用组件接口对应的第一接口指针；    从所述容器对象接收与所述容器对象支持的通用容器接口对应的第二接口指针，其中所述第一和所述第二接口支持用于组件和容器之间的一般通信的一组预定函数；    在所述组件对象内运行的用户接口控件上接收用户输入；    确定所述容器接口支持的与所接收的用户输入关联的函数；以及    使用所述第二接口指针在所述容器接口中调用所述函数。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="2" class="claim">
      <div class="claim-text">2. 根据权利要求l的方法，其中所述容器对象和所述第一组件在浏览 器应用的实例中执行。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="3" class="claim">
      <div class="claim-text">3. 根据权利要求l的方法，还包括：经由所述第二接口从所述容器对象接收组件上下文数据，所述组件上 下文数据包括实体标识符。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="4" class="claim">
      <div class="claim-text">4. 根据权利要求3的方法，其中所述实体标识符与公司名称、股票名 称、债券名称、市场名称以及国家名称中的一个关联。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="5" class="claim">
      <div class="claim-text">5. 根据权利要求3的方法，还包括：响应于从所述容器对象接收所述组件上下文数据，根据所述组件上下 文数据从远程数据存储区检索数据；使用所检索的数据执行组件特定的功能；以及 根据所执行的组件特定的功能更新所述组件对象的用户接口。</div>
    </div>
    </div> <div class="claim"> <div num="6" class="claim">
      <div class="claim-text">6. &#8212;种在组件软件对象和容器软件对象之间进行电子通信的计算机实 现的方法，包括：将第 一接口指针从容器传送到第 一组件对象，所述第 一接口指针定义了关于所述第一组件的由所述容器支持的多个函数；在所述容器处接收来自第二组件对象的第二接口指针，所述第二接口指针定义了关于所述容器的由所述第二组件支持的多个函数；经由所述第一接口接收第一用户操作已在所述第一组件内发生的指示，所述指示包括组件上下文数据；检测与所迷第二组件关联的第二用户操作；以及经由所述第二接口将所述组件上下文数据传送到所述第二组件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="7" class="claim">
      <div class="claim-text">7. 根据权利要求6的方法，还包括： 确定所述组件上下文数据是否与所述第二&#32068;件兼容；以及 如果所述组件上下文数据与所述第二组件不兼容，则根据所存储的描述所述第二组件的信息来转换所述组件上下文数据。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="8" class="claim">
      <div class="claim-text">8. 根据权利要求6的方法，其中所述第一用户操作包括从所述第一组 件内的用户接口选择实体。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="9" class="claim">
      <div class="claim-text">9. 根据权利要求8的方法，其中所选择的实体包括公司名称、股票名 称、债券名称、市场名称以及国家名称中的一个。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="10" class="claim">
      <div class="claim-text">10. 根据权利要求6的方法，其中所述第一用户操作包括与所述第一 组件内的用户接口中的实体关联的拖动事件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="11" class="claim">
      <div class="claim-text">11. 根据权利要求10的方法，其中所述第二用户操作包括与所述实体 关联的放下事件，所述力文下事件在所述第二组件内的用户接口上发生。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="12" class="claim">
      <div class="claim-text">12. 根据权利要求6的方法，其中所述第一用户操作指定所述第一组 件的用户接口内的一个或多个数据字段，并且其中所述第二用户操作包括 将所指定的数据字&#36084;^支入所述第二组件的用户接口的放下事件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="13" class="claim">
      <div class="claim-text">13. 根据权利要求6的方法，其中所述第一和所述第二用户操作中的</div>
    </div>
    </div> <div class="claim-dependent"> <div num="14" class="claim">
      <div class="claim-text">14. 根据权利要求6的方法，其中所述容器、所述第一组件以及所述 第二组件在浏览器应用的实例中执行。</div>
    </div>
    </div> <div class="claim"> <div num="15" class="claim">
      <div class="claim-text">15. &#8212;个或多个存储计算机可执行指令的计算机可读介质，当所述指 令在计算机系统上执行时，将执行包括以下步骤的方法：将第一接口指针传送到第一&#32068;件对象，所述第一接口指针定义了关于所述第一组件所支持的多个函数；接收来自笫二组件对象的第二接口指针，所述笫二接口指针定义了所 述第二组件所支持的多个函数；经由所述第 一接口接收第 一用户操作已在所述第 一组件内发生的指 示，所述指示包括组件上下文数据；检测与所述第二组件关联的第二用户操作；以及经由所述第二接口将所述组件上下文数据传送到所述第二组件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="16" class="claim">
      <div class="claim-text">16. 根据权利要求15的计算机可读介质，其中所述方法还包括： 确定所述组件上下文数据是否与所述第二组件兼容；以及 如果所述组件上下文数据与所述第二组件不兼容，则根据所存储的描述所述第二组件的信息来转换所述组件上下文数据。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="17" class="claim">
      <div class="claim-text">17. 根据权利要求15的计算机可读介质，其中所述第一用户操作包括 从所述第 一组件内的用户接口选择实体。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="18" class="claim">
      <div class="claim-text">18. 根据权利要求17的计算机可读介质，其中所选择的实体包括公司、 股票、债券、市场以及国家中的一个。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="19" class="claim">
      <div class="claim-text">19. 根据权利要求15的计算机可读介质，其中所述第一用户操作包括 与所述第 一组件内的用户接口中的实体关联的拖动事件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="20" class="claim">
      <div class="claim-text">20. 根据权利要求19的计算机可读介质，其中所述第二用户操作包括 与所述实体关联的放下事件，所述》文下事件在所述第二组件内的用户接口 上发生。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="21" class="claim">
      <div class="claim-text">21. 根据权利要求15的计算机可读介质，其中所述第一用户操作指定 所述第一&#32068;件的用户接口内的一个或多个数据字段，并且其中所述第二用 户操作包括将所指定的数据字段放入所述第二组件的用户接口的放下事 件。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="22" class="claim">
      <div class="claim-text">22. 根据权利要求15的计算机可读介质，其中所述第一和所述第二用 户操作中的一个操作包括将所选择的数据字段导出到电子表格软件应用的 用户命令。</div>
    </div>
    </div> <div class="claim-dependent"> <div num="23" class="claim">
      <div class="claim-text">23. 根据权利要求15的计算机可读介质，其中所述方法在浏览器应用的实例中执行，并且其中所述第 一&#32068;件和所述第二组件在同 一 因特网浏览 器应用实例中执行。</div>
    </div>
  </div> </div>
  </div></div><div class="patent-section patent-description-section"><div class="patent-section-header"><span class="patent-section-title"> 说明</span></div><div class="patent-text"><div mxw-id="PDES27982342" lang="ZH" load-source="patent-office" class="description">
    <p>公共组件框架</p>
    <p>技术领域</p>
    <p>本发明一般地涉及在软件应用中的对象间进行通信的方法。更具体地 说，本发明涉及在容器应用与容器内的组件软件对象之间建立的通用通信 框架。</p>
    <p>背景技术</p>
    <p>基于在软件容器应用内执行的模块化组件，软件应用通常被实现为多 层应用。这些容器-组件应用在开发、可移植性和可扩展性方面提供了优势。 容器应用可以处理事务、安全以及组件管理功能，使得组件开发者能够专 注于由他们的组件所实现的特定功能。此外，容器可以通过与每个其组件 同时通信的方式在多个组件之间进行协调并对行为进行同步。</p>
    <p>在实现这些优势之前，必须在容器应用及其组件之间建立有效的通信 标准。这是一个挑战，因为组件和容器可以是多个不同对象类型中的任何</p>
    <p>一个。例如，组件可以净皮实现为简单的HTML页面、基于Web的对象， 或应用对象的实例。对于任何基于Web的组件，容器可以是另一个Web 页面，或桌面容器应用。对于通信难题的一种先前解决方案涉及使用具有 本地组件的容器。当桌面容器应用包括专门为在该容器内使用而设计的本 地组件时，这些所谓的"智能"组件可以被紧密地集成到容器环境中。例 如，智能组件可以被直接置于一层FLEX容器实例中（例如，作为容器窗 口中的瓦片（tile)或选项卡（tab))，而不是在单独的弹出窗口中启动。 类似地，所述组件可以支持更健全的功能并且可以被完整地集成到容器的 FLEX范例中。</p>
    <p>但是，基于Web的组件不能被紧密地集成到类似本地智能组件的容器中。因此，在典型的容器架构中，基于Web的组件通常支持有限的功能并 提供不是很一致的用户体验。此外，如上所述，通常必须为特定的容器应 用专门设计在容器内运行的本地智能组件。结果，智能组件通常不能在其 他容器内工作，使得容器-组件软件应用的许多主要优势荡然无存。</p>
    <p>因此，需要一种在多层软件应用中的容器和组件之间进行通信的系统。</p>
    <p>发明内容</p>
    <p>根据上述问题，本发明涉及一种在多层软件应用中的容器和组件软件 对象之间进行通信的公共组件框架（CCF)系统。在一个方面中，组件请 求所述容器上的注册函数调用。使用此函数，容器和组件可以交换彼此用 于执行通用函数调用和数据请求的CCF接口指针。在特定实施例中，由于 此接口指针交换可以在接近组件实例化时发生，所以可以在注册函数的稍 后使用第二函数调用来通知所述组件已准备好从容器接收调用和数据请 求。 一旦组件和容器建立了这些接口，每一方就可以通知另一方在其范围 内发生的用户操作或某些其他状态更改，使得被通知的容器或组件能够根 据所述更改采取适当的操作来协调其行为。</p>
    <p>根据另一个方面，在已交换CCF接口指针之后，用户可以例如通过单 击或选择组件中的用户接口控件来导致所述组件中的上下文更改。作为一</p>
    <p>件中的金融实体（例如，公司、股票、债券、市场等）。响应于所述上下 文更改，所述组件可以发送事件以通知容器所述更改并提供新的上下文。 所述容器可以转换所述上下文数据（如果需要）并将新的上下文数据转发 到该容器内运行的一个或多个其他组件。因此，即使是单独设计和开发以 提供不同功能的组件也可以通过CCF接口由所述容器来协调和同步，这向 用户提供了更加无缝和一致的体验。</p>
    <p>根据再一个方面，所述上下文更改可以源自用户将所述组件中的一个 用户接口控件拖放到同 一容器内运行的其他组件中的拖放操作。组件之间</p>
    <p>或甚至可以允许用户将特定数据字段从一个组件的用户接口拖入另 一个组件的用户接 口。作为此功能的一个示例，可以将金融数据检索组件返回的搜索结果拖</p>
    <p>入同一容器内运行的邻近电子表格组件（例如，Microsoft Excel对象实例）。 从本发明的以下详细说明、所附权利要求以及附图，本发明的这些以 及其他优点和方面将是显而易见和可以理解的。</p>
    <p>附图说明</p>
    <p>通过示例的方式示出了本发明并且本发明并不限于附图，在附图中，</p>
    <p>相同的标号指示相同的元素，这些附图是：</p>
    <p>图1示出了才艮据本^Hf的各方面的计算环境的框图；</p>
    <p>图2示出了才艮据4^^开的各方面的软件组件架构的框图；</p>
    <p>图3是示出才艮据本公开的各方面的组件和容器之间的通信的流程图；</p>
    <p>图4是示出才艮据本公开的各方面的公共组件框架（CCF)功能的执行</p>
    <p>的流程图；以及</p>
    <p>图5-9是示出根据本公开的各方面的用户与CCF容器内启用CCF的 组件的交互的示例性屏幕快照。</p>
    <p>具体实施方式</p>
    <p>在以下对各个实施例的说明中，参考了形成本说明书一部分的附图，</p>
    <p>例。应当理解，可以采用其他实施例并且可以4故出结构和功能修改而不偏 离本发明的范围。</p>
    <p>由于本发明涉及软件对象通信，因此首先将描述适合的通用计算系统 环境。其上可以实现一个或多个示例性方面的计算机100只是适合的计算 环境的一个示例并且并非旨在暗示与在此描述的使用范围或特性功能相关 的任何限制。图1示出了其中可以实现在此描述的一个或多个方面的计算环境。诸</p>
    <p>如计算机ioo的计算设备可以容纳有用于输入、输出、存储和处理数据的 各种组件。例如，处理器105可以执行多种任务，包括执行一个或多个应 用、从存储装置115之类的存储设备检索数据和/或将数据输出到诸如显示 器120之类的设备。处理器105可以连接到随M取存储器（RAM)模块 110，后者可以临时存储应用数据和/或指令。可以以任何顺序存储和存取 RAM模块110，这提供了对RAM模块110中的存储单元的同等可存取性。 计算机100还可以包括只读存储器（ROM) 112，其允许存储在其上的数 据在关闭计算机100之后保持不变或继续存在。ROM 112可用于各种用途， 包括存储计算机100的基本输入/输出系统（BIOS) 。 ROM112还可以存 储日期和时间信息，以便即使在关机和重新启动之后信息仍保持不变。此 外，存储装置115可以为包括应用和数据文件的各种数据提供长期存储。 在一个示例中，处理器105可以从存储装置115检索应用并当应用正在执 行时将与应用关联的指令临时存储在RAM模块110中。</p>
    <p>计算机100可以通过各种组件和设备输出数据。如上所述， 一个此类 设备可以是显示器120。另一个输出设备可以包括诸如扬声器125之类的 音频输出设备。每个输出设备120和125都可以与诸如显示适配器l22和 音频适配器127之类的输出适配器关联，后者将处理器指令转换成相应的 音频和视频信号。除了输出系统以外，计算机100还可以从各种输入设备 (如键盘130、存储介质驱动器135和/或麦克风（未示出））接收和/接受 输入。与输出设备120和125&#8212;样，每个输入设备130和135都可以与适 配器140关联以便将输入转换成计算机可读/可识别的数据。在一个示例中， 通过麦克风（未示出）接收的语音输入可以被转换成数字格式并存储在数 据文件中。在一种或多种情况下，诸如介质驱动器135之类的设备可以用 作输入和输出设备两者，使得用户能够向/从存储介质（例如，DVD-R， CD-RW等）写入/读取数据。</p>
    <p>计算机100还可以包括一个或多个通信组件以便通过网络接收和发送 数据。各种类型的网络包括蜂窝网络、数字广播网、网际协议（IP)网络等。计算机100可以包括适于通过一个或多个这些网络通信的适配器。具 体地说，计算机100可以包括网络适配器150以便通过IP网络160(例如， 局域网、广域网或因特网）与一个或多个其他计算机或计算设备通信。在 一个示例中，适配器150可以帮助通过^^司或组织的网络160传输数据（如 电子邮件消息和/或金融数据）。在另一个示例中，适配器150可以帮助从 诸如因特网160的万维网传输或接收信息。适配器150可以包括与一种或 多种联网协议有关的一组或多组指令。例如，适配器150可以包括处理IP 网络分组的第 一组指令以及包括与处理蜂窝网络分组关联的第二组指令。 在一个或多个布置中，网络适配器150可以为计算机100提供无线网^ 入。</p>
    <p>本领域的技术人员将理解，诸如计算机100的计算设备可以包括各种</p>
    <p>其他组件并且不限于图1中描述的设备和系统。</p>
    <p>在描述^^共组件框架（CCF)的软件架构和接口细节之前，将给出初 始描述。CCF是一种可用于使一个或多个基于web的软件组件以及与这些 组件关联的容器之间的通信标准化的接口 。基于web的&#32068;件可以例如是简 单的HTML网页，或更复杂的基于web的对象，如Active X对象或Java 小应用程序。容器也可以是网页或基于web的父对象，但可以实际是在计 算机100上运行的桌面软件应用。作为一个示例，Reuter的Xtra桌面软 件应用可以被实现为用作启用CCF的容器。桌面应用CCF容器的一个潜 在优势涉及使得HTML组件能够展示与嵌入桌面容器内的本地组件的行 为类似的行为。这些所谓的"智能"本地组件通常由容器应用来定义，并 且因此容器通常是应用特定的。</p>
    <p>参考图2，其中示出了软件组件架构的框图。在图2中，容器应用210 的单个实例可以容纳许多不同的组件，包括一个或多个启用CCF的组件 (例如，组件240 )以及非CCF组件（其他对象250-280 )。如上所述， 其他对象250-280可以是本地的容器特定的组件，用于在容器内提供特定功能。在此示例中容器220可以是在容器应用210中运行的客户端应用对象，其实现CCF接口的容器方。容器220可以使用与应用210所容纳的所有其他组件250-280相同或类似的方式与容器应用210通信。</p>
    <p>与容器220通信的基于web的CCF组件240可以在因特网浏览器应用230 (如Microsoft Internet Explorer (IE )浏览器）的实例中运行。当然，可以使用其他浏览器应用。在此示例中浏览器230是可嵌入IE的对象的已嵌入副本。如以下详细说明的，由于组件240直接与CCF容器220通信，所以组件240无需依赖于任何特定品牌或配置的浏览器230。</p>
    <p>应指出的是，如果容器220容纳了多个CCF组件240，则其可能需要额外的专用存储装置和逻辑以便同时协调其与多个组件240的通信。完成此协调的一种方式是为每个包含的组件240维护CCF接口的一个单独实例。</p>
    <p>在与图2所示略为不同的配置中，多个CCF组件（如组件240)可以在同一浏览器对象230中运行。在此类配置中，在浏览器230中运行的父网页可以将自身向容器220呈现为单个组件，同时还支持CCF接口的容器方以便它可以将自身向多个内部CCF组件240呈现为容器。在容器与组件之间传递的对象和数据可以是由浏览器230实现的JavaScript解释器的本地对象和数据。例如，在Internet Explorer浏览器中，IE自动地将IDispatch对象和VARIANTS转换为本地JavaScript类型以及从本地JavaScript类型来转换IDispatch对象和VARIANTS。因此，可以实现CCF组件以利用此浏览器功能。</p>
    <p>如上所述，组件240无需依赖于任何特定品牌或配置的浏览器230。但是，在一种配置中，CCF容器220接口可以假设组件240位于MicrosoftInternet Explorer浏览器的实例中，更具体地说，位于可嵌入IE COM的对象的实例中。在此示例中，CCF组件240可以访问Internet Explorer特定的对象"window.external"以定位容器220。但是，如果组件240无法访问此对象，则它可能断定它没有"window.external"容器220，并且然后尝试定位浏览器（例如，HTML)容器220。为了定位浏览器容器220，组件240可以搜索全局JavaScript函数，这指示其没有浏览器容器220。备选地，组件240可以尝试首先访问浏览器容器220，然后再尝试访问"window.external"容器220。当然，使用其他用于定位和访问容器或组件的技术，容器220与组件240之间的CCF通信也是可能的，只要在两者之间至少存在某些通信路径即可。如果组件240无法建立与容器220的通信，则它仍然可以继续运行，尽管特定组件会提供简化的功能，这取决于组件240的类型和实施方式。</p>
    <p>还可以这样配置CCF接口：使用公知的技术，仅在容器220与组件240之间传递COM对象。这些COM对象可以实现IDispatch接口，并且传递具有VARIANT数据类型的数据。应指出的是，虽然"window.external"接口可能需要此COM/IDispatch通信，但是其他通信方法可能并不需要此通信。例如，浏览器容器220可以使用本地JavaScript对象和函数来实现上述接口。</p>
    <p>参考图3,其是示出容器220与组件240之间的通信的步骤的流程图。在步骤301，组件240启动容器220的注册函数，或所谓的握手函数。以</p>
    <p>下示出了可能的握手函数定义的一个示例：</p>
    <p>[id(l)] HRt:SULT registerWithCCFContainer(卩n〗iCCF* component Interface,卩nj BS丁R componentSessionXML，[out， retval〗ICCF** containerlnterface)</p>
    <p>在此示例中，通过新的组件240在CCF容器220上调用该函数。返回给组件240的非空值指示握手过程成功。此外，如果容器220在基于web的对象（例如，如图2所示在IE浏览器内运行的HTML容器）内运行，则registerWithCCFContainer握手函数在浏览器内可以是全局的。但是，如果容器220未在浏览器对象内运行，则替代地可以使用window.external.registerWithCCFContainer 来实现 registerWithCCF-Container函数。</p>
    <p>如上所示，registerWithCCFContainer函数允许启用CCF的组件240调用该函数以及启用CCF的容器220接收该调用以交换接口指针。此夕卜，</p>
    <p>12在处理此握手函数时，容器220可以例如通过解析componentSessionXML参数来确定在组件240上运行的CCF版本。在特定实施方式中，版本号可以包括三个由句点分隔的单独部分（例如，数字）。例如，容器220可以解析componentSessionXML参数来确定组件240正在运行CCF接口版本"3.4.5"。在此示例中，第一个数字（"3")代表只有当新的CCF实施方式与先前版本不兼容时才更改的主要版本。第二个数字（"4")代表指示CCF实施方式中与先前版本的向后兼容更改的次要版本。第三个数字("5")用于反映不改变CCF接口本身，但是修复程序错误或细化特定结构的含义的实施方式更改。如果容器220确定其自己的CCF实施方式不支持组件240所运行的CCF版本，则容器220可以只是通过向组件240返回空值来拒绝握手请求。</p>
    <p>在可能时，新版本的CCF接口可以被设计为向后兼容先前版本。为了在新版本的CCF容器和组件接口中更好地实现向后和未来兼容性，函数可以被设计为忽略任何意外的或未被识别的输入，因为此类输入很可能是与较近版本的CCF接口通信的结果。</p>
    <p>返回图3， 一旦成功完成握手函数，容器220就准备好接收来自组件240的CCF调用。因此，在步骤302，组件240通过调用在CCF容器接口内定义的函数来请求容器220上的功能。以下参考图4更详细地描述了可用的CCF函数调用。</p>
    <p>在步骤303，组件240向容器220发送"onLoad"事件。onLoad事件(其在以下详细说明）向容器220指示发出调用的组件240现在准备好接收CCF函数调用。因此，在步骤304,容器220可以调用CCF组件接口内定义的函数，同时继续接收和支持容器接口函数以便由组件240或容器220中的其他组件进行调用。然后，在步骤305，组件240向容器220发送"onUnload"事件，通过向容器220指示组件240将不再接受CCF调用来取消注册组件。虽然通常由组件240在其解构期间发送onUnload，但是组件240可以继续存在并随后尝试重新建立与容器220的通信。但是，在特定实施方式中，可能不允许组件240重用在步骤301中获得的容器接口指针。在此情况下，可能需要组件240再次请求容器的握手函数(registerWithCCFContainer),然后才能重新开始与组件240的通信。参考图4，其是示出CCF函数的执行的流程图。在步骤401，在CCF</p>
    <p>容器220处或者在启用CCF的组件240处接收函数调用。如上所述，CCF</p>
    <p>容器220可以支持在CCF容器接口内定义的一组函数，该组函数不同于由</p>
    <p>组件240支持的在CCF容器接口中定义的函数。</p>
    <p>在步骤402，接收方确定所述调用请求哪个CCF函数。在此示例中，</p>
    <p>容器220和组件240仅支持两个可能的CCF函数，即"GetData()"和"ProcessEventO"函数。尽管容器接口和组件接口可以定义一组相同的</p>
    <p>CCF函数，甚至所述CCF函数可以具有相同的函数定义（即，相同数量</p>
    <p>和数据类型的输入/输出参数），但是这并不意味着组件接口所支持的实际功能与容器接口所支持的实际功能相同。例如，在容器220和组件240支</p>
    <p>持多组不同的事件的情况下，CCF ProcessEvent()函数可以接受对应于事件名称的字符串输入参数。以下说明了潜在地由CCF容器接口和CCF组件接口支持的一 系列事件。通过以下接口定义例示了针对CCF接口实现此</p>
    <p>事件和数据检索功能的一种方式：</p>
    <p>interface ICCF : IDispatch</p>
    <p>HRESULT getData(</p>
    <p>[in] ICCFObj* requestObj,〖out， retval〗BSTR* result);[id(2)〗HRESULT p瞎ssEvent(</p>
    <p>[in] ICCFObj* eventObj,</p>
    <p>jout， mvall VARIANT&#8212;BOOL* result);</p>
    <p>interface ICCFObj : IDispatch</p>
    <p>[propg化即）]HRESULT&#32048;e(</p>
    <p>〖加t, retval] BSTR* value);[propgedd(2)] HRESULT xmiData(</p>
    <p>[out' retval] BSTR* value);</p>
    <p>在此示例中，ICCF对象支持getData或processEvent函数。如函数定义中所示，指向ICCFObj的指针是两个ICCF方法都需要的输入参数。作为参数传递的所引用的ICCFObj包含与（processEvent函数）发送的事件或（getData事件）请求的数据对应的'name'字符串（例如，BSTR)。所引用的ICCFObj还包含'xmldata，字符串，以便以XML文档的形式提供附加的信息，容器220或&#32068;件240可以解析和使用该XML文档以处理所述事件和请求。</p>
    <p>许多不同配置的事件和可检索数据是可能的，并且下一节中详细讨论了某些类似的事件和请求名称。但是应指出的是，在特定配置中，与CCF函数调用一起传递的ICCFObj中的名称标识符永远不能为空值。也就是说，任何在未指定事件名称或所请求数据的情况下的请求数据或发送事件的尝试都会导致将错误返回给调用方。相比之下，xmldata标识符可能经常为空值，因为许多事件或数据请求不需要附加的数据来使CCF容器220或&#32068;件240成功处理所述事件或请求。</p>
    <p>因此，在步骤403，无论函数调用为何，接收调用的CCF对象都解析名称和xmldata参数，以^f更能够处理期望的事件或数据请求。在步骤404，执行所请求的功能，并且在步骤405，函数返回值和/或数据被发送回函数调用方。</p>
    <p>如以上参考图3和4所述，容器220和组件240可以通过经由它们相应的CCF接口发送事件并做出数据请求来进行交互。当做出这些事件和/或数据请求时，可以在由CCF模式文件专门定义的复杂定制数据类型（例如，信息类型）中传递数据。CCF模式文件通常被实现为XML文档（例如，XML模式定义（XSD)文件）并且与实现CCF容器和组件功能的JavaScript文件一起^L下载到计算机100。如公知的，XSD文件能够根据XML元素和属性连同元素和属性可存储何种数据值和类型的约束一起来定义信息类型。类似于其他XML文档，XSD可由接收的软件组件来解析并用于填充适当类型的对象实例。</p>
    <p>以下包括了定义信息类型的样例XSD文件。在此示例中，由ContextData.XSD文件完整地描述ContextData信息。由xs: complexType元素的"name"属性来指定类型名称，并且由此xs: complexType标签中包含的内容来定义类型的结构。因此，在以下示例中：</p>
    <p>&lt;/xsxomplexType&gt;</p>
    <p>省略号代表ContextData类型的结构，其可以包括诸如数字或字符串的简单数据类型的集合，并且还可以包括更复杂的嵌入数据类型。在以下的ContextData.XSD文件中可以看到，contextdata类型包括一系列实体对象(由〈xs:sequence maxOccurs= "unbounded" &gt;标签内的〈xs:element ref="Entity" &gt;标签表示），以及可选的名为searchID的字符串属性（由&lt;xs:attribute name= "searchID" type= "xs:string" use= "optional" &gt;标签表示）。在ContextData.XSD文件的更下方，以类似方式定义了实体对象类型。因此，从发送方接收XML数据的软件组件可以解析该XML以确定其代表类型为"contextdata"的对象，然后访问ContextData.XSD文件以验证所接收的数据，构造contextdata软件对象，并且使用从XML文件解析的值来填充该对象。</p>
    <p>在此处描述的许多可能的CCF事件和数据请求中，"ContextData"数据类型的实例是在CCF容器和组件之间最频繁地传递的信息。在其最简单的形式中，ContextData实例可以通过存储单个实体（例如，诸如公司、股票、债券、市场、国家等的金融实体）的一个或多个标识符（例如，RIC、CUSIP、 ISIN等）来描述该实体。在其他情况下，ContextData的实例可以保存更复杂的数据以表示与主要实体关联的字段（即，名称-值对）和/或子实体对象。ContextData实例还可以包括一系列实体，它们或者存储为平铺列表或者存储为实体的分层树结构。</p>
    <p>当组件240在容器220中运行时，&#32068;件240通常具有主要上下文，可以根据组件240的用户接口内呈现的数据的焦点来设置此主要上下文。当组件240的用户例如通过单击组件用户接口中的不同实体项而设置新的焦点时，组件240应相应地更新其主要上下文，从而允许容器220获得当前上下文并且与其他组件同步显示/活动。除了只是维护其自己的主要上下文</p>
    <p>16以外，组件240还可以以用户鼠标单击、双击、拖动或右击以便进行上下文菜单选择的形式向容器220输出附加上下文。容器220可以使用这些附加上下文来向其他组件提供输入。</p>
    <p>&lt;formula&gt;formula see original document page 17&lt;/formula&gt;"s:加加tMi加〉</p>
    <p>&lt; xs :doc , entatkm&gt;</p>
    <p>Thi?i document defines schema for the XML instance i.bai is created by thecompcm《nt/s lo rK)Ufy lhe container and the ocml迈iner to notify lhe components U&gt; indicate a context change</p>
    <p>&lt;xs:element name，化Entities" typcyConlcxtData" /&gt;&lt;xs:cornplexType name^'ConteTdData'')</p>
    <p>&lt;xs:scquence maxOcc;urs=''unbciuiided"&gt;&lt;xs:c:leme.rH rf'EmH/' /&gt;</p>
    <p>&lt;/xs:sequence&gt;</p>
    <p>&lt;xs:attrib* nam『"searciiID'' typ『"xs:string" use^"丰iorm[V&lt;xs:annotaUon&gt;</p>
    <p>&lt;p)Th(s attribute is oriiy used in conjunction 、vith asynehronoustX)mponem in^EUecl search (tha【requested whh a getData(，'search"， &amp;U;Se.archTm'gei&amp;gt;)).&lt;/p&gt;</p>
    <p>lf the container chooses lo return the search resuttsasynduomxjsly, it will return an "Entities" deniem wi〖h this aUdbute Hlkd with a unique kkntifier, and willret匿NO "Entity1' e(ements. When Uk search iscompleu:， it vv川return (in the "onSearchResuks" event) an"etu"ies" e化m抓with Lhe SAM&#163; ideruifk" and 、vi" include a【l of the "Kn&#8212;" elements representing the resu〗tof the search.&lt;/p&gt;</p>
    <p>&lt;Zxs:docimientaUon&gt;&lt;/xs:iinr&#187;&lt;M3Uon&gt;</p>
    <p>&lt;xs:dcrnerU rtatnt^"EnU【y"〉</p>
    <p>&lt;xs: docu m t: nla t ion 〉</p>
    <p>This dement represents a business enUty such as a business sector,c'o'npany/issuer, Irisu'画erU'Quoie， etc. &lt;/p&gt;</p>
    <p>&lt;xs: com plexTy pe&gt;</p>
    <p>&lt;xs:dement ref--F"dcmifief" rninO"ursyQ'， maxOccurs^"unboundecT /&gt;&lt;xs:ekmem rdWri&#163;mit》'"minOccurs""0" maxOccurs="unbcmnded" /&gt;</p>
    <p>〈xs:atthbute name="datasourcefl type，"xs:string" use?optitina!" /&gt;</p>
    <p>&lt;xs: docu me nUU [on&gt;</p>
    <p>This dement represent a field name/v由e pair and assodateddats&#27512;ce if any such as iDN， NDA, &#163;JV&lt;7p&gt;&lt;xs:a〖tribute n&#32048;e-"oame" type^'x^string"&#35469;一'requitt:d" &lt;/xs :eom p kxTy pe&gt;</p>
    <p>&lt;xs:annotalion&gt;</p>
    <p>&lt;xs: docu rnenta"on&gt;</p>
    <p>TOs element represents seeurife symbology rmniespace: R!C， SEDOL，</p>
    <p>&#163;JV,&#33126;，etc.&lt;/p&gt;</p>
    <p>&lt;/  :doctJ n，entation&gt; &lt;xs: c ompl ex丁ype m i xed菜"true"&gt; &lt;/xs:compJexT)'pc&gt;</p>
    <p>&lt;/xs;sehema&gt;</p>
    <p>与容器-组件CCF通信兼容的信息类型的若干附加示例3皮披露为XSD 文件并在以下附录中进行了描述。</p>
    <p>如上所述， 一旦容器220和组件240交换了 CCF接口指针，它们就可 以通过相应的接口进行交互。此交互可以采取彼此之间发送的事件和请求 的形式，如以上在图4中所示。以下章节提供了与可以包括在CCF接口中 的特定事件和数据请求有关的信息。虽然可以以两个方向（即，容器接口 和组件接口两者）实现一组相同的事件和数据请求，但是可以存在其他仅 在一个方向实现的事件和/或数据请求。例如，可以将组件至容器事件作为 组件240的当前状态的指示发送到其容器220，同时并不支持容器至组件 事件。以下的许多组件至容器事件通过组件中的某些用户操作来触发。</p>
    <p>组件至容器事件的示例</p>
    <p>1. onLoad -在此示例中，onLoad事件是在握手函数之后第一个发 送到容器220的事件。此事件指示组件240现在已初始化并准备好从容器 220接收事件和请求。与此事件一起发送的数据是组件240的描述，其作 为XML文档&#31056;发送到容器220。</p>
    <p>2. onUnload - onUnload事件是从组件240的实例发送到容器220的 最后一个事件。随此事件没有发送数据。在processEvent函数调用返回此事件后，组件240将不再从容器220接受事件和请求。但是，容器220可 以在正在处理此事件时向组件240发送请求和/或事件。</p>
    <p>3. onClick - onClick事件通知容器220在组件240的用户接口上发生 用户鼠标单击操作。此事件是组件240向其他组件提供数据链接（即，组 件240的输出被用作其他组件的输入）的机制，如果容器240希望使用此 数据用于数据链接的话。此事件的数据描述了用户单击的组件（例如，用 户接口控件按钮、下拉菜单等）内的实体，并且可以采取如以上在 ContextData.XSD文件中定义的ContextData实例的形式。</p>
    <p>4. onDoubleClick-onDoubleClick事件类似于onClick事件，但是通 知容器220用户在组件240的用户接口上进行了双击。</p>
    <p>5. onContextDragStart - onContextDragStart事件通知容器220用户 正在试图拖动组件240中显示的某些实体。与onCliek事件相似，此事件 的数据也可以是描述了用户正在拖动的实体（例如，描述实体上下文）的 ContextData数据结构。类似于onClick事件，此事件可用于将来自组件 240的数据输出提供给其他组件。</p>
    <p>6. onComponentDragStart &#8212; onComponentDragStart事件由组件240 发送以通知容器220用户正在试图拖动整个组件。此组件可以是组件240， 也可以是其他组件（例如，组件240的子显示）。例如，通过显示拖动"句 柄，，以便用户在用户接口上单击并拖动，某些组件可以支持拖动。此事件 提供了描述组件的当前状态的数据结构，并且可由容器220使用以在容器 220内的其他位置处克隆组件240。</p>
    <p>7. onContextMenu &#8212; onContextMenu事件通知容器220用户在组件 240内进行了右击。在接收到此事件后，容器220可以通过在组件240用 户接口上显示其上下文来做出响应。此事件可以提供诸如右击位置的屏幕 相对坐标之类的数据，以及指示组件240希望添加到上下文菜单的菜单选 项的信息。此外，如果用户在用户接口实体上进行右击，则可以随所述事 件一起发送描述该实体的数据。</p>
    <p>8. onUpdateCommandBars -可以发送onUpdateCommandBars事件以响应用户操作。事件数据描述了上下文菜单、工具栏和/或服务菜单。使</p>
    <p>用此事件，组件240可以在组件240正在运行时定制这些菜单或工具栏。 例如，组件240可以在onUpdateCommandBars事件中提供新的值以替换 在onContextMenu事件中指定的值。</p>
    <p>9. onContextChange - onContextChange事件通知容器220组件240 最近已更改了其主要焦点。事件数据描述了新的上下文。</p>
    <p>10. onProperyChange - onProperyChange事件通知容器220 &#8212;个或 多个其属性的值已更改。此事件的数据描述了已更改的属性并且可以包括</p>
    <p>新的值。</p>
    <p>11. onP叩up -当容器220希望在组件240的用户接口上创建启用 CCF的弹出窗口时，容器220将onPopup事件发送到&#32068;件。容器220随 事件一起发送的数据可以对应于弹出窗口的优选大小和位置。所述数据还 可以包含要载入弹出窗口的CCF组件240的描述。</p>
    <p>12. onLog -组件240发送onLog事件以请求容器220的日志文件中 的表项（如果有）。组件240可以使用此事件来记录组件的重要的意外事 件（例如，错误发生、用户事务等）。事件数据包^^要记录的消息的文本 和严重度（例如，关键、高、警告、信息、调试等）。某些记录的消息可 以被本地化以便为用户提供额外的便利，如果用户要阅读这些消息以便例 如调试CCF组件240中的4&#26185;误的话。</p>
    <p>组件至容器数据请求的示例</p>
    <p>1. persistdata -例如，当容器220从保存的副本、组件放置、组件粘 贴或响应于onPopup事件而创建组件240时，可以4吏用persistdata数据请 求。组件240不随此数据请求发送任何数据。此请求的返回值可以包括组 件恢复其状态所需的组件240的所有状态信息。例如，组件MO可以在成 功的握手函数调用之后，但是在发送onLoad之前做出此请求。容器220 可以在组件240的整个生命周期中保存此状态数据的副本。</p>
    <p>2. search -组件240可以发送search数据请求以使容器220代表&#32068;件240执行搜索。随此请求提供的数据描述了要执行的搜索。 容器至组件事件的示例</p>
    <p>以下是容器220可以在上述的onLoad与onUnload事件之间发送到组 件240的事件的示例。</p>
    <p>1. onContextChange - onContextChange事件向组件240的实例提供 由其容器220发送的上下文。如果随事件一起传递的上下文数据不匹配组 件240的当前现有的上下文信息，则此事件可用作组件240上的相应地更 改其上下文的请求。所述事件可以与其他启用CCF的组件一起产生，并且 可以通过容器220被传送到预定组件240而无需由容器220进行转换。在 其他onContextChange事件调用中，容器220可能需要先转换上下文，然 后才能将其发送到&#32068;件240，或者它可以使用未知类型的标识符构造上下 文并仍然将该标识符传递给组件240以便解释该标识符。</p>
    <p>2. onProperyChange - onProperyChange事件允许容器220更改组件 240的一个或多个属性值。可以随此事件一赴良送与要更改的属性对应的 数据。组件240可以被配置为忽略容器220更改组件240的只读属性或不 存在属性的尝试。</p>
    <p>3. onCommand -容器220发送onCommand事件以通知组件240用 户已从菜单或工具栏（例如，Reuters工具栏、服务菜单或上下文菜单）进 行了选择。随此事件一起提供的数据描述了用户选择。</p>
    <p>容器至组件数据请求的示例</p>
    <p>1. context-容器220可以使用context数据请求来检索组件240的当 前上下文。随此数据请求没有提供数据。容器220可以在组件启动期间使 用此信息以便将组件240与容器220可能同时显示的其他组件进行同步。</p>
    <p>2. description &#8212; description数据请求将组件240的描述返回给容器 220。其可以是在组件240发送的onLoad事件中传递的同一描述。因此， 如果容器220未&#32233;存此值，则容器220可以使用此数据请求获取此值。3. persistdata &#8212; persistdata数据请求允许容器220检索组件240的当 前状态的副本。当用户希望保存组件240时可以使用persistdata数据请求。</p>
    <p>4. properties -容器220发送properties数据请求以检索组件240的 所有属性的当前值。</p>
    <p>5. helpurl-在实现容器级用户帮助功能时，helpurl数据请求返回帮 助统一资源定位符（URL)的副本以便为容器220提供方便。</p>
    <p>6. inputowner &#8212; inputowner数据请求返回字符串 "component"或 "container"，并由容器220用于控制用户输入。只要输入焦点在组件240</p>
    <p>内的用户接口控件上，该值就被设置为"component",在所有其他时间 将被设置为"container"。容器220可以使用此值来确定是自身处理用户 输入（例如，键盘和菜单输入），还是继续传递该用户输入以便由组件240 处理。</p>
    <p>应指出的是，上述用于容器和组件两者的CCF功能可以被实现为以脚 本编制语言（例如，Netscape JavaScript)编写的可以净皮嵌入网页并由浏 览器230执行的客户端方框架。在此类实施方式中，需要随每个组件包括 CCF JavaScript文件。但是，组件创建者也可以潜在地使用其他技术（例 如，Microsoft Visual Basic)来实现JavaScript事件转发和应用编程接口 (API)。此外，组件创建者可以以JavaScript实现其自己的接口。</p>
    <p>现在参考图5和6，它们是示出可以使用用于组件-容器通信的上述启 用CCF的函数来支持的用户功能的示例。</p>
    <p>在图5中，在组件用户接口显示窗格510中显示了启用CCF的股票跟 踪器&#32068;件240。同时，配置为显示新闻标题的另一组件241在同一容器220 中运行并显示在临近组件240的浏览器上。在此示例中，容器是Reuter 的3000Xtra容器应用的一个实例，而股票跟踪器组件240是3000Xtra报 价对象。如图5所示，组件241的显示窗格520是空的，因为未选择要显 示新闻的目标公司。换言之，&#32068;件241正在运行，但是没有当前上下文。 同样如图5所示，股票跟踪器组件240的当前上下文是"IBM.N",其对 应于IBM^^司。</p>
    <p>22在此示例中，股票跟踪器组件240是通过使用上述 onContextDragStart事件来支持上下文拖放的启用CCF的组件。因此，用 户可以单击显示窗格510中的高亮的"IBM.N"行，将其拖出当前组件240 并;^UV相邻组件241的显示窗格520中，如图5所示。当用户拖动组件240 内的实体时，可以将被拖动的实体作为输出发送到容器220，使得容器220 可以存储上下文并在放置实体时使用该上下文。</p>
    <p>当用户将实体放置在不同的启用CCF的组件241上时，新的上下文被 从容器220传递到目标组件241。作为响应，组件241将采取必要的（通 常是组件特定的）操作来更改其主要上下文以匹配容器220提供的新的上 下文。如果新的上下文使用另一启用CCF的组件产生（如此示例中那样）， 则事件通常将传递上下文而不做更改。但是，如果新的上下文来自其他来 源，例如非启用CCF的组件，则容器220会尝试将输入转换成适合的上下 文。容器220可以尝试自己将所提供的输入转换成上下文数据（例如，使 用搜索功能），或者可以只是将来自非启用CCF的组件的具有未知类型标 识符的上下文传递给目标组件，以期目标组件理解该上下文。</p>
    <p>在此示例中，由于源组件240和目标组件241都启用了 CCF，所以上 下文传递过程可以相当简单。目标组件241可以向容器220描述其可以接 受的上下文数据的类型，例如，使用随onLoad事件一起传递的描述数据。 如果是这样，则容器220可以与组件24进行协调以便获取目标组件2" 的正确类型的上下文。此外，如果需要，容器220可以将上下文转换成目 标组件241可以接受的形式和数据类型。</p>
    <p>现在参考图6，新的上下文已被传递到新闻标题组件241，并且调用组 件特定的功能以响应该新的上下文，从而更新显示窗格520以显示与IBM 相关的新的事件。</p>
    <p>现在参考图7和8，它们是示出可以通过^f吏用启用CCF的组件和容器 来支持的用户功能的其他示例。在图7中，启用CCF的组件2邾被实现为 显示与用户选择的发布者关联的评级数据。当用户从组件240内的下拉用 户接口控件输入或选择发布者名称（例如，General Motors )时，组件240检索关联的评级数据并将其显示在显示窗格730中。组件240的此基本功 能可以完全是组件240的内部功能并且可以在没有与容器220的交互的情 况下发生。但是，除了组件240实现的基本功能和用户接口控件之外，还 将使用Microsoft Excel图标720定制的标准工具栏710结合到组件240中。 Excel图标720指示启用CCF的组件240支持将来自组件显示窗格730的 数据导出到Excel电子表格。在此示例中，组件240可以向容器220指示 要在工具栏720上显示Excel图标720，方法是在随onLoad事件发送到容 器220的描述中传递此信息（甚至可能传递图标720本身）。</p>
    <p>当用户在显示窗格730中的评级数据的情况下单击图标720时，新的 Microsoft Excel应用窗口 241被实例化并显示给用户，如图8所示。在此 示例中，在检测到用户单击之后，容器220可以向组件240发送 onCommand事件，指示单击了 Excel图标720。在接收到此事件后，组件 240可以向远程数据服务器发送请求以检索与显示窗格730中的评级数据 对应的Excel工作表，然后使用现有的IE功能在新的弹出窗口 241中启动 具有该工作表的Excel的实例。因此，在此示例中，容器2M只是向组件 240提供选择工具栏项或菜单选项的通知，然后允许组件处理该选择而没 有任何进一步的容器-组件通信。当然，在其他组件-容器实施方式中，两 者之间的通信可以继续支持用于数据检索、呈现等的不同技术。例如，使 用CCF通信，容器-组件可以协调容器内新的组件的创建，并且使用从远 程服务器检索的数据来填充该新的组件，或者直接使用组件显示窗格730 中的数据来填充该新的组件。</p>
    <p>此外，容器220可以创建新的组件并建立组件间的直接组件至组件通 信。例如，组件可以作为随onPopup或onComponentDragStart事件发送 的persistData的一部分向同一容器内运行的另 一组件传递任意数据，。 在其他实施方式中， 一个组件可以包含另一组件并且两者可以相互同意扩 展CCF接口以提供它们自己的私有数据格式的事件。</p>
    <p>除了图7-8所示的导出到Excel功能以外，启用CCF的&#32068;件和容器能 够支持若干不同的用户交互特性。以下包括了列出这些潜在特性中的某些特性的表:</p>
    <p>&lt;table&gt;table see original document page 25&lt;/column&gt;&lt;/row&gt;
&lt;table&gt;</p>
    <p>现在参考图9，其中示出了与CCF容器220内运行的启用CCF的组 件240的用户交互（涉及维护和传送属性值）的另一变型。如上所述，组 件240可以向其容器220提供属性信息并且反之亦然，这允许容器220根 据组件240所支持的用户功能来定制标题栏910、工具栏920以及菜单930。 当然，组件240所支持的属性的属性名称、值、类型和访问许可取决于特 定的组件240。但是，在特定实施例中，需要组件240维护一组预定的最 小属性。例如，在图9中，组件240在Reuter的3000Xtra容器220中运 行，并需要向容器220暴露至少三个属性。首先，"Title"属性是容器220 用于设置标题栏910中的标签的只读（即，只能由组件240自身设置）字 符串值。在此示例中，组件240设置了标题"Issue Information"，使得容器220能够检索该值并相应地更新标题栏910。第二个属性"HelpURL" 是由组件240设置并由容器220检索的另一个只读属性。如果HelpURL 属性具有非空值，则容器220可以提供到所提供URL的链接（例如，作 为工具栏920上的帮助按钮或帮助菜单项），该链接将用户重定向到组件 240提供的帮助内容。因此，可以在容器220的菜单和工具栏内提供组件 特定的用户帮助。在此示例中的第三个所需属性是布尔型"SelectorVisible" 属性。SelectorVisible属性由容器220 i殳置以响应用户选择容器菜单930 内的Show Component Handles项940。当此属性被设置为TRUE时，组 件240将暴露其句柄，在组件240可供拖动的情况下，将允许用户选择并 拖动容器220内的组件240。因此，可以由容器220、组件240或两者:&amp;置 特定属性以便在容器220的框架内提供组件特定的支持，这向用户提供了 更加无缝和一致的体验。</p>
    <p>在一种布置中，支持在组件软件对象和软件容器对象之间进行电子通 信的方法，类似于以上参考图3和4所述的技术。所述方法可以包括在容 器对象220上启动注册函数，向所述函数传递与容器对象220内的组件对 象240支持的通用组件接口对应的第一接口指针。所述方法还包括从容器 220接收与容器220支持的通用容器接口对应的第二接口指针，其中所述 第一和所述第二接口支持用于组件240和容器220之间的一般通信的一组 预定函数。所述方法还包括在组件240内运行的用户接口控件上接收用户 输入，确定所述容器接口支持的与所接收的用户输入关联的函数，以及使 用所述第二接口指针在所述容器接口中调用所述函数。在特定实施例中， 容器220和第一组件240可以在浏览器应用230的实例中执行。此外，所 述方法可以包括经由所述第二接口从容器220接收包括实体标识符的组件 上下文数据。所述实体标识符可以与诸如公司、股票、债券、市场或国家 的金融实体关联。此外，所述方法可以包括响应于从容器220接收所述组 件上下文数据，根据所述组件上下文数据从远程数据存储区检索数据，使 用所检索的数据执行组件特定的功能，以及根据所执行的组件特定的功能 更新组件240的用户接口 。</p>
    <p>26在另一种布置中，提供了在多个组件软件对象240和241以及容器软 件对象220之间进行电子通信的第二方法，类似于以上参考图5所述的技 术。所述第二方法包括将第一接口指针从容器220传送到第一组件240， 所述第 一接口指针定义了关于第 一组件240的由容器240支持的多个函数， 以及在容器240处接收来自第二组件对象的第二接口指针，所述第二接口 指针定义了关于容器240的由第二组件241支持的多个函数。所述方法还 可以包括经由所述第 一接口接收第 一用户操作已在第 一组件240内发生的 指示，所述指示包括组件上下文数据，检测与第二组件241关联的第二用 户操作，以及经由所述第二接口将所述组件上下文数据传送到第二组件 241。</p>
    <p>所述第二方法还可以包括启动所述组件上下文数据是否与第二组件 241兼容，以及如果所述组件上下文数据与所述第二组件不兼容，则根据 所存储的描述第二组件241的信息来转换所述组件上下文数据。在特定实 施例中，所述第一用户操作可以对应于从第一组件240 (如7&gt;司、股票、 债券、市场或国家）内的用户接口选择实体。所述第一用户操作还可以对 应于与第一组件240内的用户接口中的实体关联的拖动事件，或与所述实 体关联的放下事件，所述放下事件在第二组件241内的用户接口上发生。 此外，所述第一用户操作可以指定第一组件240的用户接口内的一个或多 个数据字段，并且所述第二用户操作可以对应于将所指定的数据字段放入 第二组件241的用户接口的放下事件。所述第一或第二用户^^作还可以对 应于将所选择的数据字段导出到电子表格软件应用的用户命令。在一个实 施例中，容器220以及第一组件240可以在浏览器应用230的实例中执行。</p>
    <p>在此描述的方法、模型和架构的各个方面可以以计算机可读指令的形 式存储在计算机可读介质中。计算机可读介质的类型可以包括磁带驱动器、 光存储装置、闪存盘、随机存取存储器（RAM)、只读存储器（ROM) 等。此外，在此描述的方法、模型和架构的各方面也可以与其他行业和应 用 一起4吏用。</p>
    <p>根据本发明的优选和示例性实施例描述了本发明。通过回顾本公开，本领域技术人员将想到在所附权利要求的范围和精神之内的大量其他实施 例、修改和变型。</p>
    <p>附录</p>
    <p>以上详细说明了 ContextData信息类型并且其在先前披露的 ContextData.XSD模式文件中定义。但是，使用在此披露的CCF接口和其 他方面的容器-组件通信并不限于在容器与组件之间传递ContextData。可 以传送许多其他信息类型，现在说明这些类型的几个示例并将其公开为此 附录中的XSD文件。例如，以下的Properties.XSD文件定义了 "Properties" 信息类型的才莫式，其对应于组件240响应于容器220的属性请求而创建和 发送到容器220的XML实例。</p>
    <p>Properties，XSD</p>
    <p>&lt;〖"edked by -、&gt;</p>
    <p>&lt;xs:schemaxrnlns:&gt;i;^l1http:〃www,vvO,org/2(KH/XMLScht;ma" w"lnsyhUp:〃vnvw.namespaceserv'er.com/cc广 targetNamesp-aces''hUp:〃www,rvamespaccserver,com/c.cr elemenformDefault:"quaiifiW wsicm=，'2,0n&gt;</p>
    <p>&lt;xs:documeniaticm〉</p>
    <p>This docu舰ru defines sehen，a for the XML insu匿e that is created by lhe cc)mpcment/s when properties are requested by 〔he container&lt;yp〉 &lt;/,、s: docum erttaii加&gt;</p>
    <p>&lt;x,s:complexType&gt; &lt;xs:c.hoic.e&gt;</p>
    <p>&lt;xs:elemem Property" minOcd'， maxOcxu「？"unbounci&lt;xr&gt;</p>
    <p>&lt;xs:dociiniemaUon&gt;Bhitls a value to a name. Aiso provides addition^ type arid acc咖trol infbrrm"ion,&lt;/xs:doc,urnerua[ion&gt;</p>
    <p>&lt;/.、's:annotalion&gt;</p>
    <p>&lt;xs:eomp〗exType rnixed^"true"&gt;</p>
    <p>^xs:&#20489;ibute nam&#8212;'name"</p>
    <p>typero"xs:s.uing"use=;"r，ired''&gt;</p>
    <p>&lt;x_s:documen【ation&gt;Specifies the</p>
    <p>properly name,&lt;/xs:docume-ntaticm&gt;</p>
    <p>々xs加nota〖ion》 &lt;/xs:aUribute&gt;&lt;formula&gt;formula see original document page 29&lt;/formula&gt;以下的SearchTarget.XSD文件定义了用于将变元提供给搜索引擎的 "SearchTarget"信息类型以及要应用于搜索结果的变换。SearchTarget 数据帮助容器220 (其支持至少一个指定的搜索引擎）搜索组件220的输 入。</p>
    <p>&lt;!&#8212;cdiwd    &#8212;:'</p>
    <p>《X5:Selwmaxm【nS..xSs;:"ht1fW',Vw%v-v*J,&#171;rp'2CI0l,&gt;CMLSi;hei?ur &gt;:[71』&#12316;一'11&#171;^/''^&#171;1^'.。遂^|^|&gt;^5《1^^'0)^1,'&#163;&lt;^'</p>
    <p>■Oes'clement, ranfic' Scarc?H Vg"'、</p>
    <p>&lt;xs:&gt;dc&#187;cuniCTratioR&gt;Co,c&#171;u dcscftoia容 &gt;&#22894;r鹏dctftjc傲々":teuntensaii加》</p>
    <p>々'XS:,&#34899;1i惯》 given; &lt;As:《lo"Jn,;ilior^</p>
    <p>《、s:cUjt娜鹏f IMsRitiW</p>
    <p>wr》rd: ['rsg;na' toiU.akL iXa'.i:iKTt 、Vx、&#19972;u:Li【化nUU":^'</p>
    <p>t-xs:anrK、鹏i!&#28149;》</p>
    <p>《L、：o:!niiScx〗'Ypi^〉</p>
    <p>、':、^: s i i n p I 。二 a n</p>
    <p>ji;i!v.-"'&#8212; r。im'</p>
    <p>XSI,T Lr,rw,m;i:'n〖im ihc !</p>
    <p>j OCT "mtc:、'《！■</p>
    <p>'二xvdo^nrr,!mi;id加浙c!、.idra a 3 iJix^ufH 、-.'、s:dc'd'.nlai'io''::'</p>
    <p>、，'x，,:a.nn。Ui1":m:' 《":c、'柳pies Ty|je&gt;</p>
    <p>《&amp;iS:判ui;r'" n， inOc《ud'</p>
    <p>々'.":S叫固oe》 ;.议膨tee嫌f uf 'rt，i n^'〉々&#20034; s:&#40786;i一 (K. l'y^e&gt;</p>
    <p>以下的Description.XSD文件定义了由容器220创建以允许容器220 访问组件240所支持的功能的XML实例的模式。</p>
    <p>(、;rn! vmkm&#12316;'！,i:". c"iC0ding，"01卩-W ') 々"diicd ti》'</p>
    <p>l&#171;rg^.Niin，csp"Gt""!'.tmp:''&gt;\v/wvv.mime!ip&#163;ii:dnr.':';jm/i&gt;:cr" ukmLnF':i:ri'4)efaLl;&#8212;''qi^WwiT</p>
    <p>、im':。n&#8212;。W&gt;</p>
    <p>《Wiinn^it3t:i、"irr:.</p>
    <p>，This ctosifeers '扭flrw;s w-henvi for !hf XM L ，,ftce 1h站;s er糊cd by "imfi&#171;)L'nL''s m ailow【:nr,"im," W q"《ry ['npiih「l'ii'4's suppled b&gt; t'ic ccsmporie&#187;、K''|i》 '-7 xs:;kn;um  w t i '， r)</p>
    <p>^rlHrrn;U.ui;mi'.:fn".''CJ':inkiy.U&gt;^l;i-、;id' '*&gt; ;^el^;irrLU.ut;;L:K!n:"''&gt;ie;sr[:hT;ir[^^.w:r ':-xs .cwpk" ,、'(X'..&#8212;--</p>
    <p>&lt;，"S,n-ar)&#8212;》</p>
    <p>&#12316;'x 3&#8212;b r, b; u加》</p>
    <p>re、lrii:."i;ici bir":-'':".、l"i&lt; ，'〉</p>
    <p>"-Tw、to 一》</p>
    <p>um:aa，" fo, A CO! Icct柳?r";um、卩0f [W cr&#8212;1i"pcW.'、s-dn:.i:5r&#19972;'n::!宾i':in:' 、：！一Scf"OC M-SR、1</p>
    <p>^&#8226;x5:do&#171;jrnenuitii-in:''rhi:s der?ie"【de""bcs l卜'f service</p>
    <p>menu     【k GORlpc:'Tien!;':/;w,dc《'iini[x"ii'^fi，'&lt;formula&gt;formula see original document page 32&lt;/formula&gt;最后，UpdateCommandBars,XSD文件定义了由组件240创建的XML 实例的模式，其将在组件240需要更新或修改当前在容器220中显示的工 具栏、服务菜单和/或上下文菜单时被发送到容器220。在特定实施例中， 组件可能只有修改容器220内其自己的组件特定的菜单的权限。</p>
    <p>.&lt;formula&gt;formula see original document page 32&lt;/formula&gt;</p>
  </div>
  </div></div><div class="patent-section patent-tabular-section"><a id="forward-citations"></a><div class="patent-section-header"><span class="patent-section-title"> 被以下专利引用</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">引用专利</th><th class="patent-data-table-th"> 申请日期</th><th class="patent-data-table-th">公开日</th><th class="patent-data-table-th"> 申请人</th><th class="patent-data-table-th">专利名</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN101908078A?cl=zh">CN101908078A</a><span class='patent-tooltip-anchor' data-tooltip-text="由审查员引用"> *</span></td><td class="patent-data-table-td patent-date-value">2010年8月30日</td><td class="patent-data-table-td patent-date-value">2010年12月8日</td><td class="patent-data-table-td ">深圳市五巨科技有限公司</td><td class="patent-data-table-td ">一种将网页数据导入excel表格的方法和装置</td></tr></table><div class="patent-section-footer">* 由审查员引用</div></div><div class="patent-section patent-tabular-section"><a id="classifications"></a><div class="patent-section-header"><span class="patent-section-title">分类</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> </th><th class="patent-data-table-th"> </th></tr></thead><tr><td class="patent-data-table-td ">国际分类号</td><td class="patent-data-table-td "><span class="nested-value"><a href="https://www.google.com/url?id=FxNtBwABERAJ&amp;q=http://web2.wipo.int/ipcpub/&amp;usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&amp;notion=scheme&amp;version=20130101&amp;symbol=G06F0009460000">G06F9/46</a></span></td></tr><tr><td class="patent-data-table-td "> 合作分类</td><td class="patent-data-table-td "><span class="nested-value"><a href="https://www.google.com/url?id=FxNtBwABERAJ&amp;q=http://worldwide.espacenet.com/classification&amp;usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06F3/0486">G06F3/0486</a></span>, <span class="nested-value"><a href="https://www.google.com/url?id=FxNtBwABERAJ&amp;q=http://worldwide.espacenet.com/classification&amp;usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06F9/543">G06F9/543</a></span></td></tr><tr><td class="patent-data-table-td "> 欧洲专利分类号</td><td class="patent-data-table-td "><span class="nested-value">G06F9/54C</span>, <span class="nested-value">G06F3/0486</span></td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="legal-events"></a><div class="patent-section-header"><span class="patent-section-title">法律事件</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> 日期</th><th class="patent-data-table-th">代码</th><th class="patent-data-table-th">事件</th><th class="patent-data-table-th">说明</th></tr></thead><tr><td class="patent-data-table-td patent-date-value">2009年9月9日</td><td class="patent-data-table-td ">C06</td><td class="patent-data-table-td ">Publication</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">2009年11月11日</td><td class="patent-data-table-td ">C10</td><td class="patent-data-table-td ">Request of examination as to substance</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">2014年6月18日</td><td class="patent-data-table-td ">C14</td><td class="patent-data-table-td ">Granted</td><td class="patent-data-table-td "></td></tr></table><div class="patent-section-footer"></div></div><div class="modal-dialog" id="patent-images-lightbox"><div class="patent-lightbox-controls"><div class="patent-lightbox-rotate-controls"><div class="patent-lightbox-rotation-text">旋转</div><div class="rotate-icon rotate-ccw-icon"></div><div class="rotate-icon rotate-cw-icon"></div></div><div class="patent-lightbox-index-counter"></div><a class="patent-lightbox-fullsize-link" target="_blank">原始图片</a><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_right.png" alt="Next page"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_left.png" alt="Previous page"width="21" height="21" /></div></div><div class="modal-dialog-content"><div class="patent-lightbox-image-holder"><div class="patent-lightbox-placeholder"></div></div></div></div><script>_OC_initPatentsAtb({image_not_available_html: " 未提供图片。\x3ca href\x3d//docs.google.com/viewer?url\x3dpatentimages.storage.googleapis.com/pdfs/7da8cdbf37cd63b1a73e/CN101529382A.pdf\x3e查看 PDF\x3c/a\x3e"});</script></div></div></div></div></div><script>(function() {var href = window.location.href;if (href.indexOf('?') !== -1) {var parameters = href.split('?')[1].split('&');for (var i = 0; i < parameters.length; i++) {var param = parameters[i].split('=');if (param[0] == 'focus') {var elem = document.getElementById(param[1]);if (elem) {elem.focus();}}}}})();</script><script>_OC_addFlags({LockSrc:"/books/javascript/lock_50a6672b5f82ffbd39b7a9e87fd4594c.js", Host:"https://www.google.com/", IsBooksRentalEnabled:1, IsBrowsingHistoryEnabled:1, IsWebReaderSvgEnabled:0, IsImageModeNotesEnabled:1, IsOfflineBubbleEnabled:1, IsFutureOnSaleVolumesEnabled:1, IsBooksUnifiedLeftNavEnabled:1, IsMobileRequest:0, IsZipitFolderCollectionEnabled:1, IsAdsDisabled:0, IsEmbeddedMediaEnabled:1, IsImageModeAnnotationsEnabled:1, IsMyLibraryGooglePlusEnabled:1, IsImagePageProviderEnabled:1, IsBookcardListPriceSmall:0, IsInternalUser:0, IsBooksShareButtonEnabled:0, IsDisabledRandomBookshelves:0});_OC_Run({"enable_p13n":false,"is_cobrand":false,"sign_in_url":"https://www.google.com/accounts/Login?service=\u0026continue=https://www.google.com/patents%3Fcl%3Dzh%26hl%3Dzh-CN\u0026hl=zh-CN"}, {"volume_id":"","is_ebook":true,"volumeresult":{"has_flowing_text":false,"has_scanned_text":true,"can_download_pdf":false,"can_download_epub":false,"is_pdf_drm_enabled":false,"is_epub_drm_enabled":false,"download_pdf_url":"https://www.google.com/patents/download/%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E6%A1%86%E6%9E%B6.pdf?id=FxNtBwABERAJ\u0026hl=zh-CN\u0026output=pdf\u0026sig=ACfU3U3dmgX-m9c3forRIDqvMPe4IyYp1g"},"sample_url":"https://www.google.com/patents/reader?id=FxNtBwABERAJ\u0026hl=zh-CN\u0026printsec=frontcover\u0026output=reader\u0026source=gbs_atb_hover","is_browsable":true,"is_public_domain":true}, {});</script><div id="footer_table" style="font-size:83%;text-align:center;position:relative;top:20px;height:4.5em;margin-top:2em"><div style="margin-bottom:8px"><a href="https://www.google.com/search?hl=zh-CN"><nobr>Google&nbsp;首页</nobr></a> - <a href="//www.google.com/patents/sitemap/"><nobr>站点地图</nobr></a> - <a href="http://www.google.com/googlebooks/uspto.html"><nobr>美国专利商标局 (USPTO) 专利信息批量下载</nobr></a> - <a href="/intl/zh-CN/privacy/"><nobr>隐私权政策</nobr></a> - <a href="/intl/zh-CN/policies/terms/"><nobr>服务条款</nobr></a> - <a href="https://support.google.com/faqs/answer/2539193?hl=zh-CN"><nobr> 关于 Google 专利</nobr></a> - <a href="//www.google.com/tools/feedback/intl/zh-CN/error.html" onclick="try{_OC_startFeedback({productId: '72792',locale: 'zh-CN'});return false;}catch(e){}"><nobr>发送反馈</nobr></a></div></div> <script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-27188110-1");pageTracker._setCookiePath("/patents/");pageTracker._trackPageview();</script> </body></html>